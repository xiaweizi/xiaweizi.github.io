<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>『Android Tips』—— 模拟手势操作</title>
      <link href="/article/496f/"/>
      <content type="html"><![CDATA[<blockquote><p>平时 <code>Android</code> 开发中总会遇到奇葩的功能或者需求，这里做个记录和积累，以便后面开发过程中遇到类似的问题，可以快速的解决。<a href="http://xiaweizi.cn/categories/Android-tips/">Android tips</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个版本终于快结束了，历时一个月的时间，这段时间里重复着开发、找 <code>BUG</code> 和解 <code>BUG</code> 的工作，人已经快麻木了，不过最后看到 自己的开发成果还是蛮欣慰的，这可能就是程序员最简单的乐趣吧。这里看一下整体的效果图，一些细节不方便展示，大概有个预览吧：</p><a id="more"></a><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-05-29-jiaohu.gif" alt="整体交互"></p><p>里面有很多细小的知识点，比如阴影、状态栏颜色、下拉刷新、tab 悬浮、TCP 更新、数据缓存等等，或者是奇葩的 <code>BUG</code>，比如透明主题的 <code>Activity</code> 下 <code>Dialog</code> 的展示、<code>Fragment</code> 的 <code>setUserVisibleHint</code>没有按照预期执行等等，总之，在这次版本过后，感觉自己写 <code>UI</code>的能力提高了不少。</p><p>今天我介绍整个版本中一个非常小的细节处理，并对这个功能进行了稍微的扩展，希望能够帮到你们。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>进入正题，整个界面我是通过一个通用的下拉刷新控件 + <code>design</code> 库 <code>CoordinatorLayout</code> 实现的。那这里有个小需求，看一下效果：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-05-29-TouchPreview.gif" alt="card"></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-05-29-093648.png" alt="head"></p><p>说明：点击蓝色区域，展开资金页，同时整个界面向下滑动至初始位置。</p><p>功能简单，但是实现的过程发现，我外层滑动的 <code>View</code> 并不是 <code>RecyclerViedw</code> 或者是 <code>ListView</code> 更或者是 <code>ScrollView</code>，因此并没有相应的接口类似 <code>smoothScrollToPosition()</code> ，供我调用。只能自己想办法实现这个效果。</p><p>第一：研究 <code>CoordinatorLayout</code> 源码，搞懂他的滑动机制，这个对于我来说难度有点大，况且需求的预估时间也不允许我这样做。</p><p>第二：另辟蹊径，既然滑动是人为触发的，那就模拟手指滑动事件，让父 <code>View</code>下发滑动事件，让子 <code>View</code> 接收这个事件并处理。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然找到实现的思路了，那就动手来实现吧。在此之前需要对事件的分发机制有一定的了解，相信大部分小伙伴应该都很熟悉，不过可能也有的人没怎么接触这块，那我做个大致的介绍为后文进行铺垫。</p><h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p>搞懂事件分发也不难，只要搞懂事件的本质、操作的对象和传递的过程，脑海里就会对此有个基本的概念。</p><p><strong>什么是事件？</strong></p><p>当你接触到屏幕便会产生事件，<code>Android</code>系统将其封装成 <code>MotionEvent</code>。</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">desc</th></tr></thead><tbody><tr><td style="text-align:center">MotionEvent.ACTION_DOWN</td><td style="text-align:center">按下屏幕</td></tr><tr><td style="text-align:center">MotionEvent.ACTION_UP</td><td style="text-align:center">从屏幕上移开</td></tr><tr><td style="text-align:center">MotionEvent.ACTION_MOVE</td><td style="text-align:center">在屏幕上滑动</td></tr><tr><td style="text-align:center">MotionEvent.ACTION_CANCEL</td><td style="text-align:center">非人为取消</td></tr></tbody></table><p><strong>事件在哪传递呢？</strong></p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">desc</th></tr></thead><tbody><tr><td style="text-align:center">Activity</td><td style="text-align:center">事件传递的起点</td></tr><tr><td style="text-align:center">ViewGroup</td><td style="text-align:center">负责接收上层事件、处理或者下发</td></tr><tr><td style="text-align:center">MotionEvent.ACTION_MOVE</td><td style="text-align:center">负责接收上层事件和处理</td></tr></tbody></table><p><strong>事件传递的方向是什么？</strong></p><p>从 <code>Acitivity</code> -&gt; <code>ViewGroup</code> -&gt; <code>View</code> 一次传递，最终被处理或者被回传到最上层。</p><p><strong>如何控制事件的传递？</strong></p><p>主要有三个方法决定：</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">desc</th></tr></thead><tbody><tr><td style="text-align:center">dispatchTouchEvent()</td><td style="text-align:center">负责分发事件</td></tr><tr><td style="text-align:center">onInterceptTouchEvent()</td><td style="text-align:center">负责拦截事件</td></tr><tr><td style="text-align:center">onTouchEvent()</td><td style="text-align:center">负责事件的处理</td></tr></tbody></table><p><strong>事件传递的流程是什么？</strong></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-05-29-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.png" alt="事件分发"></p><p>上图来源于 <a href="https://www.jianshu.com/p/38015afcdb58" target="_blank" rel="noopener">事件分发机制详解</a>，特此感谢。</p><p>整体大概流程就这样，因为篇幅重点不在这，就不做多阐述，我写的可能有点粗糙，如果想看详细的介绍，推荐上方的事件分发机制详解文章。</p><h3 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h3><p>既然对事件分发有了大致的了解，那接下来就好办了，咱们可以直接构造这个 <code>MotionEvent</code> 然后让 <code>View</code> 处理，或者让 <code>Activity</code> 进行向下分发。</p><p><strong>模拟点击</strong></p><p>首先从简单的开始，模拟手势的点击操作。<strong>点击操作由一个 <code>Down</code> 和 <code>Up</code> 组合而成</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MotionEvent downEvent = MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, x, y, <span class="number">0</span>);</span><br><span class="line">        MotionEvent upEvent = MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, x, y, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 事件构造出来，接下来就是处理和分发了。</span></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">    ((View) object).onTouchEvent(downEvent);</span><br><span class="line">    ((View) object).onTouchEvent(upEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">    ((Activity) object).dispatchTouchEvent(downEvent);</span><br><span class="line">    ((Activity) object).dispatchTouchEvent(upEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记得将事件回收</span></span><br><span class="line">downEvent.recycle();</span><br><span class="line">upEvent.recycle();</span><br></pre></td></tr></table></figure><p>我这边封装成了一个静态方法，直接调用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simulateClick</span><span class="params">(View view, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        dealSimulateClick(view, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simulateClick</span><span class="params">(Activity activity, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    dealSimulateClick(activity, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 <code>Demo</code> 的运行效果：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-05-29-%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB.gif" alt="模拟点击"></p><p><strong>模拟滑动</strong></p><p>那滑动即一个 <code>Down</code> 、一个 <code>Up</code> 和 多个 <code>Move</code> 事件组成，为了添加一个滑动的延迟效果，使用 <code>Handler</code> 来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Handler handler;</span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">    View view = (View) object;</span><br><span class="line">    handler = <span class="keyword">new</span> ViewHandler(view);</span><br><span class="line">    view.onTouchEvent(MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN, startX, startY, <span class="number">0</span>));</span><br><span class="line">    GestureBean bean = <span class="keyword">new</span> GestureBean(startX, startY, endX, endY, duration, period);</span><br><span class="line">    Message.obtain(handler, <span class="number">1</span>, bean).sendToTarget();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">    Activity activity = (Activity) object;</span><br><span class="line">    handler = <span class="keyword">new</span> ActivityHandler(activity);</span><br><span class="line">    activity.dispatchTouchEvent(MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN, startX, startY, <span class="number">0</span>));</span><br><span class="line">    GestureBean bean = <span class="keyword">new</span> GestureBean(startX, startY, endX, endY, duration, period);</span><br><span class="line">    Message.obtain(handler, <span class="number">1</span>, bean).sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Handler</code> 里不断的发送 <code>Move</code> 事件，完成模拟手指滑动的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    WeakReference&lt;Activity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">    ActivityHandler(Activity activity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</span><br><span class="line">        mActivity = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Activity theActivity = mActivity.get();</span><br><span class="line">        <span class="keyword">if</span> (theActivity == <span class="keyword">null</span> || theActivity.isFinishing()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> downTime = SystemClock.uptimeMillis();</span><br><span class="line">        GestureBean bean = (GestureBean) msg.obj;</span><br><span class="line">        <span class="keyword">long</span> count = bean.count;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"handleMessage: "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= bean.totalCount) &#123;</span><br><span class="line">            theActivity.dispatchTouchEvent(MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_UP, bean.endX, bean.endY, <span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            theActivity.dispatchTouchEvent(MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_MOVE, bean.startX + bean.ratioX * count, bean.startY + bean.ratioY * count, <span class="number">0</span>));</span><br><span class="line">            bean.count++;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.obj = bean;</span><br><span class="line">            sendMessageDelayed(message, bean.period);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也封装了一个静态方法进行使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟手势滑动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> activity 当前的 activity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startX   起始位置 x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startY   起始位置 y</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endX     终点位置 x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endY     终点位置 y</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> duration 滑动时长 单位 ms</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period   滑动周期</span></span><br><span class="line"><span class="comment"> *                 &#123;<span class="doctag">@link</span> #LOW&#125; 慢</span></span><br><span class="line"><span class="comment"> *                 &#123;<span class="doctag">@link</span> #NORMAL&#125; 正常</span></span><br><span class="line"><span class="comment"> *                 &#123;<span class="doctag">@link</span> #HIGH&#125; 高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simulateScroll</span><span class="params">(Activity activity, <span class="keyword">float</span> startX, <span class="keyword">float</span> startY, <span class="keyword">float</span> endX, <span class="keyword">float</span> endY, <span class="keyword">long</span> duration, <span class="keyword">int</span> period)</span> </span>&#123;</span><br><span class="line">    dealSimulateScroll(activity, startX, startY, endX, endY, duration, period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 <code>Demo</code>  的运行效果：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-05-29-%E6%A8%A1%E6%8B%9F%E6%BB%91%E5%8A%A8.gif" alt="模拟滑动"></p><p>模拟手势画了一个⭐️，具体的源码我已经上传到了 <code>Github</code> 上 <a href="https://github.com/xiaweizi/ScollDemo" target="_blank" rel="noopener">ScrollDemo</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从一个非常小的需求实现细节就可以拓展很多知识点，不得不说这个版本学了很多东西，或许这次分享可以帮到你。</p>]]></content>
      
      <categories>
          
          <category> Android tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 平时积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『自定义View实战』—— 客服好评View</title>
      <link href="/article/18a/"/>
      <content type="html"><![CDATA[<blockquote><p>在工作中难免遇到自定义 <code>View</code> 的相关需求，本身这方面比较薄弱，因此做个记录，也是自己学习和成长的积累。<a href="https://link.jianshu.com/?t=http%3A%2F%2Fxiaweizi.cn%2Fcategories%2F%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589View%25E5%25AE%259E%25E6%2588%2598%2F" target="_blank" rel="noopener">自定义View实战</a>.</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个版本主要的任务就是完成<strong>环信客服</strong>系统的集成，上一篇文章 <a href="http://xiaweizi.cn/article/5d77/">仿IOS下载View</a> 也是这个版本开发需求中的一小部分，那今天介绍一下另一个小需求 <strong>客服好评</strong>。 <strong>客服好评</strong> 的功能在于用户对客服服务态度和质量的评价，也是作为考核客服服务的标准。相关代码已上传 <a href="https://github.com/xiaweizi/EvaluationCardView" target="_blank" rel="noopener">EvaluationCardView</a></p><a id="more"></a><p>看一下预览效果：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-31-%E6%95%B4%E4%BD%93%E9%A2%84%E8%A7%88.gif" alt="整体预览"></p><blockquote><p>需求简要说明</p><ol><li>默认状态为0星，不可提交</li><li>星星数量小于等于3，展示差评理由</li><li>差评理由云控，数量可变</li><li>差评理由可不选，可多选</li></ol></blockquote><p>我将分为3部分进行介绍。</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-31-image-201803311622551.png" alt="介绍"></p><ol><li>评级的 <code>RatingBar</code></li><li>差评理由 <code>TagView</code></li><li>整体评价的 <code>CardView</code></li></ol><h2 id="EvaluationRatingBar"><a href="#EvaluationRatingBar" class="headerlink" title="EvaluationRatingBar"></a>EvaluationRatingBar</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><code>Android</code> 原生就有这个空间 <code>RatingBar</code>,定制型不是很高，所以需要通过自定义来满足特定的产品需求。其实 <code>RatingBar</code>的主要用处就在于 <strong>评级</strong>，基本就是对服务进行等级评价，来决定服务的质量如何。</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>有需求才会有对应的实现，那么有哪些需要控制的属性呢。</p><table><thead><tr><th>属性名称</th><th>属性介绍</th></tr></thead><tbody><tr><td>mStarTotal</td><td>评级的总数</td></tr><tr><td>mSelectedCount</td><td>评级选中的数量</td></tr><tr><td>mStarResId</td><td>星星的资源文件</td></tr><tr><td>mHeight</td><td>星星的高度</td></tr><tr><td>mIntervalWidth</td><td>星星之间间隔的宽度</td></tr><tr><td>mEditable</td><td>是否可被点击</td></tr></tbody></table><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>既然星星有两种状态可供选择，那么单个 <code>View</code> 就使用 <code>CheckBox</code> 代替，首先初始化的时候，需要根据 <code>mStarTotal</code> 来控制添加多少个 <code>CheckBox</code> ，并根据 <code>mHeight</code> 高度和 <code>mIntervalWidth</code> 间隔来控制摆放的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mStarTotal; i++) &#123;</span><br><span class="line">    CheckBox cb = <span class="keyword">new</span> CheckBox(getContext());</span><br><span class="line">    LayoutParams layoutParams;</span><br><span class="line">    <span class="keyword">if</span> (mHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        layoutParams = <span class="keyword">new</span> LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutParams = <span class="keyword">new</span> LayoutParams((<span class="keyword">int</span>) mHeight, (<span class="keyword">int</span>) mHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    layoutParams.gravity = Gravity.CENTER_VERTICAL;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != mStarTotal - <span class="number">1</span>) &#123;</span><br><span class="line">        layoutParams.leftMargin = (<span class="keyword">int</span>) mIntervalWidth;</span><br><span class="line">        layoutParams.rightMargin = (<span class="keyword">int</span>) mIntervalWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        layoutParams.rightMargin = (<span class="keyword">int</span>) mIntervalWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == mStarTotal - <span class="number">1</span>) &#123;</span><br><span class="line">        layoutParams.leftMargin = (<span class="keyword">int</span>) mIntervalWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(cb, layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在父布局 <code>LinearLayout</code> 中添加 所有的 <code>CheckBox</code>。</p><p>至于点击事件的回调，可以在每次点击的时候进行遍历，获取 <code>CheckBox</code> 的选中状态，并通过 <code>callback</code> 回调出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mStarTotal; i++) &#123;</span><br><span class="line">    CheckBox cb = (CheckBox) getChildAt(i);</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= position) &#123;</span><br><span class="line">    cb.setChecked(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; position) &#123;</span><br><span class="line">    cb.setChecked(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mOnRatingChangeListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mOnRatingChangeListener.onChange(mSelectedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-31-ratingBar.gif" alt="EvaluationRatingBar"></p><h2 id="EvaluationNegReasonsLayout"><a href="#EvaluationNegReasonsLayout" class="headerlink" title="EvaluationNegReasonsLayout"></a>EvaluationNegReasonsLayout</h2><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>当用户给出差评的时候，需要展示对应的差评理由选择。理由云控，数量可变，内容可变。可单选，可不选，可多选。</p><p>主要的难点和重点在于根据理由内容的长短进行展示，如果内容长则显示一条，如果内容短可以显示多条。</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>我们都知道 <code>View</code> 的测量工作主要是在 <code>onMeasure</code> 里进行。 <strong>宽度计算</strong>，可以先测量出每个子 <code>View</code> 的宽度，每次叠加，如果超过父布局限制的宽度则换行。 <strong>高度计算</strong>，每次换行叠加高度，每一行的高度取子 <code>View</code> 高度的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历每个子元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) &#123;</span><br><span class="line">    View childView = getChildAt(i);</span><br><span class="line">    <span class="comment">//测量每一个子view的宽和高</span></span><br><span class="line">    measureChild(childView, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到测量的宽和高</span></span><br><span class="line">    <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();</span><br><span class="line">    <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span></span><br><span class="line">    MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">    <span class="keyword">int</span> realChildWidth = childWidth + mlp.leftMargin + mlp.rightMargin;</span><br><span class="line">    <span class="keyword">int</span> realChildHeight = childHeight + mlp.topMargin + mlp.bottomMargin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前一行的宽度加上要加入的子view的宽度大于父容器给的宽度，就换行</span></span><br><span class="line">    <span class="keyword">if</span> ((lineWidth + realChildWidth) &gt; sizeWidth) &#123;</span><br><span class="line">    <span class="comment">//换行</span></span><br><span class="line">    resultWidth = Math.max(lineWidth, realChildWidth);</span><br><span class="line">    resultHeight += realChildHeight;</span><br><span class="line">    <span class="comment">//换行了，lineWidth和lineHeight重新算</span></span><br><span class="line">    lineWidth = realChildWidth;</span><br><span class="line">    lineHeight = realChildHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不换行，直接相加</span></span><br><span class="line">    lineWidth += realChildWidth;</span><br><span class="line">    <span class="comment">//每一行的高度取二者最大值</span></span><br><span class="line">    lineHeight = Math.max(lineHeight, realChildHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历到最后一个的时候，肯定走的是不换行</span></span><br><span class="line">    <span class="keyword">if</span> (i == childCount - <span class="number">1</span>) &#123;</span><br><span class="line">    resultWidth = Math.max(lineWidth, resultWidth);</span><br><span class="line">    resultHeight += lineHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setMeasuredDimension(modeWidth == MeasureSpec.EXACTLY ? sizeWidth : resultWidth,modeHeight == MeasureSpec.EXACTLY ? sizeHeight : resultHeight);</span><br></pre></td></tr></table></figure><p>既然 <strong>宽高</strong> 计算完了，剩下就是子 <code>View</code> 的摆放了，自然是在在 <code>onLayout()</code> 中实现。摆放就比较简单了，同样需要遍历所有的子 <code>View</code>，最终调用 <code>layout(left, top, right, bottom)</code> 方法进行位置的摆放。宽度不断叠加，当超过父布局的宽度，则将 <code>left</code> 置为 0，高度记上一行子 <code>View</code> 的最大高度，以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> realWidht = getWidth();</span><br><span class="line">    <span class="keyword">int</span> childLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childTop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历子控件，记录每个子view的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) &#123;</span><br><span class="line">        View childView = getChildAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过View.GONE的子View</span></span><br><span class="line">        <span class="keyword">if</span> (childView.getVisibility() == View.GONE) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到测量的宽和高</span></span><br><span class="line">        <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();</span><br><span class="line">        <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span></span><br><span class="line">        MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childLeft + mlp.leftMargin + childWidth + mlp.rightMargin &gt; realWidht) &#123;</span><br><span class="line">            <span class="comment">//换行处理</span></span><br><span class="line">            childTop += (mlp.topMargin + childHeight + mlp.bottomMargin);</span><br><span class="line">            childLeft = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//布局</span></span><br><span class="line">        <span class="keyword">int</span> left = childLeft + mlp.leftMargin;</span><br><span class="line">        <span class="keyword">int</span> top = childTop + mlp.topMargin;</span><br><span class="line">        <span class="keyword">int</span> right = childLeft + mlp.leftMargin + childWidth;</span><br><span class="line">        <span class="keyword">int</span> bottom = childTop + mlp.topMargin + childHeight;</span><br><span class="line">        childView.layout(left, top, right, bottom);</span><br><span class="line">        childLeft += (mlp.leftMargin + childWidth + mlp.rightMargin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下最终的效果：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-31-ReasonLayout.gif" alt="reasonsLayout"></p><h2 id="EvaluationCardView"><a href="#EvaluationCardView" class="headerlink" title="EvaluationCardView"></a>EvaluationCardView</h2><p>这个就简单了，配合着 <code>AlertDialog</code> 弹窗显示，将之前介绍的 <code>EvaluationRatingBar</code> 和 <code>EvaluationNegReasonsLayout</code> 结合在一块，并根据自己特殊的产品需求来定制对应的效果。最后在点击提交的时候通过接口回调的方式，将最终的结果回调出来并处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnEvaluationCallback</span><span class="params">(OnEvaluationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mCallback = callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnEvaluationCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvaluationCommitClick</span><span class="params">(<span class="keyword">int</span> starCount, Set&lt;String&gt; reasons)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>starCount: 即为评级的等级。reasons：即为选择的差评理由</p></blockquote><p>最终调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EvaluationCardView cardView = <span class="keyword">new</span> EvaluationCardView(<span class="keyword">this</span>);</span><br><span class="line">List&lt;String&gt; reasonsData = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">reasonsData.add(<span class="string">"回复太慢"</span>);</span><br><span class="line">reasonsData.add(<span class="string">"对业务不了解"</span>);</span><br><span class="line">reasonsData.add(<span class="string">"服务态度差"</span>);</span><br><span class="line">reasonsData.add(<span class="string">"问题没有得到解决"</span>);</span><br><span class="line">cardView.setReasonsData(reasonsData);</span><br><span class="line">cardView.show();</span><br><span class="line">cardView.setOnEvaluationCallback(<span class="keyword">new</span> EvaluationCardView.OnEvaluationCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvaluationCommitClick</span><span class="params">(<span class="keyword">int</span> starCount, Set&lt;String&gt; reasons)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String reason : reasons) &#123;</span><br><span class="line">            sb.append(<span class="string">"\n"</span>).append(reason);</span><br><span class="line">        &#125;</span><br><span class="line">        Toasty.success(EvaluationCardViewActivity.<span class="keyword">this</span>, <span class="string">"评价成功\n"</span> + <span class="string">"星星数量："</span> + starCount + <span class="string">"\n差评理由："</span> + sb.toString(), Toast.LENGTH_LONG, <span class="keyword">true</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>具体的实现代码请查看 <a href="https://github.com/xiaweizi/EvaluationCardView" target="_blank" rel="noopener">EvaluationCardView</a>。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://github.com/hanhailong/FlowTag" target="_blank" rel="noopener">FlowTag</a></p>]]></content>
      
      <categories>
          
          <category> 自定义View实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作积累 </tag>
            
            <tag> 自定义 View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『程序员必备软件』—— 短小精悍的GIF录制软件LICEcap</title>
      <link href="/article/licecap/"/>
      <content type="html"><![CDATA[<blockquote><p>平时学习和开发的过程中，总有一些软件可以提高工作或者开发效率，特此记录一下，并附上简单的入门教程，方便自己查找，但愿也可以帮助到您 <a href="http://xiaweizi.cn/article/3cfa/">程序员必备软件</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想必经常写博客的小伙伴经常会需要上传运行的效果图，也就是 <code>GIF</code> 动态图，目前有很多方式可供选择。</p><ol><li>先使用视频录制软件(比如QQ自带的录制)，然后通过某些转换工具(比如 <code>GIF Brewery</code>)将视频文件转换成 <code>GIF</code>格式</li><li>或者直接使用某些 <code>GIF</code> 录制工具 <code>GifCam</code> 也很不错</li></ol><a id="more"></a><p>那今天我要介绍的就是一款非常轻量级的但功能强大的 <code>GIF</code> 录制工具 — <strong>LICEcap</strong>。</p><blockquote><p>对此有了解的请绕过。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">LICEcap</a> 可以捕获桌面区域并将其直接保存为 <code>.gif</code> 文件，可直接查看或者在网页上查看。 <strong>操作简单</strong>、 <strong>功能强大</strong>、 <strong>性能卓越</strong>！这就是我一直使用它的原因。</p><p>作者还开源了并放在了 <code>Github</code> 上。 <a href="https://github.com/justinfrankel/licecap" target="_blank" rel="noopener">源码</a></p><p>除了 <code>.gif</code> 格式之外， <code>LICEcap</code> 还支持自己原生无损 <code>.lcf</code> 文件格式，该格式允许比 <code>.gif</code> 更高的压缩比，更高的质量(每帧超过 256 色)，以及更精确的时间戳。</p><p>展示一下大致的效果(因为不想用别的录制软件来录制 <code>LICEcap</code> 的录制过程，就直接使用官网的效果)：</p><p><img src="https://www.cockos.com/licecap/how_to_licecap.gif" alt="官网展示效果"></p><h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><p>拥有以下的功能特点：</p><ul><li>可以录制为 <code>.gif</code> 或者是 <code>.lcf</code> 文件</li><li>在录制的过程中支持拖拽屏幕捕捉框</li><li>支持暂停和重新录制功能</li><li>支持添加标题功能</li><li>在录制的过程中，支持快捷键操作暂停功能</li><li>可调节录制帧率到最大来限制 <code>CPU</code> 的使用率</li><li>支持记录鼠标按钮按下</li><li>录制过程中展示录制时间</li></ul><h2 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h2><ul><li><strong>Windows</strong>。 Windows XP/Vista/7/8/8.1/10</li><li><strong>OSX</strong>。 macOS 10.4+</li><li><strong>Linux</strong>。 大部分</li><li>给力的 <code>CPU</code></li><li>1GB+ 的 <code>RAM</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="操作预览"><a href="#操作预览" class="headerlink" title="操作预览"></a>操作预览</h3><p>操作是非常简单的，看一下下面的录制预览图：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-24-6D389141-DCC9-480A-8E5B-A3E5968E3DBB-1.png" alt="预览"></p><blockquote><ol><li>录制的帧率。帧率越大，效果越好，文件大小越大</li><li>录制区域大小。当然也可以通过拖拽的方式进行区域的选择</li><li>开始</li><li>暂停</li></ol></blockquote><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>点击录制后，需要进行一些基础的配置。</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-24-47746539-37D1-469A-A000-7BE5FDAF3D05.png" alt="基础配置"></p><blockquote><p>除了 <strong>文件名称</strong> 和 <strong>保存路径</strong> 这些必须配置外，还有一些可以选择配置的。</p><ol><li>标题的帧率</li><li>录制的时间</li><li>鼠标的点击</li><li>标题内容</li></ol></blockquote><h3 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h3><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-24-DownloadView.gif" alt=" 开始录制"></p><p>我帧率调到了 <strong>30</strong>，还是蛮高的， <strong>7</strong> 秒钟，<strong>2M</strong> 多，效果还是蛮不错的。</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><a href="https://www.cockos.com/licecap/licecap128-install.exe" target="_blank" rel="noopener">LICEcap v1.28 for Windows</a> (更新于 12/2/17) (230kb)</p><p><a href="https://www.cockos.com/licecap/licecap128.dmg" target="_blank" rel="noopener">LICEcap v1.28 for OSX</a> (更新于 12/2/17) (730kb)</p><p><a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">官网地址</a></p><p><a href="https://github.com/justinfrankel/licecap" target="_blank" rel="noopener">源码</a></p>]]></content>
      
      <categories>
          
          <category> 程序员必备软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
            <tag> 提高效率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『自定义View实战』—— 仿ios图标下载view</title>
      <link href="/article/5d77/"/>
      <content type="html"><![CDATA[<blockquote><p>在工作中难免遇到自定义 <code>View</code> 的相关需求，本身这方面比较薄弱，因此做个记录，也是自己学习和成长的积累。<a href="https://link.jianshu.com/?t=http%3A%2F%2Fxiaweizi.cn%2Fcategories%2F%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589View%25E5%25AE%259E%25E6%2588%2598%2F" target="_blank" rel="noopener">自定义View实战</a>.</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近项目需要接入环信客服 <code>SDK</code> ，我配合这同事完成，其中我负责文件下载这部分。</p><p>因为时间比较紧张，8 天的时间完成 <strong>环信客服模块</strong> 的接入，就直接用了环信提供的 <code>UI</code> 控件，但是一些细节的部分， <code>UI</code> 还是会给出设计图，按照设计图完成最终效果。</p><a id="more"></a><p><code>UI</code>那边直接让我参考 <code>IOS</code>的实现效果:</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-23-12A0620B-7476-42BE-BE83-09280E35CD18.png" alt="UI效果"></p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-23-DownloadView.gif" alt="最终效果"></p><p>源码请看 <a href="https://github.com/xiaweizi/DownloadLoadingView" target="_blank" rel="noopener">DownloadLoadingView</a></p><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>面对这样的需要应该怎么实现呢？其实实现的方式可能不止我想的这种，我就讲述一下我是如何处理的。</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-23-115616.png" alt="预览图"></p><p>首先，可以分成三部分：</p><ol><li>半透明的背景</li><li>全透明的环</li><li>实心全透明的弧</li></ol><p>那怎么实现背景半透明，而圆环和弧又是全透明的。顿时有个想法，要是两张图片重叠的部分能被抠出掉，也就是变成全透明，那岂不是非常容易就实现了。</p><p>圆环和弧既然是盖在了背景上，理当直接变成透明。那 <code>Android</code> 有对应处理的 <code>API</code>吗？答案是肯定的。 <strong>setXfermode()</strong> 用于设置图像的过度模式，其中 <strong>PorterDuff.Mode.CLEAR</strong> 为清除模式则可以实现上述的效果。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="一系列的初始化"><a href="#一系列的初始化" class="headerlink" title="一系列的初始化"></a>一系列的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DownloadLoadingView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.DownloadLoadingView);</span><br><span class="line">    mRadius = typedArray.getDimension(R.styleable.DownloadLoadingView_radius, RADIUS_DEFAULT);</span><br><span class="line">    mStrokeWidth = typedArray.getDimension(R.styleable.DownloadLoadingView_strokeWidth, STROKE_WIDTH_DEFAULT);</span><br><span class="line">    mMaxProgress = typedArray.getInteger(R.styleable.DownloadLoadingView_maxProgress, MAX_PROGRESS_DEFAULT);</span><br><span class="line">    mRoundRadius = typedArray.getDimension(R.styleable.DownloadLoadingView_roundRadius, ROUND_RADIUS_DEFAULT);</span><br><span class="line">    mBackgroundColor = typedArray.getColor(R.styleable.DownloadLoadingView_backgroundColor, getResources().getColor(R.color.bg_default));</span><br><span class="line">    Log.i(TAG, <span class="string">"radius:"</span> + mRadius);</span><br><span class="line">    typedArray.recycle();</span><br><span class="line">    setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);<span class="comment">//关闭硬件加速</span></span><br><span class="line">    paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>记得需要关闭硬件加速，不然会没有效果。</p></blockquote><h3 id="绘制背景"><a href="#绘制背景" class="headerlink" title="绘制背景"></a>绘制背景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">paint.setColor(mBackgroundColor);</span><br><span class="line">paint.setStyle(Paint.Style.FILL);</span><br><span class="line">RectF round = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">canvas.drawRoundRect(round, mRoundRadius, mRoundRadius, paint);</span><br></pre></td></tr></table></figure><blockquote><p>设置背景颜色，样式为填充，绘制圆角矩形</p></blockquote><h3 id="绘制圆环"><a href="#绘制圆环" class="headerlink" title="绘制圆环"></a>绘制圆环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">paint.setColor(Color.RED);</span><br><span class="line">paint.setStrokeWidth(mStrokeWidth);</span><br><span class="line"><span class="comment">// 采用 clear 的方式</span></span><br><span class="line">paint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">canvas.drawCircle(getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>, mRadius, paint);</span><br></pre></td></tr></table></figure><blockquote><p>圆环的颜色可以随意设置，毕竟最后会被抠除掉，</p><p>设置 <code>PorterDuff.Mode.CLEAR</code> 类型模式绘制圆环</p></blockquote><h3 id="绘制圆"><a href="#绘制圆" class="headerlink" title="绘制圆"></a>绘制圆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);</span><br><span class="line"><span class="keyword">float</span> sweepAngle = <span class="number">360</span> * mProgress / mMaxProgress;</span><br><span class="line">RectF rectF = <span class="keyword">new</span> RectF(getWidth() / <span class="number">2</span> - mRadius, getHeight() / <span class="number">2</span> - mRadius, getWidth() / <span class="number">2</span> + mRadius, getHeight() / <span class="number">2</span> + mRadius);</span><br><span class="line">canvas.drawArc(rectF, -<span class="number">90</span>, sweepAngle, <span class="keyword">true</span>, paint);</span><br><span class="line"><span class="comment">// 记得设置为 null 不然会没有效果</span></span><br><span class="line">paint.setXfermode(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>根据当前的进度绘制相对应的弧，并且结束的时候将 <code>Xfermode</code> 模式置为 <code>null</code>。</p></blockquote><p>这样效果就结束了，贼简单。完整的代码请看 <a href="https://github.com/xiaweizi/DownloadLoadingView" target="_blank" rel="noopener">DownloadLoadingView</a></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>文中提到了 <code>PorterDuff.Mode</code>，里面存储了大量的枚举，当我们需要处理图像的时候就会用到，但是对每种类型并没有特别的了解。每次使用的时候都需要查资料，然后确定到底需要使用哪种模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Xfermode <span class="title">setXfermode</span><span class="params">(Xfermode xfermode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> xfermodeNative = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (xfermode != <span class="keyword">null</span>)</span><br><span class="line">        xfermodeNative = xfermode.native_instance;</span><br><span class="line">    native_setXfermode(mNativePaint, xfermodeNative);</span><br><span class="line">    mXfermode = xfermode;</span><br><span class="line">    <span class="keyword">return</span> xfermode;。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Mode &#123;</span><br><span class="line">    <span class="comment">/** [0, 0] */</span></span><br><span class="line">    CLEAR       (<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/** [Sa, Sc] */</span></span><br><span class="line">    SRC         (<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/** [Da, Dc] */</span></span><br><span class="line">    DST         (<span class="number">2</span>),</span><br><span class="line">    <span class="comment">/** [Sa + (1 - Sa)*Da, Rc = Sc + (1 - Sa)*Dc] */</span></span><br><span class="line">    SRC_OVER    (<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/** [Sa + (1 - Sa)*Da, Rc = Dc + (1 - Da)*Sc] */</span></span><br><span class="line">    DST_OVER    (<span class="number">4</span>),</span><br><span class="line">    <span class="comment">/** [Sa * Da, Sc * Da] */</span></span><br><span class="line">    SRC_IN      (<span class="number">5</span>),</span><br><span class="line">    <span class="comment">/** [Sa * Da, Sa * Dc] */</span></span><br><span class="line">    DST_IN      (<span class="number">6</span>),</span><br><span class="line">    <span class="comment">/** [Sa * (1 - Da), Sc * (1 - Da)] */</span></span><br><span class="line">    SRC_OUT     (<span class="number">7</span>),</span><br><span class="line">    <span class="comment">/** [Da * (1 - Sa), Dc * (1 - Sa)] */</span></span><br><span class="line">    DST_OUT     (<span class="number">8</span>),</span><br><span class="line">    <span class="comment">/** [Da, Sc * Da + (1 - Sa) * Dc] */</span></span><br><span class="line">    SRC_ATOP    (<span class="number">9</span>),</span><br><span class="line">    <span class="comment">/** [Sa, Sa * Dc + Sc * (1 - Da)] */</span></span><br><span class="line">    DST_ATOP    (<span class="number">10</span>),</span><br><span class="line">    <span class="comment">/** [Sa + Da - 2 * Sa * Da, Sc * (1 - Da) + (1 - Sa) * Dc] */</span></span><br><span class="line">    XOR         (<span class="number">11</span>),</span><br><span class="line">    <span class="comment">/** [Sa + Da - Sa*Da, Sc*(1 - Da) + Dc*(1 - Sa) + min(Sc, Dc)] */</span></span><br><span class="line">    DARKEN      (<span class="number">12</span>),</span><br><span class="line">    <span class="comment">/** [Sa + Da - Sa*Da, Sc*(1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)] */</span></span><br><span class="line">    LIGHTEN     (<span class="number">13</span>),</span><br><span class="line">    <span class="comment">/** [Sa * Da, Sc * Dc] */</span></span><br><span class="line">    MULTIPLY    (<span class="number">14</span>),</span><br><span class="line">    <span class="comment">/** [Sa + Da - Sa * Da, Sc + Dc - Sc * Dc] */</span></span><br><span class="line">    SCREEN      (<span class="number">15</span>),</span><br><span class="line">    <span class="comment">/** Saturate(S + D) */</span></span><br><span class="line">    ADD         (<span class="number">16</span>),</span><br><span class="line">    OVERLAY     (<span class="number">17</span>);</span><br><span class="line">    Mode(<span class="keyword">int</span> nativeInt) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nativeInt = nativeInt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> nativeInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中已经说明了该模式到的透明度计算和颜色的计算方式，首先我们要了解一下基本的概念：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sa：全称为Source alpha，表示源图的Alpha通道；</span><br><span class="line">Sc：全称为Source color，表示源图的颜色；</span><br><span class="line">Da：全称为Destination alpha，表示目标图的Alpha通道；</span><br><span class="line">Dc：全称为Destination color，表示目标图的颜色.</span><br></pre></td></tr></table></figure><p>来看一下权威的展示图：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-23-122007.png" alt="mode预览图"></p><p>我觉得 <a href="https://www.jianshu.com/p/d11892bbe055" target="_blank" rel="noopener">各个击破搞明白 PorterDuff.Mode</a> 这篇文章写的特别好，不是很懂的小伙伴可以看一下，在这里也表示一下感谢。</p>]]></content>
      
      <categories>
          
          <category> 自定义View实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作积累 </tag>
            
            <tag> 自定义 View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员必备软件(持续更新中...)</title>
      <link href="/article/3cfa/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>程序员的任务就是开发，那开发自然少不了一些软件的帮助，那么有哪些软件是开发必须的或者是一定程度上提高开发效率的呢？</p><p>接下来就会介绍一下我自己电脑上必备的软件和<strong>使用教程</strong>(有些自己写的，也有是别人写的)。本篇文章主要针对 <code>Mac</code> 的用户，当然介绍的软件也有 <code>windows</code> 版本，就麻烦看客自行上网搜索吧。</p><p>先展示一下我电脑上的软件截图：</p><a id="more"></a><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171703014.png" alt="mage-20180317170301"></p><p>或许你也有相同的软件，那么就请你忽略这些。上面的软件大部分我都有安装包，如果有需要的请私聊我获取软件的资源，毕竟一些破解的不方便给出，还请见谅。</p><h2 id="提高效率软件"><a href="#提高效率软件" class="headerlink" title="提高效率软件"></a>提高效率软件</h2><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171714388.png" alt="Typora"></p><p>一款集 <strong>编辑预览</strong> 于一身的 <code>MarkDown</code> 编辑器，界面简洁，功能强大，操作简单。</p><p><a href="http://xiaweizi.cn/article/typora/">教程入口</a></p><h2 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h2><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251133533.png" alt="iPic"></p><p><code>Mac</code> 上非常好用的图床神器，配合着 <a href="http://xiaweizi.cn/article/typora/">Typora</a> 可以大大提高写博客的效率。 <code>Windows</code> 上有对应的 <a href="https://www.jianshu.com/p/d0bd91d38011" target="_blank" rel="noopener">MPic</a>。</p><p><a href="https://www.toolinbox.net/iPic/iPic.html" target="_blank" rel="noopener">教程入口</a></p><h3 id="LICEcap"><a href="#LICEcap" class="headerlink" title="LICEcap"></a>LICEcap</h3><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-24-image-201803242128590.png" alt="LICEcap"></p><p>一款 <strong>操作简单、功能强大、性能卓越</strong> 的屏幕 <code>GIF</code> 录制工具软件。</p><p><a href="http://xiaweizi.cn/article/licecap/">教程入口</a></p><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171713278.png" alt="Android Studio"></p><p>这可是吃饭的软件，我是一名 <code>Android</code> 程序的开发者，自然少不了。</p><p><a href="https://blog.csdn.net/qq_38080117/article/details/79083996" target="_blank" rel="noopener">教程入口</a></p><h3 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h3><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171713555.png" alt="Intellij IDEA"></p><p>这个一般作为我巩固 <code>Java</code> 基础或是学习后端的软件。</p><p><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/about-this-tutorial.html" target="_blank" rel="noopener">教程入口1</a></p><p><a href="https://blog.csdn.net/yanjiangdi/article/details/77864610?locationNum=4&amp;fps=1" target="_blank" rel="noopener">教程入口2</a></p><h3 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h3><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171714167.png" alt="PyCharm"></p><p><code>Python</code> 的开发工具。</p><p><a href="https://blog.csdn.net/u013088062/article/details/50388329" target="_blank" rel="noopener">教程入口</a></p><h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251128305.png" alt="网易云音乐"></p><p>这个不用多说吧，程序员和音乐更配哦，最近网易云不少音乐的版权要了回来，更加的爱它了。</p><h2 id="Latern"><a href="#Latern" class="headerlink" title="Latern"></a>Latern</h2><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251139527.png" alt="mage-20180325113952"></p><p>额…你懂得，输入我的邀请码 57QP4H 来获得三个月的蓝灯专业版！<a href="https://github.com/getlantern/forum" target="_blank" rel="noopener">立即下载</a> 。不需要的可以忽视。</p><p>未完待续…</p>]]></content>
      
      <categories>
          
          <category> 程序员必备软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
            <tag> 提高效率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『程序员必备软件』—— 编辑预览于一身的 Typora</title>
      <link href="/article/typora/"/>
      <content type="html"><![CDATA[<p>平时学习和开发的过程中，总有一些软件可以提高工作或者开发效率，特此记录一下，并附上简单的入门教程，方便自己查找，但愿也可以帮助到您 <a href="http://xiaweizi.cn/article/3cfa/">程序员必备软件</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为程序员，相信对 <code>MarkDown</code> 语法并不陌生，平时知识的积累，博客的编写或者是工作的报告都或多或少会用到。</p><blockquote><p><code>Markdown</code> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p></blockquote><p>那具体的介绍和使用语法就不用过多介绍，较为简单，网上一搜一大把。对应的编辑器也很多，比如之前使用的 <code>MacDown</code>，或者是笔记软件，更或者是博文平台都是支持 <code>MarkDown</code> 语法的。就我使用的过程来看，大部分的界面都是编辑+预览的，那 <code>Typora</code> 不同于其他的编辑工具，当输入相应的标记符号，系统便会自动渲染文本，形成相对应的格式。因此就达到了 <strong>编辑与预览</strong> 同一界面的效果。</p><a id="more"></a><p>看一下大概的效果，后面会一一介绍：</p><p><img src="/Users/xiaweizi/Desktop/pic/2018-03-17-Typora%E9%A2%84%E8%A7%88%E6%95%88%E6%9E%9C.png" alt="大概效果">功能还有很多，确实值得拥有。</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><a href="https://www.baidu.com/link?url=KYhuNjN8103k0Uz6EMLJnj07U89iX26TMslP5Yf1CUm&amp;wd=&amp;eqid=8aea3c1900083620000000035aacb943" target="_blank" rel="noopener"><em>Typora</em> — a markdown editor, markdown reader.</a></p><p>进入官网可进行下载，目前 <code>Mac</code>、 <code>Windows</code> 和 <code>Linux</code> 都有对应的版本，当然也有详细的使用介绍。</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171450002.png" alt="mage-20180317145000"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><code>Typora</code> 支持原生的标记语法使用，也支持非常强大的快捷键使用，两者配合着使用，很大程度上可以提高工作效率。</p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E6%A0%87%E9%A2%98.gif" alt="标题"></p><h4 id="特殊样式"><a href="#特殊样式" class="headerlink" title="特殊样式"></a>特殊样式</h4><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E7%89%B9%E6%AE%8A%E6%A0%B7%E5%BC%8F.gif" alt="特殊样式"></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E5%88%97%E8%A1%A8.gif" alt="列表"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E4%BB%A3%E7%A0%81.gif" alt="代码"></p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E8%A1%A8%E6%A0%BC.gif" alt="表格"></p><h4 id="流程图-时序图"><a href="#流程图-时序图" class="headerlink" title="流程图 时序图"></a>流程图 时序图</h4><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E6%B5%81%E7%A8%8B%E5%9B%BE.gif" alt="流程图"></p><p>相关对应的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 流程图 flow</span><br><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line"></span><br><span class="line">// sequence</span><br><span class="line">Title:连接建立的过程</span><br><span class="line">客户主机-&gt;服务器主机: 连接请求（SYN=1,seq=client_isn） </span><br><span class="line">服务器主机-&gt;客户主机: 授予连接（SYN=1,seq=client_isn）\n ack=client_isn+1</span><br><span class="line">客户主机-&gt;服务器主机: 确认（SYN=0,seq=client_isn+1）\nack=server_isn+1</span><br><span class="line"></span><br><span class="line">// mermaid</span><br><span class="line">graph TD</span><br><span class="line">client1--&gt;|read / write|SVN((SVN server))</span><br><span class="line">client2--&gt;|read only|SVN</span><br><span class="line">client3--&gt;|read / write|SVN</span><br><span class="line">client4--&gt;|read only|SVN</span><br><span class="line">client5(...)--&gt;SVN</span><br><span class="line">SVN---|store the data|sharedrive</span><br></pre></td></tr></table></figure><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>有人说插入图片凭什么算作为 <strong>进阶使用</strong>，不就一行代码的事情吗 <code>![]()</code>，但是我要说的可不一样。</p><p>我们平常需要插入文章应该怎么办？</p><ol><li>直接从网络上获取图片的链接地址，作为自己的图片链接(万一链接改变，图片便显示不出)</li><li>直接本地文件的相对路径(万一博客需要共享，自然别人看不到图片)</li><li>先通过别的平台上传图片(七牛云)，然后拷贝链接地址(操作较为麻烦)</li><li>当然可以直接在简书上直接拖拽文件到编辑见面(那又何必用 <strong>Typora</strong>。。。)</li></ol><p>有图床神器 <strong><a href="https://itunes.apple.com/cn/app/id1101244278?mt=12" target="_blank" rel="noopener">iPic</a></strong>，可以通过拖拽、快捷键等方式上传图片，支持微博、七牛、又拍、阿里云、Imgur、Flickr、Amazon S3 等图床，自动保存 Markdown 格式链接，给你前所未有的插图体验。</p><p>看一下效果:</p><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fewqw208xmg30j60aske8.gif" alt="效果"></p><p>或者是直接拷贝粘贴图片到编辑器中也可以：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87.gif" alt="截图拷贝"></p><p>还可以支持多文件上传哦，具体教程请见 <a href="https://www.toolinbox.net/iPic/" target="_blank" rel="noopener">ipic使用教程</a></p><h4 id="版本回溯"><a href="#版本回溯" class="headerlink" title="版本回溯"></a>版本回溯</h4><p>我觉得这是它最牛逼的地方了！有点点类似开发过程中的代码回退，比如你想回到某个版本，通过 <code>git reset [commit]</code> 即可回到需要的版本，那 <strong>Typora</strong> 的效果如何呢？</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171558408.png" alt="mage-20180317155840"></p><p>首先点击 <strong>浏览所有版本</strong>，即可以看到历史的版本：</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171603346.png" alt="mage-20180317160334"></p><h4 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h4><p><strong>Typora</strong> 支持各种主题的更换</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-image-201803171607569.png" alt="mage-20180317160756"></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-17-%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2.gif" alt="主题更换"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Typora</strong> 用习惯了后，真的是离不开他，不仅界面相当友好，而且快捷键功能强大，更提供了方面的插入图片方式，拥有并学会它，一定可以帮助您提高开发效率的。</p>]]></content>
      
      <categories>
          
          <category> 程序员必备软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具软件 </tag>
            
            <tag> 提高效率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记(持续更新...)</title>
      <link href="/article/7b67faab/"/>
      <content type="html"><![CDATA[<blockquote><p>书籍是人类进步的阶梯</p></blockquote><p>已经开发<code>Android</code>一年的我，虽然也看了几本书，但是都是走马观花式看法，并没有细致的了解其内部原理。</p><p>因此打算利用空余时间充实一下自己的知识体系，夯实基础，毕竟底层基础决定上层建筑。顺便会记录一下学习笔记，这个笔记的主要作用也是在于巩固自己的学习内容，更是方便后面对遗忘知识点的回顾。</p><p>记录方式以文章内容为主，附带本人的学习心得和练习代码，最终能对所读书籍的内容做到百分之八十的吸收，为以后的开发编程铺下基础。</p><h3 id="Thinking-in-java"><a href="#Thinking-in-java" class="headerlink" title="Thinking in java"></a><a href="http://xiaweizi.cn/categories/Thinking-In-Java-读书笔记/">Thinking in java</a></h3><blockquote><p>这本书是相当厚，当然内容也是很丰富，对<code>Java</code>知识点的介绍循序渐进，不论是<code>Java</code>的入门还是进阶都是不二之选，绝对值得一读！</p></blockquote><a id="more"></a><table><thead><tr><th style="text-align:left">章</th><th style="text-align:left">标题</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_1/">对象导论</a></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_2/">一切都是对象</a></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_3/">操作符</a></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_4/">控制执行流程</a></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_5/">初始化与清理</a></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_6/">访问权限控制</a></td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_7/">复用类</a></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_8/">多态</a></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_9/">接口</a></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_10/">内部类</a></td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_11/">持有对象</a></td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="http://xiaweizi.cn/article/thinking_in_java_12/">通过异常处理错误</a></td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo 博客小功能添加-评论、相册、字数统计...</title>
      <link href="/article/31905/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间 <a href="https://www.jianshu.com/p/502765617b74" target="_blank" rel="noopener">个人博客全新上线(阿里域名+GitPages+hexo+Yelee)</a> 搭建的博客 <a href="http://xiaweizi.cn">我的博客</a>,基础的功能已经实现了，想着既然有了自己的博客就要好好的维护(折腾)一下，于是便参考着别人的博客添加一些额外的小功能。</p><a id="more"></a><p>首先我的博客是基于<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">yelee</a>风格，作者也是在 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Hexo-Theme-Yilia</a>的基础上进行修改，增加了一些新的功能，个人也是喜欢这种简洁的风格，觉得还不错就使用了该主题，在此表示对作者无私贡献的感谢！展示一下该主题风格的特性:</p><table><thead><tr><th></th><th style="text-align:left">New</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">嵌入边栏的文章目录</td></tr><tr><td>2</td><td style="text-align:left">透明化背景，随机背景大图</td></tr><tr><td>3</td><td style="text-align:left">页内跳转按钮</td></tr><tr><td>4</td><td style="text-align:left">文章版权等信息显示</td></tr><tr><td>5</td><td style="text-align:left">文章导航切换按钮与文章迷你列表</td></tr><tr><td>6</td><td style="text-align:left">网站计数</td></tr><tr><td>7</td><td style="text-align:left">多语言支持</td></tr><tr><td>8</td><td style="text-align:left">本地站内实时搜索</td></tr><tr><td>9</td><td style="text-align:left">动态加载评论</td></tr></tbody></table><p>具体的使用可以参考一下<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">官方使用介绍</a>。</p><p>为了给博客添加一些有趣的功能，就四处查资料，借鉴别人的博客，陆陆续续添加了一些小的功能，在此介绍一下添加的过程，或许对于感兴趣的您有所帮助，后续会陆续添加…</p><p>目前添加了:</p><ul><li>评论</li><li>相册</li><li>文章字数统计和阅读时长</li><li>网易云音乐</li><li>鼠标点击效果</li><li><code>PDF</code> 预览</li><li>添加可爱的妹子</li><li>添加网站运行时间</li></ul><h2 id="来必力评论"><a href="#来必力评论" class="headerlink" title="来必力评论"></a>来必力评论</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">yelee</a> 原生就已经支持了 <code>Disqus</code>、多说和友言，具体的使用可以参考<a href="http://moxfive.coding.me/yelee/2.Basic-Usage/comment.html" target="_blank" rel="noopener">yelee-评论系统</a>,但是，鉴于多说已经关闭，友言支持又不太友好，于是一开始就集成了<code>Disqus</code>。不过后来发现手机上展示不出来，一研究原来还得翻墙，这显然不够友好，上网了查了查还有网易云跟帖和来必力两个评论系统，对比了一下，最终选择了<a href="https://livere.com" target="_blank" rel="noopener">来必力</a>。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-650a5085c30ea485.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来必力首页"></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-16bff39e7d148364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据分析"></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-4b3cecd8e6b109bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><p>无论是功能还是数据分析还是UI都很不错。</p><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>因为原先的主题没有集成来必力，所以需要自己去集成，作为一个 <code>Android</code> 程序员，对这方面一窍不通，所以只能按部就班，照着其他的评论系统处理。</p><h4 id="1-主题站点添加-uid"><a href="#1-主题站点添加-uid" class="headerlink" title="1. 主题站点添加 uid"></a>1. 主题站点添加 uid</h4><p>打开<code>theme/yelee/_config.yml</code>，添加配置信息。</p><pre><code>livere:   on: true   livere_uid: Your uid</code></pre><h4 id="2-创建评论-ejs-文件"><a href="#2-创建评论-ejs-文件" class="headerlink" title="2. 创建评论 ejs 文件"></a>2. 创建评论 ejs 文件</h4><p>在<code>themes/yelee/layout/_partial/comments</code>文件夹创建<code>livere.ejs</code>文件，拷贝上图的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class=&quot;livere&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">    &lt;!-- 来必力City版安装代码 --&gt;</span><br><span class="line">    &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;Your uid&quot;&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   (function(d, s) &#123;</span><br><span class="line">       var j, e = d.getElementsByTagName(s)[0];</span><br><span class="line"></span><br><span class="line">       if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">       j = d.createElement(s);</span><br><span class="line">       j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;;</span><br><span class="line">       j.async = true;</span><br><span class="line"></span><br><span class="line">       e.parentNode.insertBefore(j, e);</span><br><span class="line">       &#125;)(document, &apos;script&apos;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- City版安装代码已完成 --&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h4 id="3-配置文章内的评论部分内容"><a href="#3-配置文章内的评论部分内容" class="headerlink" title="3. 配置文章内的评论部分内容"></a>3. 配置文章内的评论部分内容</h4><p>打开<code>themes/yelee/layout/_partial/article.ejs</code>。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-77ff3ca9a7cf3e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="article"></p><p>添加红色框标记的代码，到这就可以进行评论了，效果如下:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-dcf7a8397fd1a0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="评论"></p><p>大家可以到我的<a href="http://xiaweizi.cn/message/">留言板</a>进行留言🤣。</p><h2 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>如果你跟我一样，对前端一窍不通，但是还是想添加相册功能，就去看看别人已经实现的案例，然后进行模仿~😆。<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>的作者已经实现了，效果很不错，不妨可以学习一下，我也是照着资料借鉴了一下。</p><h3 id="集成-1"><a href="#集成-1" class="headerlink" title="集成"></a>集成</h3><h4 id="1-创建可以点击链接"><a href="#1-创建可以点击链接" class="headerlink" title="1. 创建可以点击链接"></a>1. 创建可以点击链接</h4><p>如果想单独创建一个可以单击的链接，方法是相同的，首先进入您的博客目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure><p>立即在<code>source</code>下生成<code>photos/index.md</code>文件，然后在主题站点的配置文件<code>theme/yelee/_config.yml</code>中添加点击的文案和跳转到位置。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9433d49dd33043b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相册"></p><h4 id="2-拷贝他人的-photos-内容"><a href="#2-拷贝他人的-photos-内容" class="headerlink" title="2. 拷贝他人的 photos 内容"></a>2. 拷贝他人的 photos 内容</h4><p>可以参考别人做好的博客，找到他的博客备份<a href="https://github.com/litten/BlogBackup" target="_blank" rel="noopener">博客备份</a>,下载<code>source/photos</code>下的所有文件，拷贝到你对应的位置。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-6820c4cefbfd74aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拷贝配置"></p><p>一般只需要修改<code>ins.js</code>文件的<code>render()</code>函数。这个函数式用来渲染数据的，里面配置了展示图片的链接地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-5276a7b36a5116e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片链接地址"></p><p>这个时候界面已经出来，接下来就是放置您的图片。</p><h4 id="3-处理图片并引入图片"><a href="#3-处理图片并引入图片" class="headerlink" title="3. 处理图片并引入图片"></a>3. 处理图片并引入图片</h4><p>接下来就是最后一步，也是最重要的一步了，使用<code>python</code>写的脚本，生成一套大图和一套小图，然后上传到<code>Github</code>上，随即生成<code>json</code>文件，这个文件保存在<code>source/photos/data.json</code>。</p><p>脚本可以直接下载 <a href="https://github.com/maker997/backupBlog/" target="_blank" rel="noopener">下载地址</a>，整个文件目录：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-40f1d984fcf69d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件目录"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    cut_photo()        # 裁剪图片，裁剪成正方形，去中间部分</span><br><span class="line">    compress_photo()   # 压缩图片，并保存到mini_photos文件夹下</span><br><span class="line">    git_operation()    # 提交到github仓库</span><br><span class="line">    handle_photo()     # 将文件处理成json格式，存到博客仓库中</span><br></pre></td></tr></table></figure><p>主要的执行的就是上面的代码，前提需要您的电脑装 <code>python</code>。</p><p>最后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean (清理之前的 HTML 等)</span><br><span class="line">hexo g (生成 HTML 文件)</span><br><span class="line">hexo s (看看效果)</span><br></pre></td></tr></table></figure><p>查看一下效果。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-13e6ce4a9ca5af54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相册"></p><h3 id="字数统计和阅读时长"><a href="#字数统计和阅读时长" class="headerlink" title="字数统计和阅读时长"></a>字数统计和阅读时长</h3><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>Next 是已经集成了这个功能，所以还是得需要咱们自己完成，首先看一下官网的使用帮助<a href="https://www.npmjs.com/package/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>.</p><h3 id="集成-2"><a href="#集成-2" class="headerlink" title="集成"></a>集成</h3><h4 id="1-安装-hexo-wordcount"><a href="#1-安装-hexo-wordcount" class="headerlink" title="1. 安装 hexo-wordcount"></a>1. 安装 hexo-wordcount</h4><pre><code>npm i --save hexo-wordcount</code></pre><p>先安装插件。</p><h3 id="2-文件配置"><a href="#2-文件配置" class="headerlink" title="2. 文件配置"></a>2. 文件配置</h3><p>在<code>yelee/layout/_partial/post/word.ejs</code>下创建<code>word.ejs</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;margin-top:10px;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-time&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-keyboard-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">        &lt;span class=&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">    &lt;span class=&quot;post-time&quot;&gt;</span><br><span class="line">      &amp;nbsp; | &amp;nbsp;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-hourglass-half&quot;&gt;&lt;/i&gt;</span><br><span class="line">        &lt;span class=&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后在 <code>themes/yelee/layout/_partial/article.ejs</code>中添加</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-8f87eb04040f35ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="article 配置"></p><p><code>word_count</code> 是主题<code>_config.yml</code>中配置是否需要添加字数统计功能控制 flag，<code>no_word_count</code>即配置文章是否需要显示字数统计的功能。</p><p>大功告成~看一下效果：⤵️</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-a382b16fb0e50417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页展示"></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-cbdad1ce42edc83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内容展示"></p><h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>作为一名<code>Android</code>开发者，最少不了的两个软件，一个是<code>Android Studio</code>，还有一个就是<code>网易云音乐</code>，那博客也要添加这个功能。</p><h3 id="集成-3"><a href="#集成-3" class="headerlink" title="集成"></a>集成</h3><p>集成起来就很简单了，<code>MarkDown</code> 是支持 <code>h5</code> 代码的，所以打开<a href="https://music.163.com" target="_blank" rel="noopener">网易云</a>,输入你想要的歌曲，点击对应歌曲的 生成外链播放器。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3a5ba250204c5338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="外链"></p><p>前提是有版权哈，然后拷贝相应的代码即可。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-b820e3f312ff2724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拷贝代码"></p><p>效果请点击<a href="http://xiaweizi.cn/photos/">我的相册</a></p><h2 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h2><p>废话不多说，直接看如何集成。</p><h4 id="1-拷贝需要的文件"><a href="#1-拷贝需要的文件" class="headerlink" title="1. 拷贝需要的文件"></a>1. 拷贝需要的文件</h4><p>进入到<a href="https://github.com/xiaweizi/BackupBlog" target="_blank" rel="noopener">我的备份</a>，拷贝文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-15b1a79a486bf7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击效果文件"></p><p>拷贝<code>resources</code>下的所有文件到您对应的目录。</p><h4 id="2-添加配置"><a href="#2-添加配置" class="headerlink" title="2. 添加配置"></a>2. 添加配置</h4><p>打开<code>themes/yelee/layout/_partial/after-footer.ejs</code>文件，添加刚刚添加文件的配置。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-26b534dbe4438243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置"></p><p>看一下效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-e04028a13a498132.gif?imageMogr2/auto-orient/strip" alt="鼠标点击效果.gif"></p><h2 id="PDF-预览"><a href="#PDF-预览" class="headerlink" title="PDF 预览"></a>PDF 预览</h2><p>如果想要在自己的博客中添加书籍的预览，实现起来也很简单，前人已经做好了…</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-pdf</span><br></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p><strong>链接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http:<span class="comment">//7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125;</span></span><br></pre></td></tr></table></figure><p><strong>本地</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf ./bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure><h3 id="3-效果"><a href="#3-效果" class="headerlink" title="3. 效果"></a>3. 效果</h3><p>可进入我的博客 <a href="http://xiaweizi.cn/pdf/">书籍</a> 进行查看。 <a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">源码</a></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251202198.png" alt="效果"></p><h2 id="萌妹子添加"><a href="#萌妹子添加" class="headerlink" title="萌妹子添加"></a>萌妹子添加</h2><p>也是偶然之间发现可以添加可爱的妹纸或者是萌宠，发现挺好玩的，而且作者提供了很多模型供你选择，没事的时候还可以逗一逗 🤣</p><h3 id="1-获取"><a href="#1-获取" class="headerlink" title="1. 获取"></a>1. 获取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p>在站点的 <code>_config.yml</code> 下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  scriptFrom: local</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: <span class="number">150</span></span><br><span class="line">    height: <span class="number">300</span></span><br><span class="line">  mobile:</span><br><span class="line">    show: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>use</code> 用来配置模型，目前有很多模型可以选择。 <a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">模型</a></p><p>也有对应模型的预览效果。<a href="http://xiaweizi.cn">我的博客</a></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251224150.png" alt="模型预览1"></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251224536.png" alt="预览2"></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251225213.png" alt="预览3"></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-03-25-image-201803251226068.png" alt="预览4"></p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">源码地址</a></p><h2 id="网站运行时间添加"><a href="#网站运行时间添加" class="headerlink" title="网站运行时间添加"></a>网站运行时间添加</h2><p>实时展示你的博客已经运行了多长时间了，我还是蛮喜欢这个功能的，随着时间的增长，和你的博客访问量形成照样，成就感也会增添不少。</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>在 <code>hexo/themes/[your theme]/layout</code> 文件夹下找到你的 <code>footer</code> 文件，即脚布局文件，在对应的位置添加一下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=<span class="string">"timeDate"</span>&gt;载入天数...&lt;<span class="regexp">/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/</span>span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createtime</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"02/14/2018 12:49:00"</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间 </span></span><br><span class="line">        now.setTime(now.getTime()+<span class="number">250</span>); </span><br><span class="line">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="built_in">Math</span>.floor(days); </span><br><span class="line">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="built_in">Math</span>.floor(hours); </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">String</span>(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span><br><span class="line">        mnum = <span class="built_in">Math</span>.floor(minutes); <span class="keyword">if</span>(<span class="built_in">String</span>(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">"0"</span> + mnum;&#125; </span><br><span class="line">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum); </span><br><span class="line">        snum = <span class="built_in">Math</span>.round(seconds); <span class="keyword">if</span>(<span class="built_in">String</span>(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">"0"</span> + snum;&#125; </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"timeDate"</span>).innerHTML = <span class="string">"本站已安全运行 "</span>+dnum+<span class="string">" 天 "</span>; </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"times"</span>).innerHTML = hnum + <span class="string">" 小时 "</span> + mnum + <span class="string">" 分 "</span> + snum + <span class="string">" 秒"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">setInterval(<span class="string">"createtime()"</span>,<span class="number">250</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-04-12-time%20record.gif" alt="运行预览"></p><p>如果遇到什么问题，希望我可以帮助到你，<a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『技术分享』— 个人博客全新上线(阿里域名+GitPages+hexo+Yelee)</title>
      <link href="/article/39434/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新年新气象，狗年也是我本命年，因此决定将博客重新搞一波。其实之前已经搭好过博客，因为前段时间换了<code>mac</code>，之前的环境和博客的内容都没有备份，索性就重新开始吧。那展示一下我的新的博客地址:</p><p><a href="http://xiaweizi.cn">http://xiaweizi.cn</a></p><a id="more"></a><p>在来一波动态图演示：</p><p>电脑端：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-c2da9789c4e8a0c9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电脑端.gif"></p><p>手机端：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-f2f6b7f7a5ac6a38.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手机博客"></p><p>整个的搭建，一些的配置和博客的迁移也是花了我一整个下午和晚上加班的时间，自我感觉看起来很舒服，那接下来我就大概讲述一下这个博客搭建的过程。</p><h2 id="GitHub-Pages-Hexo"><a href="#GitHub-Pages-Hexo" class="headerlink" title="GitHub Pages + Hexo"></a>GitHub Pages + Hexo</h2><p>没钱买域名，没时间网站备案，那就用<code>GitHub Pages</code>和<code>Hexo</code>搭建属于自己的博客吧。其实网上这个教程真的是一搜一大把，我之前也写过，不过被我弄丢了，所以我就不赘述了，贴几个链接以供参考，只要照着流程走，是肯定可以顺利搭建的，这是件一劳永逸的事情。</p><p><a href="https://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">1. 如何搭建一个独立博客</a><br><a href="https://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">2. 搭建属于自己的博客</a></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>域名，之前的云服务器套餐就是在<a href="https://www.aliyun.com/?spm=5176.8006371.388261.1.66867e63FewLSC" target="_blank" rel="noopener">阿里云</a>上购买，因此我就顺便在<a href="https://wanwang.aliyun.com/?spm=5176.8142029.735711.56.a72376f4MMmf6X" target="_blank" rel="noopener">阿里云</a>进行购买域名。</p><p>前缀的选择就没有想那么多，也没有想的那么商业化，直接就是本人姓名的中文拼音。至于后缀，一开始对这块不熟悉，就先购买一个最便宜的尝试一下<code>.top</code>，成功后，索性花点钱买了个<code>.cn</code>——全球唯一由中国管理的英文国际顶级域名。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3ebf50b50d917461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名选择"></p><p>首先选择你喜欢和合适的域名，然后进行购买，购买成功并通过实名审核后，就可以在控制台找到您刚刚注册的域名。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-e82acbfa03abcba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析"></p><p>我购买了两个，因此<code>xiaweizi.cn</code>和<code>xiaweizi.top</code>就会展示在首页，如果想绑定到<code>GitHub Pages</code>上,点击所选域名对应的「解析」按钮。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-849b16522051456a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加解析"></p><p>这里我之前已经添加过两个解析，第一次的时候需要你自行添加相应的解析。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-6a6af64c6a80ca51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析1"></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-45ed7b185921b081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析2"></p><p>按照上图添加两条解析。方式有很多种，我选择<strong>A</strong>的记录类型，即将域名指向一个 IPV4 地址，那记录值对应的就是你的<code>GitHub Pages</code>对应的地址，那这个地址如何获取呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-756630c8d958e0c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取 ip 地址"></p><p>直接通过<code>ping + &quot;your name&quot;.github.io</code>的方式获取<code>IP</code>地址，也就是解析的记录值。</p><p>域名的配置已经完成了，剩下的就是<code>GitHub Pages</code>上的配置，有两种方式：</p><p>第一种，登录你的<code>GitHub</code>，找到名为<code>&quot;your name&quot;.github.io</code>的仓库，点击<code>settings</code>的选项，找到<code>GitHub Pages</code>区域，即可看到<code>Custom Domian</code>的配置，这里输入您购买的域名即可。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9ad476d51ad48a3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="github pages"></p><p>第二种，在<code>hexo</code>的对应的目录下创建<code>CNAME</code>文件，里面输入您购买的域名。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-25916cb3e8311844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加 cname 文件"></p><p>不到一天的时间，即可通过审核并解析成功，直接就可以访问您的域名并定向到您的博客位置。</p><p><a href="http://xiaweizi.cn">xiaweizi</a></p><p>到此，博客的大概框架和域名已经配置成功了，可以大致看到效果了。</p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><p>至于主题的选择完全是看个人的喜好了，有的人喜欢简洁大方，有的喜欢色彩张扬，有的喜欢品质内涵，找到自己合适的就行，如果实在没有满足您的胃口的，不妨可以根据自己的想法编写属于您自己的主题。</p><p>截止今日<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo 主题</a>已经有 189 个样式供选择，或者可以参考知乎上的一篇文章选择：<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的 hexo 主题</a>。</p><p>我 选择了<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">yelee</a>主题 —— 简而不减 Hexo 双栏博客主题，独具匠心的设计风格，突出内容为主题，凸显博主个性！</p><p>那接下来我就大概总结一下<code>yelee</code>主题的相关配置，当然官网是有详细的配置文档的：<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">中文使用文档</a>，举一反三，其他的主题配置大同小异。</p><p><strong>使用 yelee 主题</strong></p><p>打开终端，<code>cd</code>到您<code>hexo/blog</code>的目录,</p><pre><code>git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee</code></pre><p>下载<code>yelee</code>主题，那此时，分别在<code>hexo/blog</code>和<code>hexo/blog/theme/yelee</code>下有两个<code>_config.yml</code>的配置文件，前者是「站点配置文件」，后者是「主题配置文件」，大致所有的配置都在这里完成。</p><p>第一步就要在站点配置文件中，选择你刚下载的<code>yelee</code>主题。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-00bd80cf773d6bc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主题选择"></p><p>在<code>hexo/blog</code>目录下输入相应的<code>hexo</code>命令完成生成、测试和部署的工作。</p><pre><code>// 1. 生成hexo g// 2. 测试(localhost:4000)hexo s// 3. 部署hexo d</code></pre><p><strong>编写文章</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-4f3148e75bdf86bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文章编写"></p><p>头部即为每次编写文章的配置信息。</p><pre><code>title: 文章的标题date: 文章的创建时间updated: 文章的更新时间categories: 文章所属的分类(一般有且只有一个)tag: 文章所打的 tag(这个根据文章特点添加)</code></pre><p>需要注意的是，主页展示每个文章，并不是展示摘要而是直接全文，这样的体验很不好，这个时候需要添加一行摘要分割标识：<code>&lt;!-- more --&gt;</code></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-416e405032bfd6c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="摘要分割"></p><p><code>&lt;!-- more --&gt;</code>之前的正文部分就是展示在主页的摘要。</p><p><strong>第三方服务</strong></p><p>首先在主题配置文件中找到<code>github_widget:</code>并设置为<code>true</code>，开启后在正文中插入如下代码即可</p><pre><code>&lt;div class=&quot;github-widget&quot; data-repo=&quot;&lt;GitHub 用户名&gt;/&lt;仓库名&gt;.js&quot;&gt;&lt;/div&gt;&lt;!-- e.g. --&gt;&lt;div class=&quot;github-widget&quot; data-repo=&quot;xiaweizi/QNews&quot;&gt;&lt;/div&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/4043475-18522728a2540610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitHub 小挂件"></p><p>这个小挂件展示了对应仓库的链接地址、<code>star</code>和<code>fork</code>的数量等等信息。</p><p>至于其他的三方服务，只要按照官方的配置都可以完成，我就不赘述了，在配置的过程中遇到什么问题，咱们可以共同交流！</p><p>快过年了，今天也是情人节，祝撸友们新年快乐，新年脱单！</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9edf8267daf8b3a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新年快乐"></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 冷兵器 之 tools</title>
      <link href="/article/34201/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Android</code>开发在所难免的就是<code>UI</code>的预览和调整，一般情况下都是直接<code>run</code>看效果，或者是使用<code>AS</code>的<code>preview</code>预览，但这同样带来个小问题，就是你的测试内容会跟随着代码被打包到<code>apk</code>中，如果没做容错的处理很有可能将测试内容展示给用户。</p><p>还有就是像一些列表是不支持预览效果的，比如<code>ListView</code>。</p><a id="more"></a><p>其实<code>Android</code>老早就有<code>tools</code>命名空间，作为一个开发快到一年的我，最近看到一篇文章才发现这个<code>tools</code>大用处，在此做个笔记。</p><p>直接看一下效果，最为清楚：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-4b0507d661130b3d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RecyclerView.gif"></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-d4d0aa1a853870c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ListView 预览.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-55f190ae724d6e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GridView 预览.png"></p><p><code>XML</code>中的代码区区几行，但是右侧的<code>preview</code>效果却很直接，还有就是这些数据并不会打到<code>apk</code>中，直接运行是没有任何效果的，这就是厉害之处！相关代码已提交到<code>Github</code>上: </p><div class="github-widget" data-repo="xiaweizi/AndroidToolsExample"></div><h2 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h2><p>既然是命名空间，那肯定就要在<code>XML</code>开头就要声明。</p><pre><code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></pre><p>类似于</p><pre><code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</code></pre><p>然后就可以使用<code>tools</code>的相关属性了。属性功能很多很全，我就介绍一下常用的，文尾会贴上相关的文章链接。</p><p><strong>View 相关</strong></p><p>先从<code>view</code>相关说起，在<code>XML</code>中<code>view</code>的<code>android</code>任意属性值，可以直接替换成<code>tools</code>，这样就可以实现实时的预览效果，并且正式部署之后不会展示。有点类似于<code>dataBinding</code>中的 <code>default</code>属性,以<code>TextView</code>为例。</p><pre><code>//1. 原生android:text=&quot;test text&quot;//2. databindingandroid:text=&apos;@{viewModel.content, default=&quot;test text&quot;}&apos;//3. toolstools:text=&quot;test text&quot;</code></pre><p><code>preview</code>的效果是一样的，不过除了 1 以外，其他运行效果是根据代码中设置的内容决定的，真正做到了测试预览。</p><p>之前也说了，<code>view</code>的其他属性它都支持。</p><p><strong>context</strong></p><p>通过</p><pre><code>tools:context=&quot;com.xiaweizi.androidtoolsexample.CommonActivity&quot;</code></pre><p>的方式在根部局引用，主要的作用声明该布局文件默认关联的<code>Activity</code>，引号传<code>Activity</code>类的完整包名。随之就可以开启一些与其相关的特性。比如日常点击事件中，就可以直接在<code>XML</code>中声明<code>onClick</code>的方法名，然后会有错误的<code>lint</code>提示，需要你在<code>Activity</code>中创建改方法，跟随着<code>AS</code>的智能指引，便可创建对应的方法。点击事件的处理便可以放在里面。</p><p><strong>showIn</strong></p><pre><code>tools:showIn=&quot;@layout/activity_other&quot;</code></pre><p>在使用<code>include</code>或者<code>merge</code>时，内层布局是预览不到外层的布局的。那通过<code>showIn</code>链接到外层布局，就可以直接连同外层布局一同展示出来。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3e1ce6356b84a181.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="showIn"></p><p><strong>layout</strong></p><p>同样在<code>XML</code>中引用<code>fragment</code>布局也是预览不到效果的：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3851aafa5a627d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无"></p><p>那通过：</p><pre><code>&lt;fragment    android:id=&quot;@+id/fragment&quot;    android:name=&quot;com.xiaweizi.androidtoolsexample.CommonFragment&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:layout=&quot;@layout/layout_fragment_test&quot; /&gt;</code></pre><p>的方式即可达到预览的效果。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-8fcbb971d5849ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout.png"></p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p><code>tools</code>除去上面的功能，更强大的在于支持列表的预览展示，也就是文章开头预览的效果，效果最明显的就是<code>ListView</code>。</p><p><strong>ListView</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-d4d0aa1a853870c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ListView 预览.png"></p><pre><code>// 1. 列表内容的布局tools:listitem=&quot;@layout/list_content&quot;// 2. 头布局的预览展示tools:listheader=&quot;@layout/list_header&quot;// 3. 脚布局的预览展示tools:listfooter=&quot;@layout/list_footer&quot;</code></pre><blockquote><p>一开始使用的时候发现不生效，后来发现需要给<code>ListView</code>设置<code>id</code>，就会立刻生效了。</p></blockquote><p><strong>GridView</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-55f190ae724d6e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GridView 预览.png"></p><p>同样也适用于<code>GridView</code>。</p><p><strong>RecyclerView</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-4b0507d661130b3d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RecyclerView.gif"></p><p>说到<code>RecyclerView</code>一开始我以为只支持<code>itemCount</code>的设置，后来多谢以为小伙伴提的<a href="https://github.com/xiaweizi/AndroidToolsExample/issues/1" target="_blank" rel="noopener">AndroidToolsExample/issues/1</a>,我才发现可以支持复杂的列表展示！</p><pre><code>// 1. 设置展示 item 的数量tools:itemCount=&quot;6&quot;// 2. 设置布局方式 三种模式可以选择// GridLayoutManager// LinearLayoutManager// StaggeredGridLayoutManagertools:layoutManager=&quot;GridLayoutManager&quot;// 3. item 的布局tools:listitem=&quot;@layout/list_content&quot;// 4 设置布局的方向tools:orientation=&quot;horizontal&quot;// 5. 设置布局横、纵的列数tools:spanCount=&quot;2&quot;</code></pre><p><strong>sample</strong> </p><p>有人会好奇列表的数据哪来的，没看你设置，竟然能做到每条数据都不一样。客官别急，接下来就是介绍一下<code>@tools:sample/*</code>的强大功能，作为预览视图的占位数据。看一看官网的使用介绍。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-e000658ceeea7530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sample"></p><p>各种类型的数据都支持构造，这里我以例子作为展示：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-0088a7a62e7a0511.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="展示"></p><blockquote><p>每次使用，都会随机的更换不同的值，详情参见列表展示数据。</p></blockquote><p>你以为这样就结束了吗？<code>too young</code>！除去原生给的数据支持，咱们也可以自己构造假的数据。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-2a20ff2392642e85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sample data"></p><p>直接可以创建<code>sample data</code>，然后就可以创建文本或者<code>json</code>数据。如果是<code>json</code>数据，你必须先运行一下才能使用。那看一下如何使用。</p><p>先创建<code>json</code>数据：</p><pre><code>{  &quot;data&quot;: [    {      &quot;name&quot;: &quot;张三&quot;,      &quot;phone&quot;: &quot;@tools:sample/us_phones&quot;,      &quot;time&quot;: &quot;@tools:sample/date/hhmmss&quot;,      &quot;avatar&quot;: &quot;@tools:sample/avatars&quot;    },    {      &quot;name&quot;: &quot;李四&quot;,      &quot;phone&quot;: &quot;@tools:sample/us_phones&quot;,      &quot;time&quot;: &quot;@tools:sample/date/hhmmss&quot;,      &quot;avatar&quot;: &quot;@tools:sample/avatars&quot;    },    {      &quot;name&quot;: &quot;赵五&quot;,      &quot;phone&quot;: &quot;@tools:sample/us_phones&quot;,      &quot;time&quot;: &quot;@tools:sample/date/hhmmss&quot;,      &quot;avatar&quot;: &quot;@tools:sample/avatars&quot;    },    {      &quot;name&quot;: &quot;王二麻&quot;,      &quot;phone&quot;: &quot;@tools:sample/us_phones&quot;,      &quot;time&quot;: &quot;@tools:sample/date/hhmmss&quot;,      &quot;avatar&quot;: &quot;@tools:sample/avatars&quot;    }  ]}</code></pre><p>然后直接在<code>XML</code>中，通过<code>@sample/</code>的方式拿到数据。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-4eadb8c507756bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终预览"></p><p>使用和预览正如上图所示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>get</code>了该技能，不说有多大用处吧，至少可以提高开发效率，和减少把测试代码部署到线上的失误率吧，相信会帮助到你的！</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://developer.android.google.cn/studio/write/tool-attributes.html" target="_blank" rel="noopener">tools 官方文档</a></p><p><a href="http://blog.csdn.net/p106786860/article/details/53943540" target="_blank" rel="noopener">命名空间介绍</a></p><p><a href="https://www.jianshu.com/p/2912bcba4465" target="_blank" rel="noopener">tools 大有用处</a></p><p><a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 开发效率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『自定义View实战』—— 银行种类选择器</title>
      <link href="/article/25968/"/>
      <content type="html"><![CDATA[<blockquote><p>在工作中难免遇到自定义 <code>View</code> 的相关需求，本身这方面比较薄弱，因此做个记录，也是自己学习和成长的积累。<a href="https://link.jianshu.com/?t=http%3A%2F%2Fxiaweizi.cn%2Fcategories%2F%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589View%25E5%25AE%259E%25E6%2588%2598%2F" target="_blank" rel="noopener">自定义View实战</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>年前的最后一个开发需求，将之前<code>H5</code>开卡界面转变成<code>native</code>。意思就是开卡这个需求做成<code>Android</code>原生的界面，就这单单一个界面需要请求 <strong>8</strong> 个接口！可想逻辑是有多复杂，其中中间有个小需求-「选择银行卡」。来看一下<code>UI</code>出图。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/4043475-5f50c0e7819ed245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设计图"></p><p>大致就是点击「银行」弹出<code>popupWindow</code>，在里面嵌套一个银行选择器。这个「银行选择器」可以滚动类似<code>IOS</code>那边的<code>UIPickerView</code>，或者安卓的日期选择器，但是为了完成特殊的定制效果，所以咱们得自己写一个。</p><div class="github-widget" data-repo="xiaweizi/BankPickerView"></div><p>看一下效果图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-42f7f21a686f03da.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BankPickerView.gif"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>思路其实也很简单。</p><p><strong>滚动</strong></p><p><code>ScrollView</code>、<code>ListView</code>和<code>RecyclerView</code>都可以实现滚动，这自然不用说，首尾都有<code>offset</code>个位置是留占坑，可以添加空数据作为占坑的显示。</p><p><strong>回弹</strong></p><p>那就在手指松开的时候，拿到滑动的距离，通过一系列的逻辑处理，回弹到最近的<code>Item</code>处即可。</p><p><strong>回调</strong></p><p>在滑动停止的时候，通过计算获取当前所处的<code>item</code>的位置，通过<code>listener</code>回调给调用者。</p><p>因为时间有限，所以没对其进行封装，如果想使用请自行下载，通过修改源码满足特定的需求。</p><p>至于弹出的效果，用的是<code>popupWindow</code>,其中遇到了一下坑，在这里记录并分享一下。</p><p><strong>背景透明</strong></p><p><code>popupWindow</code>不像<code>dialog</code>本身是没有背景透明的效果的，需要自己实现。主要就是两种实现方式。</p><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:skin=&quot;http://schemas.android.com/android/skin&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:background=&quot;#7D000000&quot;    skin:enable=&quot;true&quot;&gt;        &lt;!-- 内容 --&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:background=&quot;#fff&quot;            android:layout_alignParentBottom=&quot;true&quot;            android:orientation=&quot;vertical&quot;&gt;        &lt;/LinerarLayout&gt; &lt;/RelativeLayout&gt;</code></pre><p>一种就是直接在<code>pooupWidnow</code>展示的布局强行假如半透明的背景。</p><p>第二种获取<code>WindowManager</code>修改当前窗口的透明值。</p><p><strong>点击返回关闭 popupWindow</strong></p><p>首先如果想实现点击返回让<code>popupWindow</code>消失，就得实现<code>View.OnKeyListener</code>接口，并且在回调中，让其消失。</p><pre><code>@Overridepublic boolean onKey(View v, int keyCode, KeyEvent event) {    if (keyCode == KeyEvent.KEYCODE_BACK) {        dismiss();        return true;    }    return false;}</code></pre><p>但是你会发现并没有生效，那是因为当前没有获取到焦点，需要设置<code>setFocusable(true)</code>即可。</p>]]></content>
      
      <categories>
          
          <category> 自定义View实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作积累 </tag>
            
            <tag> 自定义 View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我和极光的那些事---我和-Android-推送的时间简史</title>
      <link href="/article/46688/"/>
      <content type="html"><![CDATA[<h2 id="2017-年-3-月-3-日"><a href="#2017-年-3-月-3-日" class="headerlink" title="2017 年 3 月 3 日"></a>2017 年 3 月 3 日</h2><p>「极光」跟我的渊源真的是极深的，说到极光，不得不追溯到 <strong>2017 年 3 月 3 日</strong>，当时正做毕设项目<a href="https://github.com/xiaweizi/QNews" target="_blank" rel="noopener">趣闻</a>。基本的预期功能已经实现了，开始考虑集成推送功能，鉴于水平和时间的约束，决定还是集成第三方推送最为保险。</p><a id="more"></a><p>然后百度了一下「第三方推送」，映入眼帘的便是「极光推送」，毫不犹豫的选择了它。在集成过程中也是比较顺利，在收到第一条推送后，喜悦的心情无以言表，不得不说大平台就是强。</p><h2 id="2017-年-3-月-7-日"><a href="#2017-年-3-月-7-日" class="headerlink" title="2017 年 3 月 7 日"></a>2017 年 3 月 7 日</h2><p><strong>3 月 7 日</strong>，找到了第一份实习工作(毕业后也在这里转了正)，坐标「南京」。入职不久，老大开始让我接手公司项目中的推送模块。然后我把公司推送的逻辑大致看了一下，无论是设置 <code>tag</code>、或者是处理通知栏点击事件处理、还是自定义消息推送，对于刚入职的我是相当的复杂。毕竟在之前集成的毕设项目中，逻辑处理很少，只是简单的收到通知、点击并打开应用…</p><p>逻辑整理的差不多，开始了主要的任务–<strong>升级到新版的极光推送</strong>。</p><p>当我看到项目极光当前的版本，硬是被吓一跳。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-200649713cb1ebc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当前版本"></p><p>我记得当时极光已经到 <code>3.0.0+</code> 的版本了，看来升级果断是有必要的！还有一点，我们公司是「极光」的 <strong>VIP</strong>,在原来推送的基础上，多了一项非常强大的功能！<strong>集成产商的推送</strong>(小米、华为和魅族)。</p><p>这意味着，如果在「小米、华为和魅族」的大部分的设备上，推送不再走极光的通道，而是走设备的产商通道。</p><p>什么意思呢？就拿公司老版本的项目来说，不仅集成了极光推送还集成了小米推送，不仅服务端需要推送两份推送，就连客户端自己都要对设备的类型进行判断，如果是「小米」设备就调用「小米」的接口。那如果集成了<strong>产商</strong>推送，就不需要此操作，你只需提供应用的 <code>APPID</code> 等其他配置信息即可，华为和魅族同样！</p><p>那么走产商通道又意味着什么呢？有集成过推送的小伙伴应该知道，推送能准确到达在于一个长连接，假如应用的进程被杀死，推送也便收不到。假如集成了产商的推送，即便进程被杀死，推送还是可以正常收到的，不过仅限于基本的推送，不包括自定义推送。</p><p>这个升级的过程也是相当的坎坷，我记得这部分的功能也是「极光」的测试功能，正好我们集成过来一并测试…不过还有有一位热心的小姐姐，习惯称之为「大侠」！这个称号是当时她的昵称，一直都这么叫过来的。每次遇到问题都能不厌其烦的为我解惑。</p><p>其中让我印象最为深刻的，是那天公司项目已经到了发版周期的最后两天，在华为的设备上推送没有收到。这可把我急的，第一时间就是找「大侠」帮忙，可能因为我在 QQ 上表达的不是很清楚，小姐姐看起来比我 还着急，直接让我跟她通电话讨论一下具体的原因，这让我意想不到。还好最后是解决了问题，在此说声 <strong>谢谢</strong>。</p><h2 id="2017年-9月19日"><a href="#2017年-9月19日" class="headerlink" title="2017年 9月19日"></a>2017年 9月19日</h2><p><strong>9月 19 日</strong>，工作半年了，打算和大神同事一起维护一个开源项目，于是就有了 <a href="https://github.com/G-Joker/WeaponApp" target="_blank" rel="noopener">WeaponApp</a> 的诞生，目前也快到 600 的赞了。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-7dcc5c02c4e8e1a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WeaponApp"></p><p>当然，推送的功能也是少不了的，由于有了前面的经验，集成起来也是相当顺手，不过因为是个人项目就没有考虑，后来同事自学了服务端，顺便也把服务端的极光推送集成了，感兴趣的话可以把项目 <code>clone</code> 下来。</p><p>在这个项目中初次尝试了集成「极光IM」，官方的接口也是很详细，并且还有自己的用户系统，登录和注册不需要自己实现了，不过目前的用户还是很少…</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-862cf02edd55d700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="所有用户"></p><h2 id="2017年-10-月-26-日"><a href="#2017年-10-月-26-日" class="headerlink" title="2017年 10 月 26 日"></a>2017年 10 月 26 日</h2><p><strong>10 月 26 日</strong>，咱们公司另一交易项目「原油」开始进行大版本的升级，基本上属于重头做起。不用多说，推送的部分还是由我负责，鉴于又是「极光」的 <strong>VIP</strong>，直接将「贵金属」项目的推送部分挪过来，去除不需要的部分，修改一些基础的配置，最后也是顺利的完成了。</p><p>不知不觉中，推送功能已经在 4 个项目中集成了：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-b22ecfadcf437d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个人项目"></p><p>公司的就不方便列出来了，加在一块也有数十万的用户了(绝大部分是公司)…整体的过程还是很顺利的，无论是集成的步骤，还是后续的服务都很完美，这可能就是「极光」做的那么大的原因吧。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-946b179a5d307cdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="推送一览"></p><h2 id="赘述"><a href="#赘述" class="headerlink" title="赘述"></a>赘述</h2><p>说完「极光」与我的渊源，接下来就大概说一下集成的过程。</p><p>官网已经有详细的集成介绍，我就不赘述了。<a href="https://docs.jiguang.cn/jpush/client/Android/android_guide/" target="_blank" rel="noopener">官网集成</a>，只是总结一下集成的步骤，一共三步：</p><ol><li>添加依赖<br>  <strong>手动集成</strong>，需要拷贝相应的 <code>so</code> 文件到制定的目录<br>  <strong>自动导入</strong>，<code>Android Studio</code> 直接添加依赖</li><li>添加配置文件<br>   拷贝<a href="https://docs.jiguang.cn/jpush/client/Android/android_guide/" target="_blank" rel="noopener">官网</a>的 <code>AndroidManifest</code> 数据到项目 <code>app module</code> 下的  <code>AndroidManifest</code> 中，并更换对应的包名和 <code>APPID</code>。<br>   调用「极光」接口进行初始化</li><li>添加接收器<pre><code>创建自定义 `Receiver` 用于处理推送的消息。</code></pre></li></ol><p>一般这样集成就可以正常收到推送了。如果遇到问题也别慌，冷静下来。从我的经验来看，最好在每个关键的地方打上日志，方便运行时候查看和后面遇到问题方便定位。还有就是日志的 <code>TAG</code>，最好和极光的日志过滤规则保持一致，比如 <code>JPush</code>。</p><p>当你有下面的日志输出，就证明已经集成成功了！</p><pre><code>[JPushInterface] action:init.......[PushService] Login succeed!</code></pre><p>成功的日志只有这一个，错误的情况就各种各样了，可以对照之前的日志进行分析，比如：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-10028d961ff14c9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化失败"></p><p>很有可能是因为 so 文件加载失败…</p><p>还有好多东西，我后续在添加吧，感兴趣的小伙伴可以很我交流交流，希望能帮到你！</p><p>「本文系<a href="https://www.jianshu.com/p/c1953d7fccaf" target="_blank" rel="noopener">极光征文 | 写写文章就能赢 Filco，岂不美滋滋</a>的参赛文章」</p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-自学笔记</title>
      <link href="/article/18215/"/>
      <content type="html"><![CDATA[<h2 id="赘述"><a href="#赘述" class="headerlink" title="赘述"></a>赘述</h2><p><code>mac</code>自带<code>python2.7</code>版本，但是最新版本和旧版本不兼容，所以还是决定重新下载新版本，并且新版本是可以和旧版本兼容的。</p><p>在安装的时候还是会遇到一些小坑，特此记录一些命令行的使用，方便后期查找。</p><a id="more"></a><pre><code>sudo vim ~/.bash_profile //修改本地的环境变量echo $PATH // 查看本地的环境变量source ~/.bash_profile // 让刚刚设置的环境变量生效</code></pre><p>使用中文添加的配置</p><pre><code># -*- coding: utf-8 -*-</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>整数</strong></p><p>Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p><p><strong>浮点数</strong></p><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><p><strong>字符串</strong></p><p>字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。</p><p>如果需要用掉<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>这个时候外层嵌套就需要对应相反的符号</p><p>如果同时包含的话，就需要转义字符：</p><pre><code>&apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos;\n 表示换行\t 表示一个制表符\\ 表示 \ 字符本身</code></pre><p>如果里面又用到了反斜杠那么就需要<code>raw</code>字符</p><pre><code>r&apos;\(~_~)/ \(~_~)/&apos;</code></pre><p>如果需要表示多行的话</p><pre><code>&apos;&apos;&apos;Line 1Line 2Line 3&apos;&apos;&apos;</code></pre><p><strong>布尔值</strong></p><p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。</p><p>布尔值可以用and、or和not运算。</p><p>and运算是与运算，只有所有都为 True，and运算结果才是 True。</p><p>or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p><p>not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p><p><strong>空值</strong></p><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><code>Python</code>内置的一种数据类型是列表，<code>list</code>是一种<strong>有序</strong>的集合，可以随时添加和删除其中的元素.<code>list</code>是数学意义上的有序集合，也就是说，<code>list</code>中的元素是按照顺序排列的。</p><p>命名方式</p><p>L = [‘Michael’, 100, True]<br>empty_list = []</p><p><strong>查询</strong> <code>L[1]</code>、<code>L[-1]</code></p><p><strong>添加</strong> <code>L.append(&#39;da&#39;)</code>、<code>L.insert(0, &#39;22&#39;)</code></p><p><strong>删除</strong> <code>L.pop()</code>、<code>L.pop(1)</code></p><p><strong>修改</strong> <code>L[0] = &#39;da&#39;</code></p><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p><code>tuple</code>是另一种<strong>有序</strong>的列表，中文翻译为<code>元组</code>。<code>tuple</code>和<code>list</code>非常类似，但是<code>tuple</code>一旦创建完成，就不能再修改。</p><p>命名方式</p><p>t = (‘Adam’, ‘Lisa’, ‘Bart’)</p><p>用法同上，不过只能查询</p><p>因为创建单数据会有歧义，所以需要加个<code>，</code></p><pre><code>t = (1,)t = (&apos;Adam&apos;,)</code></pre><h2 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h2><p><strong>if elif else</strong></p><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件的判断。</p><blockquote><p>注： Python 代码的缩进规则。具有相同缩进的代码被视为代码块。<br>if 语句后接表达式，然后用 : 表示代码开始</p></blockquote><pre><code>score = 85if score&gt;=90:    print &apos;excellent&apos;elif score&gt;=80:    print &apos;good&apos;elif score&gt;=60:    print &apos;passed&apos;else:    print &apos;failed&apos;</code></pre><p><strong>for</strong></p><pre><code>L = [75, 92, 59, 68]sum = 0.0for value in L:    sum += valueprint sum / 4</code></pre><p><strong>while</strong></p><p>计算 1 + 2 + 4 + 8 + 16 + … 的前20项的和。</p><pre><code>sum = 0x = 1n = 1while True:    sum += x    x *= 2    n += 1    if n &gt;20:        breakprint sum</code></pre><p>0-100 只计算奇数的值</p><pre><code>sum = 0x = 0while True:    x = x + 1    if x &gt; 100:        break    if x % 2 == 0:        continue    sum += xprint sum</code></pre><p><strong>多重循环</strong></p><p>1-100 十位数比各位数小的数</p><pre><code>for x in [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]:    for y in [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]:        if x &lt; y:            print x * 10 + y</code></pre><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>从字名可以理解为「字典」，类似于<code>java</code>中的<code>map</code>，是以键值对的方式存储。</p><p>dict的第一个特点是<strong>查找速度快</strong>，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。</p><p>不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。</p><p>由于dict是按 key 查找，所以，在一个dict中，<strong>key不能重复</strong>。</p><p>dict的第二个特点就是存储的key-value序对是<strong>没有顺序</strong>的！这和list不一样：</p><p>dict的第三个特点是作为 key 的元素必须<strong>不可变</strong>，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。</p><p>命名方式</p><pre><code>d = {    &apos;Adam&apos;: 95,    &apos;Lisa&apos;: 85,    &apos;Bart&apos;: 59}</code></pre><p><strong>查询</strong> <code>d[&#39;Adam&#39;]</code>、<code>d.get(&#39;Adam&#39;)</code>,在取值的时候最好需要判断一下: ‘Adam’ in d.</p><p><strong>修改</strong> <code>d[&#39;Adam&#39;] = 32</code></p><p><strong>增加</strong> <code>d[&#39;Weizi&#39;] = 32</code></p><p><strong>删除</strong> <code>d.pop(&#39;Adam&#39;)</code>、<code>del(d[&#39;Adam&#39;])</code></p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。</p><p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。</p><p>set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。</p><p>set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。</p><p>set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。</p><p>命名方式：</p><pre><code>s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])</code></pre><p><strong>查询</strong> 由于set存储的是无序集合，所以我们没法通过索引来访问。访问 set中的某个元素实际上就是判断一个元素是否在set中。<code>&#39;Bart&#39; in s</code>。</p><p><strong>增加</strong> <code>s.add(1)</code></p><p><strong>删除</strong> <code>s.remove(1)</code></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数用于解决重复的代码块，统一封装成一个功能，以便需要直接调用。</p><p><strong>调用 abs 函数</strong>：</p><pre><code>&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34</code></pre><p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你</p><p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型</p><p>而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x==y，返回 0，如果 x&gt;y，返回 1：</p><pre><code>&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0</code></pre><p><strong>编写函数</strong></p><p>在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。</p><p>我们以自定义一个求绝对值的 my_abs 函数为例：</p><pre><code>def my_abs(x):    if x &gt;= 0:        return x    else:        return -x</code></pre><p><strong>具有多返回值的函数</strong></p><p>函数也是可以拥有多个返回值的，比如我们经常遇到需要从一个点移动到另一点，给出坐标、位移和角度，就可以计算出新的坐标。</p><pre><code>import mathdef move(x, y, step, angle):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, ny&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0</code></pre><p>其实返回的值是一个<code>tuple</code></p><p>但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><p><strong>递归函数</strong></p><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><pre><code>def fact(n):    if n==1:        return 1    return n * fact(n - 1)</code></pre><p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。</p><p><strong>默认参数</strong></p><p>定义函数的时候，还可以有默认参数。</p><p><strong>函数的默认参数的作用是简化调用</strong>，你只需要把必须的参数传进去，但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。</p><p>我们来定义一个计算 x 的 N 次方的函数</p><pre><code>def power(x, n):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s</code></pre><p><strong>可变参数</strong></p><p>如果想一个函数能接收任意个参数，我们可以定义一个可变参数：</p><pre><code>def fn(*args):    print args</code></pre><p>计算传入数的平均值：</p><pre><code>def average(*args):    sum = 0    if len(args) == 0:        return 0.0    for value in args:        sum += value    return sum * 1.0 / len(args)print average()print average(1, 2)print average(1, 2, 2, 3, 4)</code></pre><p>可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p><h2 id="对-list-进行切片"><a href="#对-list-进行切片" class="headerlink" title="对 list 进行切片"></a>对 list 进行切片</h2><p>取一个list的部分元素是非常常见的操作。比如，一个list如下：</p><pre><code>&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]L = [1,2,3,4,5,6,7,8,9,10]print(L[0:4])print(L[1:3])print(L[:3])print(L[3:])print(L[::])print(L[0:4:2])print(L[2::3])print(L[2::3])[1, 2, 3, 4][2, 3][1, 2, 3][4, 5, 6, 7, 8, 9, 10][1, 2, 3, 4, 5, 6, 7, 8, 9, 10][1, 3][3, 6, 9]</code></pre><p>请利用切片，取出：</p><ol><li>前10个数；</li><li>3的倍数；</li><li><p>不大于50的5的倍数。</p><pre><code>L = range(1, 101)print L[0:10]print L[2::3]print L[4:50:5]</code></pre></li></ol><h2 id="倒序切片"><a href="#倒序切片" class="headerlink" title="倒序切片"></a>倒序切片</h2><p>利用倒序切片对 1 - 100 的数列取出：</p><ul><li><p>最后10个数；</p></li><li><p>最后10个5的倍数。</p><pre><code>L = range(1, 101)print L[-10:]print L[-46::5]</code></pre></li></ul><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><p>字符串有个方法 upper() 可以把字符变成大写字母：</p><pre><code>&gt;&gt;&gt; &apos;abc&apos;.upper()&apos;ABC&apos;</code></pre><p>但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。</p><pre><code>def firstCharUpper(s):    return s[:1].upper()+s[1:]print firstCharUpper(&apos;hello&apos;)print firstCharUpper(&apos;sunday&apos;)print firstCharUpper(&apos;september&apos;)</code></pre><h2 id="什么是迭代"><a href="#什么是迭代" class="headerlink" title="什么是迭代"></a>什么是迭代</h2><p>在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。</p><p>在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：</p><pre><code>for (i=0; i&lt;list.length; i++) {    n = list[i];}</code></pre><p>可以看出，Python的for循环抽象程度要高于Java的for循环。</p><p>因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。</p><p>因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。</p><pre><code>注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：1. 有序集合：list，tuple，str和unicode；2. 无序集合：set3. 无序集合并且具有 key-value 对：dict</code></pre><p>而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。</p><p>迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。</p><h2 id="索引迭代"><a href="#索引迭代" class="headerlink" title="索引迭代"></a>索引迭代</h2><p>Python中，迭代永远是取出元素本身，而非元素的索引。</p><p>对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？</p><p>方法是使用 enumerate() 函数：</p><pre><code>&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):...     print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul</code></pre><h2 id="迭代-dict-的-value"><a href="#迭代-dict-的-value" class="headerlink" title="迭代 dict 的 value"></a>迭代 dict 的 value</h2><p>我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。</p><p>如果我们希望迭代 dict 对象的value，应该怎么做？</p><p>dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：</p><pre><code>d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 }print d.values()# [85, 95, 59]for v in d.values():    print v# 85# 95# 59</code></pre><p>如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：</p><pre><code>d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 }print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues():    print v# 85# 95# 59</code></pre><p>那这两个方法有何不同之处呢？</p><ol><li><p>values() 方法实际上把一个 dict 转换成了包含 value 的list。</p></li><li><p>但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。</p></li><li><p>打印 itervalues() 发现它返回一个 <dictionary-valueiterator> 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。</dictionary-valueiterator></p></li></ol><p>如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。</p><h2 id="迭代-dict-的-key"><a href="#迭代-dict-的-key" class="headerlink" title="迭代 dict 的 key"></a>迭代 dict 的 key</h2><p>我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。</p><p>首先，我们看看 dict 对象的 items() 方法返回的值：</p><pre><code>&gt;&gt;&gt; d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 }&gt;&gt;&gt; print d.items()[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)]</code></pre><h2 id="生成列表"><a href="#生成列表" class="headerlink" title="生成列表"></a>生成列表</h2><pre><code>&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):...    L.append(x * x)... &gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre><p>这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。</p><p>写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p><h2 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h2><p>使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。</p><p>假设有如下的dict：</p><pre><code>d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 }print([(x,y+1 )for x,y in d.items()])</code></pre><h2 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h2><p>列表生成式的 for 循环后面还可以加上 if 判断。例如：</p><pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre><p>如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：</p><pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]</code></pre><p>有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。    </p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><strong>map</strong></p><p><code>map</code>其实就是将一个<code>iterable</code>里的数据一次取出来，然后进行相应的函数操作，并顺序返回成<code>iterable</code>。</p><pre><code>&gt;&gt;&gt; def f(x):...     return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><p><strong>reduce</strong></p><p><code>reduce</code>针对于<code>iterable</code>，依次取出两个数进行函数处理，返回的值再与下一个数进行函数处理，最后返回最终的结果。</p><pre><code>&gt;&gt;&gt; def add(x, y):...     return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25</code></pre><p><strong>filter</strong></p><p>顾名思义，就是对集合进行刷选，针对传入函数的返回值进行判断，如果为<code>True</code>则保留，否则直接删除。</p><pre><code>def is_odd(n):    return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</code></pre><p><strong>sorted</strong></p><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p><p>Python内置的sorted()函数就可以对list进行排序：</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]</code></pre><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p><strong>返回函数</strong></p><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：</p><pre><code>def calc_sum(*args):    ax = 0    for n in args:        ax = ax + n    return ax</code></pre><p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</p><pre><code>def lazy_sum(*args):    def sum():        ax = 0        for n in args:            ax = ax + n        return ax    return sum</code></pre><p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p><pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</code></pre><p>调用函数f时，才真正计算求和的结果：</p><pre><code>&gt;&gt;&gt; f()25</code></pre><p><strong>闭包</strong></p><p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：</p><pre><code>def count():    fs = []    for i in range(1, 4):        def f():             return i*i        fs.append(f)    return fsf1, f2, f3 = count()</code></pre><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p><p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p><pre><code>&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9</code></pre><blockquote><p>注： 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p></blockquote><p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><pre><code>def count():    def f(j):        def g():            return j*j        return g    fs = []    for i in range(1, 4):        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()    return fs</code></pre><p>再看看结果：</p><pre><code>&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()4&gt;&gt;&gt; f3()9</code></pre><p><strong>匿名函数</strong></p><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p><p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p><pre><code>&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><p><strong>装饰器函数</strong></p><pre><code>def log(func):    def wrapper(*args, **kw):        print(&apos;call %s():&apos; % func.__name__)        return func(*args, **kw)    return wrapper</code></pre><p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：</p><pre><code>@logdef now():    print(&apos;2015-3-25&apos;)</code></pre><p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</p><pre><code>&gt;&gt;&gt; now()call now():2015-3-25</code></pre><p>把@log放到now()函数的定义处，相当于执行了语句：</p><pre><code>now = log(now)</code></pre><p>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</p><p>wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p><p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p><pre><code>def log(text):    def decorator(func):        def wrapper(*args, **kw):            print(&apos;%s %s():&apos; % (text, func.__name__))            return func(*args, **kw)        return wrapper    return decorator</code></pre><p>这个3层嵌套的decorator用法如下：</p><pre><code>@log(&apos;execute&apos;)def now():    print(&apos;2015-3-25&apos;)</code></pre><p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p><pre><code>&gt;&gt;&gt; now = log(&apos;execute&apos;)(now)</code></pre><p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的<strong>name</strong>等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p>不需要编写wrapper.<strong>name</strong> = func.<strong>name</strong>这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：</p><p>import functools</p><pre><code>def log(func):    @functools.wraps(func)    def wrapper(*args, **kw):        print(&apos;call %s():&apos; % func.__name__)        return func(*args, **kw)    return wrapper</code></pre><p>或者针对带参数的decorator：</p><pre><code>import functoolsdef log(text):    def decorator(func):        @functools.wraps(func)        def wrapper(*args, **kw):            print(&apos;%s %s():&apos; % (text, func.__name__))            return func(*args, **kw)        return wrapper    return decorator</code></pre><p><strong>偏函数</strong></p><p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p><p>在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：</p><p>int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p><pre><code>def int2(x, base=2):    return int(x, base)</code></pre><p>这样，我们转换二进制就非常方便了：</p><pre><code>&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85</code></pre>]]></content>
      
      <categories>
          
          <category> 自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google-最新模拟器重磅来袭！秒开并还原到之前工作状态！</title>
      <link href="/article/6515/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>12月18日，Google 官方<a href="https://android-developers.googleblog.com/2017/12/quick-boot-top-features-in-android.html" target="_blank" rel="noopener">Quick Boot</a>博客的发布，给我们带来了最新的<code>Android</code>模拟器，其中最突出的特点技术 <strong>快速启动</strong>。声称可以在 <strong>6</strong> 秒之内便可启动模拟器，在此之下，模拟器通过保存关闭之前的快照，实现数秒内便可恢复到之前的工作状态。</p><a id="more"></a><p>废话不多说，来看一下效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-e0b50be455409f79.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Quick Boot.gif"></p><p>正好之前写了个小需求 <a href="https://www.jianshu.com/p/fdf460359857" target="_blank" rel="noopener">自定义跑马灯</a>，效果就很明显。</p><p>在关闭模拟器时，绿色的跑马灯停止在「跑」字位置，经过短暂的保存状态过程，再次启动模拟器，你会发现不到 <strong>1s</strong> 中模拟器变运行起来，并且跑马灯接着「跑」字继续滚动。</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><p>除了 <strong>Quick Boot</strong> 强大的功能之外，<a href="https://android-developers.googleblog.com/2017/12/quick-boot-top-features-in-android.html" target="_blank" rel="noopener">Quick Boot</a> 这篇博客还强调一些最近发布的功能。其实 <code>Google</code> 从两年前 <a href="https://android-developers.googleblog.com/2015/12/android-studio-20-preview-android.html" target="_blank" rel="noopener">Android Studio 2.0 Preview: Android Emulator</a> 模拟器发布以来，都一直致力于提过速度和稳定性，并增加一系列丰富的功能用来加速开发者的应用开发和测试。跟随者此次的更新，绝对值得将 <code>Android</code> 模拟器升级到最新的版本！</p><h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><p>此次，作为一项稳定版本的发布，<strong>快速启动</strong> 是你的模拟器在 <strong>6s</strong> 之内便可恢复之前的状态。首次启动 <code>Android</code> 模拟器时，还是得必须像之前启动设备那样的冷启动，但是后续的速度便会加快，系统会恢复到关闭之前的状态，类似于唤醒设备。<code>Google</code> 通过彻底对模拟器系统的重构完成此次功能，并处理了虚拟传感器和 <code>GPU</code> 加速。从 <code>Android</code> 模拟器 <code>v 27.0.2</code> 开始，默认情况下启用 <strong>Quick Boot</strong>，因此是不需要额外的配置的。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>从 <code>v4.4</code> 到最新的每个 <code>SDK</code> 版本，<code>Google</code> 都会确保模拟器能够满足开发人员的日常需求。不过为了提高模拟器系统镜像的品种和稳定性，现针对 <code>Android Nougat</code> (API24) 及其以上做了限制要求。</p><h3 id="Google-Play-支持"><a href="#Google-Play-支持" class="headerlink" title="Google Play 支持"></a>Google Play 支持</h3><p>在国内对 <code>Google Play</code> 的需求不是很多，但是在国外，很多开发者还是会用到 <code>Google Play</code> 服务，在之前的模拟器中，要想保持最新的服务还是很困难的。为了解决这个问题，从 <code>API24</code> 开始，<code>Google</code> 提过了包含其服务的系统镜像版本，可以正常的使用<code>Google</code> 服务，就像是在真机上一样。</p><h3 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h3><p>使用模拟器 <strong>快速、高效</strong> 的开发一直是<code>Google</code>团队持续目标，在过去的时间里，不断研究模拟器开发的性能影响，特别是内存使用情况。使用最新版本的 <code>Android</code> 模拟器，可以根据需要分配内存，而不是根据在<code>AVD</code>中设置的固定值来分配。</p><p>此外，在过去的几个版本中，还改进了<code>CPU</code>和<code>I/O</code>的性能，增强了<code>GPU</code>的性能，包括<code>OpenGL ES 3.0</code> 的支持。从一种图片可以看出改进的效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-ceba0742ebe1f24d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="adb Push 比较.png"></p><p>对于<code>GPU</code>性能方面，<code>Google</code>创建了<a href="https://github.com/google/gpu-emulation-stress-test" target="_blank" rel="noopener">GPU仿真模拟压力测试</a>程序来根据时间进行衡量。我们发现最新的模拟器相比较之前提高了不少的帧率，同时它也是模拟器中极少部分能根据<code>Android</code>规范准确的呈现<code>OpenGL ES 3.0</code>.</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-a9dcb3f9f903702f.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GPU.gif"></p><p><strong>GPU 仿真压力测试：</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3ea1a759f4da9615.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stressTest.png"></p><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><p>还有一些去年添加的功能，防止不知道先列出来：</p><ul><li><strong>WI-FI 支持</strong>  从 <code>API24</code>开始，可以创建虚拟的蜂窝网络或者是<code>WI-FI</code>。</li><li><strong>Google Cast 支持</strong>  当你使用<code>Google Play</code>系统镜像时，在同一个<code>WI-FI</code>下可以将屏幕投射到<code>Chromcast</code> 设备上。</li><li><strong>拖拽 APK和文件</strong>  通过拖动<code>APK</code>文件到模拟器上，便可实现快速安装；也可以直接拖拽文件到模拟器上，并在模拟器的<code>DownLoad</code> 文件夹中找到它。</li><li><strong>本地复制和粘贴</strong>  可以在本地和模拟器直接复制粘贴文本</li><li><strong>两个手指的动作</strong>  在使用谷歌地图时，按住<code>ctrl</code>(Windows、Linux)或者<code>⌘</code>(Mac)，并用鼠标即可实现缩放或放大效果。</li><li><strong>模拟GPS位置</strong></li><li><strong>虚拟传感器</strong> 在扩展控制面板中有一个专门的界面，支持<code>Android</code>模拟器中的传感器，包括加速，旋转等</li><li><strong>WebCam 的支持</strong> 可以使用网络摄像头或者笔记本电脑内置摄像头作为<code>AVD</code>中的虚拟相机，在管理器的 <strong>高级设置</strong> 页面中确认相机设置。</li><li><strong>本地键盘</strong> 可以使用本地外设键盘进行内容输入</li><li><strong>虚拟短信和电话呼叫</strong></li><li><strong>屏幕缩放</strong></li><li><strong>窗口大小缩放</strong></li><li><strong>网络代理支持</strong>  到 <em>代理</em> 选项下的设置界面，为模拟器添加自定义<code>HTTP</code>代理。</li><li><strong>错误报告</strong>  可以使用扩展面板中的错误报告快速生成应用程序的错误报告，和团队分享或者向<code>Google</code>反馈。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4043475-8be5e21e8528ac6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setting.png"></p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><img src="http://upload-images.jianshu.io/upload_images/4043475-7e52c52cfbdf736e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EmulatorGet.png"></p><p>所有的功能和改进都可以通过将图中<code>Android Emulator</code>更新到 v27.0.2+ 获取。 </p><h2 id="小bug"><a href="#小bug" class="headerlink" title="小bug"></a>小bug</h2><p>不知道你们有没有遇到，我在使用的过程中，模拟器黑屏的时候，会出现怎么都打不开的现象，无论重启还是按模拟器的电源键都没有效果。然后按照网上的方法，尝试着改了一下<code>RAM</code>，任意改成与之前不同的值就可以了。应该是因为修改了系统属性导致重新加载才能恢复正常吧。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-390f451c2275ec5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="peizhi.png"></p><hr><blockquote><p>以上所有的内容和部分图片全部来自官方博客：<a href="https://android-developers.googleblog.com/2017/12/quick-boot-top-features-in-android.html" target="_blank" rel="noopener">Quick Boot</a></p></blockquote><p><strong>感谢！！</strong></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google 官方 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『自定义View实战』—— 跑马灯</title>
      <link href="/article/13147/"/>
      <content type="html"><![CDATA[<blockquote><p>在工作中难免遇到自定义 <code>View</code> 的相关需求，本身这方面比较薄弱，因此做个记录，也是自己学习和成长的积累。<a href="https://link.jianshu.com/?t=http%3A%2F%2Fxiaweizi.cn%2Fcategories%2F%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589View%25E5%25AE%259E%25E6%2588%2598%2F" target="_blank" rel="noopener">自定义View实战</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近公司接到小需求–「可以滚动的提示」，其实就是跑马灯。这让我想到了大学时专业<strong>物联网</strong>，当时学的单片机入门教程就是跑马灯，很是亲切。其实就是灯(或文字)按照某个方向循环滚动。</p><a id="more"></a><h2 id="Android-原生的跑马灯"><a href="#Android-原生的跑马灯" class="headerlink" title="Android 原生的跑马灯"></a>Android 原生的跑马灯</h2><p>其实，<code>Android</code>中的<code>TextView</code>自带跑马灯效果，只需要通过简单的配置，就可以完成滚动的效果。</p><p>在<code>XML</code>中进行配置</p><pre><code>&lt;TextView    android:id=&quot;@+id/test&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:ellipsize=&quot;marquee&quot;    android:focusable=&quot;true&quot;    android:focusableInTouchMode=&quot;true&quot;    android:marqueeRepeatLimit=&quot;marquee_forever&quot;    android:scrollHorizontally=&quot;true&quot;    android:singleLine=&quot;true&quot;    android:text=&quot;我是跑马灯，我是跑马灯，我是跑马灯，我是跑马灯，我是跑马灯，我是跑马&quot;    android:textSize=&quot;28sp&quot; /&gt;</code></pre><p>可以看到需要很多的属性配置，了解一下每个属性的含义：</p><ul><li><code>android:ellipsize=&quot;marquee&quot;</code> 设置为跑马灯效果</li><li><code>android:focusable=&quot;true&quot;</code> 获取焦点</li><li><code>android:focusableInTouchMode=&quot;true&quot;</code> touch 时获取焦点</li><li><code>android:marqueeRepeatLimit=&quot;marquee_forever&quot;</code> 设置重复次数</li><li><code>android:scrollHorizontally=&quot;true&quot;</code> 设置为水平滚动</li><li><code>android:singleLine=&quot;true&quot;</code> 单行显示</li></ul><p>按照上面的配置，正常情况下是可以运转的，但是用到项目中的时候，会发现很多<code>bug</code>和不足之处。</p><p>比如，偶尔突然不滚动了，具体的原因是没有获取到焦点。我觉得这是原生跑马灯最坑的一点，必须获取到焦点才能正常运行。</p><p>当然解决方式也有，第一种，通过主动获取焦点的方式，即调用<code>view.setFocusable(true)</code>。还有一种就是重写<code>TextView</code>的<code>isFocused()</code>方法，强制让他获取焦点。</p><pre><code>@Overridepublic boolean isFocused() {    return true;}</code></pre><p>就算这样，在遇到复杂的界面还是会遇到问题，要么焦点会被断断续续的被抢夺，导致卡顿，要么不符合<code>UI</code>提出的滚动速度要求。</p><h2 id="自定义跑马灯"><a href="#自定义跑马灯" class="headerlink" title="自定义跑马灯"></a>自定义跑马灯</h2><p>鉴于这个背景，通过<code>Scroller</code>完成自定义的跑马灯，代码已上传至<code>GitHub</code>上:</p><div class="github-widget" data-repo="xiaweizi/MarqueeTextView"></div><p>先看一下整体的效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-693d71be1451c080.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MarqueeTextView"></p><p>如果想直接使用，在根<code>build.gradle</code>配置：</p><pre><code>allprojects {    repositories {        ...        maven { url &apos;https://jitpack.io&apos; }    }}</code></pre><p>在<code>app</code>下的<code>build.gradle</code>添加依赖</p><pre><code>dependencies {    compile &apos;com.github.xiaweizi:MarqueeTextView:1.0&apos;}</code></pre><p>最后在<code>XML</code>直接使用即可：</p><pre><code>&lt;com.xiaweizi.marquee.MarqueeTextView     android:id=&quot;@+id/marquee1&quot;     android:layout_width=&quot;match_parent&quot;     android:layout_height=&quot;wrap_content&quot;     android:padding=&quot;10dp&quot;     android:text=&quot;@string/string1&quot;     android:textColor=&quot;#ff0000&quot;     android:textSize=&quot;18sp&quot;     app:scroll_first_delay=&quot;0&quot;     app:scroll_interval=&quot;2000&quot;     app:scroll_mode=&quot;mode_forever&quot; /&gt;</code></pre><p>具有一下功能：</p><ul><li>控制滚动时间</li><li>控制滚动延迟</li><li>控制滚动模式</li><li>生命周期可以自己控制<ul><li>暂停</li><li>继续</li><li>重新开始</li><li>停止</li></ul></li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过<code>Scroller</code>控制器来控制整个<code>View</code>的滚动，那什么是<code>Scroller</code>，做个简单的介绍。</p><p><code>Scroller</code>内部封装了滚动的操作，通过构造函数中传入插值器。可以控制起始位置和整个滚动的时间，并且通过<code>computeScrollOffset()</code>得到滚动动作是否结束。</p><p>最核心的方法有两个：</p><ol><li><p><code>startScroll</code></p><pre><code>/** * @param startX 水平方向滚动的偏移值，以像素为单位。 * @param startY 垂直方向滚动的偏移值，以像素为单位 * @param dx     水平方向滚动的距离 * @param dy     垂直方向滚动的距离 * @param duration 滚动持续的时间，以毫秒为单位 */public void startScroll (int startX, int startY, int dx, int dy, int duration) {    ...} </code></pre></li><li><p><code>computeScrollOffset</code></p><pre><code>/** * @return 返回动画是否结束 */public boolean computeScrollOffset (){    ...}</code></pre></li></ol><p>注释已经很清楚了，那么接下来讲一下滚动的大概实现。</p><p><strong>首先</strong>，要算出从初始位置开始滚动，到结束的距离，其实就是文字的长度。</p><pre><code>/** * 计算滚动的距离 * @return 滚动的距离 */private int calculateScrollingLen() {    TextPaint tp = getPaint();    Rect rect = new Rect();    String strTxt = getText().toString();    tp.getTextBounds(strTxt, 0, strTxt.length(), rect);    return rect.width();}</code></pre><p><strong>其次</strong>，调用<code>startScroll</code>方法进行滚动，注意的是需要调用<code>invalidate</code>方法，才会有效果。</p><p><strong>最后</strong>一个问题就是，滚动结束后继续滚动。<code>Scroller</code>在滚动的时候，会不断回调<code>View</code>的<code>computeScroll</code>方法，于是就可以在这个方法里进行判断，如果结束了，就重新开始。</p><p>到此一个简单的跑马灯效果就实现了，当然如果还想添加别的需要，只要搞懂其原理，这些都不是问题。</p>]]></content>
      
      <categories>
          
          <category> 自定义View实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作积累 </tag>
            
            <tag> 自定义 View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-分享会：Material-Design-在-Android-中的应用</title>
      <link href="/article/31642/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我刚来这个公司的时候，每个周三都会有分享会，主题自定，分享对象尽量是面向大众，一开始觉得不错，但是到后面发现分享的内容不是那么有营养，而且积极性不是很高，都是当做任务进行分享。 程序员因为较为腼腆，分享的人较少，大部分都是客户部、分析部或者推广部的分享，久而久之，氛围就比较消极。</p><a id="more"></a><p>为了提高咱们程序员发言的积极性，增添技术部的沟通氛围，决定之前的分享形式不变，但是改为月末一次，技术部的分享每周一次。主题可以是当前部门的相关技术，当然最好是能够让大众听懂。分享时能够积极讨论，最终目的提高自身的软实力，咱们程序员不能只知道敲代码，是吧？</p><p>那么，轮到我分享了，其实一个月之前就已经通知我让我准备分享，因为公司有个交易项目要上线，比较繁忙，就没太抽出时间准备，直到上个星期五才抽出周末的时间准备。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>说完那么多废话，开始进入正题。最终决定分享主题为『Material Design In Android』。因为之前毕设项目<a href="https://github.com/xiaweizi/QNews" target="_blank" rel="noopener">趣闻</a>中有用到「Support Design」库中的控件，所以写起来会顺手一点。我分三部分准备：</p><ol><li><code>APP</code>准备</li><li>文档准备</li><li><code>Keynote</code>准备</li></ol><h1 id="一、APP准备"><a href="#一、APP准备" class="headerlink" title="一、APP准备"></a>一、APP准备</h1><p>项目已经上传到<code>GitHub</code>上:<a href="https://github.com/xiaweizi/AndroidMD" target="_blank" rel="noopener">AndroidMD</a></p><p>运行效果</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-69724c76b1f4a3d3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MD.gif"></p><p>花了两个多小时做了这个<code>APP</code>，功能简单，主题明确。</p><p>先说说完成这个<code>APP</code>的事前准备:</p><h4 id="1-主题"><a href="#1-主题" class="headerlink" title="1. 主题"></a>1. 主题</h4><p>主题是最近非常火的<a href="https://t2.16163.com/thread-3414567-1-1.html" target="_blank" rel="noopener"><strong>「终结者2:审判日」</strong></a></p><h4 id="2-数据"><a href="#2-数据" class="headerlink" title="2. 数据"></a>2. 数据</h4><p>数据是自己在本地写的<code>json</code>数据，很是尴尬，然后部署到<strong><a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a></strong>上。地址是:<a href="http://owj4ejy7m.bkt.clouddn.com/weaponInfo" target="_blank" rel="noopener">WeaponInfo</a></p><h4 id="3-语言"><a href="#3-语言" class="headerlink" title="3. 语言"></a>3. 语言</h4><p>用的语言是之前学的<strong><code>Kotlin</code></strong>。<a href="http://www.jianshu.com/p/f132e368b88d" target="_blank" rel="noopener">Kotlin学习笔记</a></p><h4 id="4-风格"><a href="#4-风格" class="headerlink" title="4. 风格"></a>4. 风格</h4><p>整体的风格就是我这次分享的主题 <code>Material Desing</code>风格。</p><h1 id="二、整体内容结构的准备"><a href="#二、整体内容结构的准备" class="headerlink" title="二、整体内容结构的准备"></a>二、整体内容结构的准备</h1><p>在做<code>PPT</code>之前，先把结构搭好，并且把<code>PPT</code>的内容先准备好，到时候直接就可以复制到<code>PPT</code>中。</p><p>整体结构:</p><blockquote><ol><li>什么是 <code>Material Design</code></li><li><code>Material Desing</code>的特点</li><li>从四个特点结合<code>Android</code>的应用剖析</li><li>在我的公司「口袋」项目中的应用</li></ol></blockquote><p>当然内容需要看官方的文档和其他资料加上总结才能完成，所以在此感谢一下文章的帮助：</p><blockquote><p><a href="http://www.uisdc.com/comprehensive-material-design-note" target="_blank" rel="noopener">Material Design 学习笔记</a><br><a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material Design 官网介绍文档</a><br><a href="http://md.maxoxo.design/#" target="_blank" rel="noopener">Material Design 中文介绍</a><br><a href="https://developer.android.com/training/material/index.html" target="_blank" rel="noopener">Material Design in Android Developer</a></p></blockquote><h1 id="三、PPT的准备"><a href="#三、PPT的准备" class="headerlink" title="三、PPT的准备"></a>三、<code>PPT</code>的准备</h1><p>有了之前内容的编写，做<code>PPT</code>就方便一点。但是因为刚买的<code>MAC</code>，但又不想再装<code>WPS</code>套餐，于是用的是自带的<code>keynote</code>，所以使用上会有点生疏。不过，整个<code>PPT</code>制作下来对其使用也熟练了起来。</p><p>如果需要的话，可以加个QQ发给你。</p><h3 id="1、封面"><a href="#1、封面" class="headerlink" title="1、封面"></a>1、封面</h3><p><img src="http://upload-images.jianshu.io/upload_images/4043475-e5c6b96043664d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面"></p><blockquote><p>进入<code>MD</code>官网首页就是这张图片。</p></blockquote><h3 id="2、介绍"><a href="#2、介绍" class="headerlink" title="2、介绍"></a>2、介绍</h3><p><img src="http://upload-images.jianshu.io/upload_images/4043475-82acd36ec2a5e1d5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="介绍.gif"></p><blockquote><p>从<code>MD</code>上截取的动画作为入口，大概讲解一下<code>MD</code>的基础概念和特点。</p></blockquote><h3 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a>3、特点</h3><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9530c68384a306db.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特点.gif"></p><blockquote><p>这里抽取了四个点:<code>Material</code>、<code>Elevation</code>、<code>Color</code>和<code>Animation</code>进行分析。</p></blockquote><h3 id="4、风格背景"><a href="#4、风格背景" class="headerlink" title="4、风格背景"></a>4、风格背景</h3><blockquote><p>文字采用圆角+阴影进行包裹，至于高度和圆角效果因为时间紧迫，没有按照严格规范进行设置，如果对这方面有要求可以参考官网详细的规范要求。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-293024e20bdcfa9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="5、动画效果"><a href="#5、动画效果" class="headerlink" title="5、动画效果"></a>5、动画效果</h3><blockquote><p>说起动画，为了能够模仿<code>MD</code>的交互，也是现学现卖了一把。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-5fda106fc9875d3e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交互.gif"></p><p>其实就是背景的放大效果，再加上文字的位移效果。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这应该是本人第一次技术分享，除了内容准备的还算充分，分享的过程不是很满意。本人性格偏内向，平时只默默的撸代码、玩游戏，不愿意主动和别人交流，所以不论分享之前还是期间都表现的很紧张，声音有明显的颤抖，整体节奏把握的不好，很快。</p><p>整个分享过程，感觉自己就是为了将<code>PPT</code>内容放完就等于完成任务似的，导致听的人迷迷糊糊的，一个点还没有放完就跳到了另一个点，致使整个分享结束，听众吸收的部分很少。在结束后，我们老大 也给了我不少建议：分享的内容不在于多，而在于听众吸收了多少，你匆匆忙忙的说完了，底下的人一脸懵逼，这就失去了分享的意义。</p><p>确实，技术分享本来的目的不就是为了让那些对分享主题不熟悉的人能有个大概的了解，能够从中收获到一些在自己领域中得到应用的技能，这就足够了。因此，在分享之前，自己要对分享的知识点有个充分的了解。在分享时能将每个知识点都有个透彻而又完整的分析，不要追求速度。实话说这次分享确实给我带了不少的收获，相信在下次分享中能够有一个满意的表现。</p><hr><hr><p>我————–是————–分————–割————–线</p><hr><hr><h1 id="Material-Design-in-Android"><a href="#Material-Design-in-Android" class="headerlink" title="Material Design in Android"></a><strong>Material Design in Android</strong></h1><p>接下来开始分享这次分享的主要内容,因为<code>MD</code>的介绍和规范在官网上都有非常详细全面的介绍，所以我就不赘述了，建议自己先看一遍官方网站的介绍，这样你对<code>MD</code>的理解会更加深入一些。那我把链接再列出一下：</p><blockquote><p><a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material Design`官网介绍文档</a><br><a href="http://md.maxoxo.design/#" target="_blank" rel="noopener">Material Design 中文介绍</a></p></blockquote><p>当你把官网的内容大致浏览一遍，相信也对<code>MD</code>有个初步的了解，当然要想全部弄懂的话，还得需要消化一阵子，毕竟<code>MD</code>的设计规范细致入微。越读越能感受到它的妙处，假如你能严格按照它的规范进行开发项目，哪怕你不是专业的UI设计师，相信你的产品一定不会难看的。</p><p>那接下来就主要介绍一下<code>Material Desing</code>在<code>Android</code>中应用。。</p><p>跟随着15年<code>Android 5.0</code>的问世，谷歌设计师们还给我们带来的一系列的具有<code>Material Design</code>风格控件。这些控件被统一放置在<code>support design</code>库中，以供开发中使用。使用这些库的前提是<code>API&gt;=21</code>，当然如果你想在 5.0 一下的设备这些控件的话，需要添加<code>appcompat</code>包进行向下兼容。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-eff26b8e6f76e5d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我的<code>design</code>版本是<code>26.1.0</code>,上图大概就是<code>design</code>提供的<code>API</code>，这里我只做简单的使用介绍，如果想了解其原理的话，可以看一下官方的介绍。</p><blockquote><p>这么多我该从何说起呢？我想了下，就按照我做这个小项目，需要的控件顺序说起吧，这样也相当于大家跟我一起做出一个具有<code>Material Design</code>风格的<code>APP</code>了。</p></blockquote><h3 id="1、主题"><a href="#1、主题" class="headerlink" title="1、主题"></a>1、主题</h3><p>一个项目的开始，你得先确定这个项目的主题颜色是什么？你可以使用谷歌给你提供的<code>Material Theme</code>:</p><ul><li><code>@android:style/Theme.Material</code>（深色版本）</li><li><code>@android:style/Theme.Material.Light</code>（浅色版本）</li><li><code>@android:style/Theme.Material.Light.DarkActionBar</code></li></ul><p>当然，也可以使用自定义的主题，先看一下非常普遍的图片:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-8325db1456ddf0d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以通过定制不同的类别的主题颜色，来达到预期的主题效果。</p><ul><li><code>colorPrimary</code> 项目主颜色，一般是<code>Titlebar</code>的背景颜色</li><li><code>colorPrimaryDark</code> 比主颜色深一点颜色，一般是状态栏颜色</li><li><code>textColorPrimary</code> 文字的主颜色</li><li><code>windowBackground</code> 窗口背景颜色</li><li><code>navigationBarColor</code> 导航栏颜色</li></ul><p>通过在<code>styles</code>中配置颜色来定制您的主题，并在<code>AndroidManifest</code>中应用。<br>开发</p><p>[图片上传失败…(image-3f86ab-1513646879600)]</p><h3 id="2、BottomNavigationView"><a href="#2、BottomNavigationView" class="headerlink" title="2、BottomNavigationView"></a>2、BottomNavigationView</h3><p>主题构建好了，下面就是主要内容架构，我大致分为四个模块:武器简介、人物简介、配件简介和空头简介。那么底下就需要一个<code>tab</code>进行切换，<code>BottomNavigationView</code>便开始登场。从名字就可以看出 「底部导航<code>view</code>」，主要的作用在于给每个模块一个导航定位的功能。</p><p>先看一下效果:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-6e02ff6f1cafcc39.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bottomNavigationView.gif"></p><ol><li><p>在<code>menu/</code>下创建菜单文件:</p><pre><code>&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;group android:checkableBehavior=&quot;single&quot;&gt;        &lt;item            android:id=&quot;@+id/bottom_weapon_inc&quot;            android:icon=&quot;@drawable/about&quot;            android:title=&quot;@string/weapon_inc&quot; /&gt;        &lt;!--  省略部分代码     --&gt;    &lt;/group&gt;&lt;/menu&gt;</code></pre></li><li><p><code>XML</code>中进行引用</p><pre><code>&lt;android.support.design.widget.BottomNavigationView    android:id=&quot;@+id/navigation&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:itemBackground=&quot;@color/colorPrimary&quot;    app:itemIconTint=&quot;@android:color/white&quot;    app:itemTextColor=&quot;@android:color/white&quot;    app:menu=&quot;@menu/bottom_menu&quot;/&gt;</code></pre></li><li><p>代码中设置点击事件</p><pre><code>navigation!!.setOnNavigationItemSelectedListener {}</code></pre></li></ol><h3 id="3、DrawerLayout、NavigationView"><a href="#3、DrawerLayout、NavigationView" class="headerlink" title="3、DrawerLayout、NavigationView"></a>3、DrawerLayout、NavigationView</h3><p>和<code>BottomNavigationView</code>相对的，不得不介绍一下<code>NavigationView</code>，这两者都是导航<code>View</code>，后者一般需要配合<code>DrawerLayout</code>实现侧滑菜单效果。</p><p>请看效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-c386ac73a2c4877e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DrawerLayout.gif"></p><p>在<code>XML</code>直接引用</p><pre><code>&lt;android.support.v4.widget.DrawerLayout        android:id=&quot;@+id/dl_main&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;0dp&quot;&gt;        &lt;!-- 主内容 --&gt;        &lt;FrameLayout            android:fitsSystemWindows=&quot;true&quot;            android:id=&quot;@+id/fl_content&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;        &lt;/FrameLayout&gt;        &lt;!-- 侧滑菜单内容 --&gt;        &lt;android.support.design.widget.NavigationView            android:id=&quot;@+id/nv_left&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_gravity=&quot;start&quot;            app:headerLayout=&quot;@layout/nav_header&quot;            app:menu=&quot;@menu/nav_menu&quot;/&gt;    &lt;/android.support.v4.widget.DrawerLayout&gt;</code></pre><p>通过配置<code>layout_gravity</code>的属性来设置侧滑的方向：<code>start</code>：从左侧划出，<code>end</code>从右侧划出。</p><pre><code>headerLayout: 设置其头布局menu: 设置菜单布局</code></pre><p>详细使用请看我之前写的一篇博客：<a href="http://www.jianshu.com/p/ce8a7a20c03c" target="_blank" rel="noopener">高大上的<code>DrawerLayout</code></a></p><h3 id="4、Toolbar"><a href="#4、Toolbar" class="headerlink" title="4、Toolbar"></a>4、Toolbar</h3><p>整体的架构搭建好了，剩下就是开始每个模块的内容了，内容当然少不了标题，那么就开始介绍一下<code>Toolbar</code>。</p><p><code>Toolbar</code>作为早期<code>Android</code>中<code>ActionBar</code>的替代品，定制性和操作性挺高了不少。使用的时候需要设置<code>NoActionBar</code>的主题。</p><pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;&lt;/style&gt;</code></pre><h3 id="5、RecyclerView-SwipeRefreshLayout"><a href="#5、RecyclerView-SwipeRefreshLayout" class="headerlink" title="5、RecyclerView+SwipeRefreshLayout"></a>5、RecyclerView+SwipeRefreshLayout</h3><p>项目中列表肯定是少不了的，那么这就不得不提<code>RecyclerView</code>了，强大之处不用多说，感兴趣的话看一下我之前写的博客，对其使用有个简单的介绍：<a href="https://www.jianshu.com/p/60819de9eb42" target="_blank" rel="noopener">简单粗暴<code>RecyclerView</code></a></p><p>那如果想实现侧滑删除和长按拖拽的功能怎么办呢？<code>RecyclerView</code>原生就支持这些，只需要继承<code>ItemTouchHelper.Callback</code>的类，并实现它几个抽象方法即可。</p><ol><li><p>创建实现<code>ItemTouchHelper.Callback</code>的类</p><pre><code>internal inner class ItemTouchHelperCallback : ItemTouchHelper.Callback() {    override fun getMovementFlags(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder): Int {        val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN        val swipeFlags = ItemTouchHelper.START or ItemTouchHelper.END        return makeMovementFlags(dragFlags, swipeFlags)    }    override fun onMove(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean {        myAdapter!!.onItemMove(viewHolder.adapterPosition, target.adapterPosition)        return false    }    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {        myAdapter!!.onItemDismiss(viewHolder.adapterPosition)    }}</code></pre></li><li><p>和<code>RecyclerView</code>建立连接</p><pre><code>val mItemTouchHelper = ItemTouchHelper(ItemTouchHelperCallback())mItemTouchHelper.attachToRecyclerView(mRecyclerView)</code></pre></li></ol><p>实现效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-276e4cc24cd6a09b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RecyclerView.gif"></p><h3 id="6、CardView"><a href="#6、CardView" class="headerlink" title="6、CardView"></a>6、CardView</h3><p>列表结构写好了，里面内容得优化吧，<code>CardView</code>自带圆角和阴影效果，让每个<code>Item</code>看起来就非常的自然，正如其名像卡片一样，也符合了<code>Material Design</code>特点。</p><p>作为<code>ViewGroup</code>包裹子<code>View</code>实现圆角和阴影的效果：</p><pre><code>&lt;android.support.v7.widget.CardView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_margin=&quot;2dp&quot;    app:cardCornerRadius=&quot;5dp&quot;    app:cardElevation=&quot;5dp&quot;&gt;&lt;/android.support.v7.widget.CardView&gt;</code></pre><p>主要由两个属性控制：</p><ul><li><code>cardCornerRadius</code>：圆角半径</li><li><code>cardElevation</code>：高度(直接影响阴影的大小)</li></ul><h3 id="7、CoordinatorLayout-AppBarLayout-Toolbar"><a href="#7、CoordinatorLayout-AppBarLayout-Toolbar" class="headerlink" title="7、CoordinatorLayout+AppBarLayout+Toolbar"></a>7、CoordinatorLayout+AppBarLayout+Toolbar</h3><p>列表写好了，接下来就是滑动的交互，<code>CoordinatorLayout</code>：作为根<code>View</code>或者是一个活多个子<code>View</code>特定的容器，用于协调子<code>View</code>之间滑动的交互，可以说<code>CoordinatorLayout</code>是整个<code>Design</code>库中最核心的控件。</p><p><code>AppBarLayout</code>其实就是<code>LinearLayout</code>,通过<code>layout_scrollFlags</code>来控制滑动的效果。前提是滑动<code>view</code>必须实现<code>NestedScrollingChild</code>的接口，且需要配置<code>behavior</code>，最基本的使用就是：</p><pre><code>&lt;android.support.design.widget.CoordinatorLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;android.support.design.widget.AppBarLayout        android:id=&quot;@+id/appbar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;android.support.v7.widget.Toolbar            android:id=&quot;@+id/toolbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;?attr/actionBarSize&quot;            android:background=&quot;?attr/colorPrimary&quot;            android:fitsSystemWindows=&quot;true&quot;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;            app:layout_scrollFlags=&quot;scroll|enterAlwaysCollapsed&quot;            app:popupTheme=&quot;@style/Theme.AppCompat.Light&quot; /&gt;    &lt;/android.support.design.widget.AppBarLayout&gt;    &lt;android.support.v4.widget.SwipeRefreshLayout        android:id=&quot;@+id/refresh_layout&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;        &lt;android.support.v7.widget.RecyclerView            android:id=&quot;@+id/recyclerView&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:foregroundGravity=&quot;center&quot; /&gt;    &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre><p>有两个重点：</p><ul><li>滑动的<code>view</code>必须实现<code>NestedScrollingChild</code>接口。比如<code>RecyclerView</code>、<code>NestedScrollView</code>.</li><li>必须配置<code>behavior</code>。<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code></li></ul><p>来看一下<code>layout_scrollFlags</code>有哪些属性，为了方便理解，将可以滑动的<code>view</code>简称为<code>ScrollView</code>,设置了<code>layout_scrollFlags</code>称为<code>DependentView</code>：</p><h4 id="1-scroll"><a href="#1-scroll" class="headerlink" title="1. scroll"></a>1. scroll</h4><p>子<code>view</code>必须设置该属性其他的属性的才会生效，这个是最基本的属性。</p><h4 id="2-scroll-enterAlways"><a href="#2-scroll-enterAlways" class="headerlink" title="2. scroll|enterAlways"></a>2. scroll|enterAlways</h4><p>只要<code>ScrollView</code>滑动，滑动事件就会交给设置<code>DependentView</code>，当<code>DependentView</code>滑动结束才会将事件交给<code>ScorllView</code>。也就是下面的效果:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-df42e9245f9747ed.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enterAlways.gif"></p><h4 id="3-scroll-enterAlwaysCollapsed"><a href="#3-scroll-enterAlwaysCollapsed" class="headerlink" title="3. scroll|enterAlwaysCollapsed"></a>3. scroll|enterAlwaysCollapsed</h4><p>当<code>ScrollView</code>向下滑动时，<code>DependentView</code>先折叠到最小高度(这里是0),然后将事件交给<code>ScrollView</code>，当<code>ScrollView</code>滑动结束，<code>DependentView</code>才继续滑动事件，直至展开，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-2941d0adaa3ada9c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enterAlwaysCollapsed.gif"></p><h4 id="4-scroll-enterAlwaysCollapsed-enterAlways"><a href="#4-scroll-enterAlwaysCollapsed-enterAlways" class="headerlink" title="4. scroll|enterAlwaysCollapsed|enterAlways"></a>4. scroll|enterAlwaysCollapsed|enterAlways</h4><p>这边就展示一下折叠的效果，我们先设置最小的高度</p><pre><code>&lt;android.support.v7.widget.Toolbar    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;100dp&quot;    android:minHeight=&quot;50dp&quot;    app:layout_scrollFlags=&quot;scroll|enterAlwaysCollapsed|enterAlways&quot; /&gt;</code></pre><p>展示一下效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-24e0d5bd7a84b488.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="see.gif"></p><h4 id="5-scroll-exitUntilCollapsed"><a href="#5-scroll-exitUntilCollapsed" class="headerlink" title="5. scroll|exitUntilCollapsed"></a>5. scroll|exitUntilCollapsed</h4><p>这个搭配重点在于上拉的时候，<code>DependentView</code>会先折叠到最小高度，然后事件全部交给<code>ScrollView</code>。那下拉的时候就是当<code>ScrollView</code>滑动结束，才开始<code>DependentView</code>的滑动事件。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-a125be21d3383259.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exitUntilCollapsed.gif"></p><h4 id="6-scroll-enterAlways-snap"><a href="#6-scroll-enterAlways-snap" class="headerlink" title="6. scroll|enterAlways|snap"></a>6. scroll|enterAlways|snap</h4><p>这个<code>snap</code>就是在上面的基础上多了一个回弹的效果,当<code>DependentView</code>正在滑动，此时手指离开屏幕时，<code>DependentView</code>会自动移动到离自己较劲的终点或者始点。效果如下:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-5f1f30e9b70ca8ad.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="snap.gif"></p><p>上面的属性完全可以像第四种情况叠加使用，至于效果自己尝试了了才能感觉到它的奥妙之处。</p><h3 id="8、转场动画"><a href="#8、转场动画" class="headerlink" title="8、转场动画"></a>8、转场动画</h3><p>交互有了，现在看是添加点击跳转效果了。咱们之前跳转动画都是在<code>startActivity</code>之后调用<code>overridePendingTransition</code>方法，传入进入和退出的动画实现跳转动画。<code>Android 5.0</code>提供了强大的转场动画，给每个<code>item</code>赋予了生命，跳转时，仿佛每块布局都参与了这次搬迁大运动。</p><p>使用时，需在<code>setContentView()</code>之前加上</p><pre><code>window.requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)</code></pre><p>跳转时候这样写:</p><pre><code>startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(activity).toBundle())</code></pre><p>跳转的界面设置转场动画或者出场动画：</p><pre><code>window.enterTransition = Explode()window.exitTransition = Slide()</code></pre><p>为了看出效果我设置了2s的延迟：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-fe29a3732dfc83f6.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Transition.gif"></p><h3 id="9、Toast、SnackBar和AlertDialog"><a href="#9、Toast、SnackBar和AlertDialog" class="headerlink" title="9、Toast、SnackBar和AlertDialog"></a>9、Toast、SnackBar和AlertDialog</h3><p>基本的界面写完了，剩下的就是一些逻辑上的操作啦，比如「提示」。那么<code>Android</code>提示分为三种：</p><ul><li>友好的<code>Toast</code>(比如网络失败)</li><li>拥有附加行为的提示<code>SnackBar</code>(比如误删信息回撤)</li><li>强制让用户做出选择的<code>AlertDialg</code>(比如未登录)</li></ul><p>那么这三种的效果是什么呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-18678d48084a5701.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TSA.gif"></p><p>大概先讲这些，有时间再进行后续补充。</p><h1 id="Material-Design在「口袋」中的应用"><a href="#Material-Design在「口袋」中的应用" class="headerlink" title="Material Design在「口袋」中的应用"></a><code>Material Design</code>在「口袋」中的应用</h1><p>其实在咱们的「口袋贵金属」项目中也到找到很多<code>MD</code>的元素。</p><p>首先是点击的水波纹效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-a19996587c89e708.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ripple.gif"></p><p>其次是交易圈的滑动交互:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9ecae2ddb8be50ef.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="circle.gif"></p><p>还有就是本人在「口袋」接手的第二个需求，「个人中心」。看一下效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-4431f1f722e17eb2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="personal.gif"></p><blockquote><p>严格按照<code>Material Design</code>风格进行开发，相信一定能开发出非常漂亮的<code>APP</code>！</p></blockquote><p><a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Material Design </tag>
            
            <tag> 工作积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git-命令小结</title>
      <link href="/article/52360/"/>
      <content type="html"><![CDATA[<blockquote><p>数据来源于网络，仅供平时查询使用</p></blockquote><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code>// 在当前目录新建一个 Git 代码库git init// 新建一个目录，将其初始化为 Git 代码库git init [project-name]// 下载一个项目git clone [project-url]</code></pre><a id="more"></a><h2 id="二、基础配置"><a href="#二、基础配置" class="headerlink" title="二、基础配置"></a>二、基础配置</h2><pre><code>// 显示当前所有的 Git 配置git config --list// 编辑 Git 配置文件git config -e [--global]// 设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email]&quot;</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code>// 添加文件到暂存区git add [file] [file1] ...// 添加指定目录到暂存区，包括子目录git add [dir]// 添加当前目录的所有文件到暂存区git add .// 添加每个变化钱，都会要求确认// 对于同一个文件的多出变化，可以实现分次提交git add -p// 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...// 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]// 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code>// 提交暂存区到仓库区git commit -m &quot;[message]&quot;// 提交暂存区指定的文件到仓库区git commit [file1] [file2] ... -m [message]// 提交工作区自上次 commit 之后的变化，直接到仓库区git commit -a// 提交时显示所有 diff 信息git commit -b// 使用一次新的 commit，替代上一次提交git commit --amend -m &quot;[message]&quot;// 重新上一次的 commit，并包括之id那个文件的新变化git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code>// 列出所有本地的分支git branch// 列出所有远程的分支git branch -r// 列出所有本地分支和远程分支git branch -a// 新建一个分支，但依然停留在当前的分支git branch [branch_name]// 新建一个分支，并且切换到该分支git checkout -b [branch_name]// 新建一个分支，指向指定的 commitgit branch [branch_name] [commit]// 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch_name] [remote_branch]// 切换到指定的分支，并更新工作区git checkout [branch_name]// 切换到上一个分支git checkout -// 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch_name] [remote_branch]// 合并指定分支到当前分支git merge [branch_name]// 选择一个 commit，合并到当前的分支git cherry-pick [commit]// 删除分支git branch -d [branch_name]// 删除远程分支git push origin --delete [branch_name]git branch -dr [remote/branch_name]</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code>// 列出所有 taggit tag// 新建一个 tag 在当前的 commitgit tag [tag]// 新建一个 tag 在指定的 commitgit tab [tag] [commit]// 删除本地 taggit tag -d [tag]// 删除远程 taggit push orgin :refs/tags/[tag]// 查看 tag 信息git show [tag]// 提交指定 tag 信息git push [remote] [tag]// 提交所有 taggit push [remote] --tags// 新建一个分支，指向指定某个 taggit checkout -b [branch] [tag]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code>// 显示所有变更的文件git status// 显示当前分支的版本历史git log// 显示 commit 历史，以及每次 commit 发生的变更git log --stat// 搜索提交历史，根据关键词git log -S [keyword]// 显示某个 commit 之后所有的变动，每个 commit 占据一行git log [tag] HEAD --pretty=format:%s// 显示某个文件的版本历史，包括文件名git log --follow [file]git whatchanged [file]// 显示指定文件相关的每一次 diffgit log -p [file]// 显示过去5次提交git log -5 --pretty --oneline// 显示所有提交过的用户，按提交次数排序git shortlog -sn// 显示指定文件是什么人在什么时候修改过git blame [file]// 显示暂存区和工作区的差异git diff// 显示暂存区和上一个 commit 的差异git diff --cached [file]// 显示暂存区与当前分支最新 commit 之间的差异git diff HEAD// 显示两次提交之间的差异git diff [first_branch]...[second_branch]// 显示今天你写了多少行代码git diff --shortstat &quot;@{0 day ago}&quot;// 显示某次提交的元数据和内容变化git show [commit]// 显示某次提交发生变化的文件git show --name-only [commit]// 显示某次提交时，某个文件的内容git show [commit]:[fileName]// 显示当前分支的最近几次提交git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code>// 下载远程仓库的所有变动git fetch [remote]// 显示所有远程仓库git remote -v// 显示某个远程仓库的信息git remote show [remote]// 增加一个新的远程仓库，并命名git remote add [shortName] [url]// 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]// 上传本地指定分支到远程仓库git push [remote] --force// 推送所有分支到远程仓库git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><pre><code>// 恢复暂存区的指定文件到工作区git checkout [file]// 恢复某个 commit 的指定文件到暂存区和工作区git checkout [commit] [file]// 恢复暂存区的所有文件到工作区git checkout .// 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变git reset [file]// 重置暂存区和工作区，与上一次的 commit 保持一致git reset --hard// 重置当iqanefnzhi的指针为指定 commit，同时重置暂存区git reset [commit]// 重置当前分支的HEAD为指定的 commit，同时重置暂存区和工作区git reset --hard [commit]// 重置当前HEAD为指定的 commit，但保持暂存区和工作区不变git rest --keep [commit]// 新建一个 commit，用来撤销指定的 commit// 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]// 暂时将为提交的变化移除，稍后再移入git stashgit stash pop</code></pre>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Kotlin重构项目</title>
      <link href="/article/13823/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周大概花了一个星期的时间初步学习了一下<code>Kotlin</code>，并且同步写了<a href="http://www.jianshu.com/p/f132e368b88d" target="_blank" rel="noopener">Kotlin 笔记</a>，方便后面使用的时候查询一些语法的用法。</p><a id="more"></a><p>一周的<code>Kotlin</code>学习下来，虽然只掌握了<code>Kotlin</code>的皮毛，但仍被其简单便捷的语法吸引。目前<code>Kotlin</code>已经成为<code>Android</code>的官方推荐语言，所以建议有时间的同学不妨学习一下，相信一定可以帮助你提高开发效率的。</p><p>这里就不介绍<code>Kotlin</code>的语法使用，既然初步学习了<code>Kotlin</code>，那么就在实践中检验一下，使用的是之前的毕业设计项目</p><div class="github-widget" data-repo="xiaweizi/QNews"></div><p>，这个项目总体来说很适合初学者，所以就拿它上手，改起来相对比较简单。</p><p>所以本篇文章就介绍一下<code>Kotlin</code>在<code>Android</code>中的使用，相信你会爱上他的。</p><p>先看一下运行效果吧，跟之前<a href="http://www.jianshu.com/p/ae4aa11f35a4" target="_blank" rel="noopener">快毕业了，撸个小项目</a>效果是一模一样，所以大致看一下即可：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-65effeb19b751e39.gif?imageMogr2/auto-orient/strip" alt="运行效果.gif"></p><p>这里就展示一下基本的效果，想要了解详情的就<code>fork</code>一下我的代码吧:<a href="https://github.com/xiaweizi/QNews" target="_blank" rel="noopener">QNews</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-Android-Studio集成Kotlin插件"><a href="#1-Android-Studio集成Kotlin插件" class="headerlink" title="1. Android Studio集成Kotlin插件"></a>1. <code>Android Studio</code>集成<code>Kotlin</code>插件</h3><p>通过<code>Android Studio</code>添加<code>Kotlin</code>插件：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-f78dbad6f4cb211f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kotlin插件"></p><p>进行相关的配置：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-eed2a897793f5265.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相关配置"></p><p>集成好了，记得同步一下，这个时候在<code>build.gradle</code>下会生成对<code>Kotlin</code>插件的引用：</p><pre><code>// 根 build.gradleclasspath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;// module build.gradleapply plugin: &apos;kotlin-android&apos;compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot;</code></pre><p>这个时候配合着<a href="https://github.com/Kotlin/anko" target="_blank" rel="noopener">anko</a>使用效果更好呦，只需要在<code>build.gradle</code>中进行相应的配置：</p><pre><code>apply plugin: &apos;kotlin-android-extensions&apos;compile &quot;org.jetbrains.anko:anko-sdk15:0.9.1&quot;</code></pre><p>就这么两行的配置即可告别<code>findViewById</code>的繁琐过程，目前这个项目对于<code>ButterKnife</code>的依赖我都去掉了，极其方便。</p><p>只要<code>XML</code>定义了<code>&quot;@+id/test&quot;</code>，就可以直接引用这个<code>View</code>.</p><p>比如我的这个跳转界面<code>SplashActivity</code>的<code>XML</code>：</p><pre><code>&lt;ImageView    android:id=&quot;@+id/iv_splash&quot;    android:background=&quot;?attr/colorPrimary&quot;    android:layout_centerInParent=&quot;true&quot;    android:src=&quot;@mipmap/ic_splash&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre><p>代码中可以直接使用(属性动画)：</p><pre><code>val translationX: ObjectAnimator = ObjectAnimator.ofFloat(iv_splash, &quot;translationX&quot;, 600f, 0f)</code></pre>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 项目重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin学习笔记</title>
      <link href="/article/40024/"/>
      <content type="html"><![CDATA[<blockquote><p>项目未来可能需要使用<code>kotlin</code>开发，所以特此记录一下学习笔记，仅供参考，方便后期查询。已同步到<code>GitHub</code>上：<a href="https://github.com/xiaweizi/KotlinTest.git" target="_blank" rel="noopener">KotlinTest</a></p></blockquote><a id="more"></a><h2 id="Kotlin-简介"><a href="#Kotlin-简介" class="headerlink" title="Kotlin 简介"></a>Kotlin 简介</h2><p><code>kotlin</code> 的目标是成为一门全栈语言，主要有以下的特点：</p><ul><li>已经成为<code>Android</code>的官方推荐语言</li><li>百分百的和<code>java</code>兼容,两者可以相互转换</li><li><code>JS</code>、<code>JVM</code>、<code>Native</code>多平台开发</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h4><pre><code>Boolean true/falseDouble 64Float  32Long   64Int    32Short  32Byte   8val aChar = &apos;0&apos;val bChar = &apos;我&apos;val cChar = &apos;\u000f&apos;</code></pre><p><code>Char</code>类型的转义字符</p><pre><code>\t          制表符\b          光标后退一个字符\n          回车\r          光标回到行首\&apos;          单引号\&quot;          双引号\\          反斜杠\$          美元符号，Kotlin 支持美元符号开头的字符串模板</code></pre><h4 id="2-基本类型的转换"><a href="#2-基本类型的转换" class="headerlink" title="2. 基本类型的转换"></a>2. 基本类型的转换</h4><p>不可隐式转换</p><pre><code>val anInt: Int = 5val aLong: Long = anInt.toLong()</code></pre><p>必须得通过<code>.to类型</code>的方式进行数据的转换</p><p><strong>字符串</strong></p><ul><li>一串<code>Char</code></li><li><p>用双引号””引起来</p><p>  val aString: String = “Hello World!”</p></li><li><p>字符串比较</p><p>  a == b 表示比较内容 类似 Java 中的 equals<br>  a === b 表示比较对象是否相同</p></li><li><p>字符串模板</p><p>  println(“hello, $name”) -&gt; “hello, 小明”</p></li></ul><h4 id="3-Koltin-中的类和对象初始化"><a href="#3-Koltin-中的类和对象初始化" class="headerlink" title="3. Koltin 中的类和对象初始化"></a>3. Koltin 中的类和对象初始化</h4><p><strong>类的定义</strong></p><ul><li>类，一个抽象的概念</li><li>具有某些特征的事物的概括</li><li>不特定指代任何一个具体的事物</li></ul><p>一般写法：</p><pre><code>/*** 其中类参数如果加上 var 修饰，那么他便是成员变量，反之则是普通的参数*/class Student(var name: String, var age: Int){    init {        // ... 相当于构造函数中的代码    }}</code></pre><p><strong>对象</strong></p><ul><li>是一个具体的概念，与类相对</li><li>描述某一个类的具体个体</li><li><p>举例：</p><p>  某些人、领导的车等等</p></li></ul><p><strong>类和对象的关系</strong></p><ul><li>一个类通常可以有很多歌具体的对象</li><li>一个对象本质上只能从属一个类</li><li>某一个人，他是工程师，但本质上还是属于人这一类</li></ul><p>一般写法：</p><pre><code>val student: Student = Student(&quot;xiaweizi&quot;, 23)</code></pre><p><strong>类的继承</strong></p><ul><li>提取多个类的共性得到一个更为抽象的类，即父类</li><li>子类拥有父类的一切特征</li><li>子类也可以定义自己的特征</li><li>所有的类最终继承自<code>Any</code>,类似于<code>java</code>中的<code>Object</code></li></ul><h4 id="4-空类型和智能转换"><a href="#4-空类型和智能转换" class="headerlink" title="4. 空类型和智能转换"></a>4. 空类型和智能转换</h4><p><strong>空类型</strong></p><pre><code>// 定义val notNull: String = null // 错误，不可能为空val nullanle: String? = null // 正确，可以为空// 使用notNull.length // 正确，不可能为空所以可以直接使用nullable.length // 有可能为空，不能直接获取长度// 要想获取长度，可以通过以下两者方式nullable!!.length // 正确，强制认定 nullable 不可能为空，如果为空则会抛出空指针异常nullable?.length // 正确，若 nullable 为空，则返回 null</code></pre><p><strong>智能类型转换</strong></p><pre><code>val child: Child = parent as Child // 类似于 Java 的类型转换，失败则抛出异常val child: Child = parent as? Child // 如果转换失败，返回 null</code></pre><p>编译器智能识别转换：</p><pre><code>val parent: Parent = Child()if (parent is Child) {    // parent 直接调用子类方法,不需要再进行强制转换}val string: String = nullif (string != null) {    // string.length 可以直接调用length 方法}</code></pre><h4 id="5-区间"><a href="#5-区间" class="headerlink" title="5. 区间"></a>5. 区间</h4><p>一个数学上的概念，表示范围， <code>ClosedRange</code>的子类，<code>IntRange</code>最常用</p><p>基本用法：</p><pre><code>0..100 --&gt; [0, 100]0 until 100 --&gt; [0, 100)i in 0..100 表示 i 是否在区间[0, 100]中</code></pre><h4 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h4><p>基本写法：</p><pre><code>val ints: IntArray = IntArrayOf(1,2,3,5)var charArray: CharArray = charArrayOf(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;)var stringArray: Array&lt;String&gt; = arrayOf(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;e&quot;)</code></pre><p>基本操作：</p><pre><code>print(charArray[index])ints[0] = 2ints.lengthcahrArray.joinToString(&quot;&quot;) // 讲 char 数组转换成字符串stringArray.slice(1..4) // 取出区间里的值</code></pre><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h4 id="1-常亮和变量"><a href="#1-常亮和变量" class="headerlink" title="1. 常亮和变量"></a>1. 常亮和变量</h4><p><strong>常量</strong></p><pre><code>val a = 2类似 Java 中的 final不可被重复赋值运行时常量：val x = getX()编译期常量：const val x = 2</code></pre><p><strong>变量</strong></p><pre><code>var a = 2a = 3 // 可以被再次赋值</code></pre><p><strong>类型推导</strong></p><pre><code>val string = &quot;Hello&quot; // 推导出 String 类型val int = 5 // 推导出 Int 类型var x = getString() + 5 // String 类型</code></pre><h4 id="2-函数-Function"><a href="#2-函数-Function" class="headerlink" title="2. 函数 Function"></a>2. 函数 Function</h4><p>以特定功能组织起来的代码块</p><pre><code>// 最简单的打印信息，无返回的方法fun printMessage(message: String):Unit{    println(&quot;$message&quot;)}// 拥有返回值得方法fun sum(first: Int, second: Int):Int {    return first + second}// 可以简化成：fun sum(first: Int, second: Int) = first + second// 或者更简单的匿名函数val result = fun(first: Int, second: Int) = first + second</code></pre><h4 id="3-Lambda-表达式"><a href="#3-Lambda-表达式" class="headerlink" title="3. Lambda 表达式"></a>3. Lambda 表达式</h4><p>其实又是匿名函数</p><p> <strong>一般形式</strong>：</p><pre><code>{传入参数 -&gt; 函数体，最后一行是返回值}// 例如val sum = {first: Int, second: Int -&gt; first + second}val printMessage = {message: String -&gt; println(message)}</code></pre><p><strong>类型标识</strong></p><pre><code>() -&gt; Unit // 无参，返回值为 null(Int) -&gt; Int // 传入整型，返回一个整型(String, (String) -&gt; String) -&gt; Boolean // 传入字符串、Lambda 表达式，返回Boolean</code></pre><p><strong>Lambda 表达式的简化</strong></p><ul><li>函数参数调用时最后一个<code>Lambda</code>可以移出去</li><li>函数参数只有一个<code>Lambda</code>，调用时小括号可以省略</li><li><code>Lambda</code>只有一个参数可默认为<code>it</code></li><li>入参、返回值与形参一致的函数可以用函数引用方式作为实参传入</li></ul><h4 id="4-成员变量和成员方法"><a href="#4-成员变量和成员方法" class="headerlink" title="4. 成员变量和成员方法"></a>4. 成员变量和成员方法</h4><p><strong>成员变量的声明</strong></p><pre><code>// 第一种是在构造函数中声明class Student(var age: Int, name: String){    // age 是成员变量 name 是局部变量}// 第二种是在函数体内声明var a = 0    get() {        field += 1        return field    }    set(value) {        println(&quot;set)        field = value + 1    }// 可以进行对 get 和 set 方法的重新定义// 属性的初始化尽量在构造方法中完成// var 用 lateinit 延迟初始化， val 用 lazylateinit var sex: Stringval person: Person by lazy {    Person()}</code></pre><p><strong>成员方法</strong></p><p>在类中直接声明方法可以直接调用,包括<code>lambda</code>表达式</p><pre><code>// 方法的声明fun sum(a: Int, b: Int) = a + bval sum1 = {a: Int, b: Int -&gt; a + b}// 方法的调用println(person.sum(1,2))println(person.sum1(3,5))</code></pre><h4 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h4><p>在<code>java</code>中运算符是不能重新定义重载的，只能按照原先的逻辑进行计算</p><p>而<code>Kotlin</code>则可以重新定义运算符，使用<code>operator</code>关键字，举了例子：</p><pre><code>// 定义一个用于计算复数的类class Complex(var real: Double, var imaginary: Double) {    operator fun plus(other: Complex): Complex{        return Complex(real+other.real, imaginary+other.imaginary)    }    // 重新 toString 方法    overrride fun toString(): String {        return &quot;$real + ${imaginary}i&quot;    }}// 使用val complex1 = Complex(1, 2)val complex2 = Complex(2, 3)println(complex1 + complex2)// 输出结果为&quot;3 + 5i&quot;</code></pre><p>关键就是这个方法，方法名必须是<code>plus</code>或者其他官方定义的运算符，参数有且仅有一个，类型自定义，返回值意识可以自定义的.</p><pre><code>operator fun plus(other: Complex): Complex{        return Complex(real+other.real, imaginary+other.imaginary)}</code></pre><h4 id="6-表达式"><a href="#6-表达式" class="headerlink" title="6. 表达式"></a>6. 表达式</h4><p><strong>中缀表达式</strong></p><p>通过<code>infix</code>关键字修复方法，那么就可以不用通过 对象.方法() 的方式调用，而是直接 对象 方法名 参数的方式调用。举了例子</p><pre><code>class Student(var age: Int){    infix fun big(student: Student): Boolean {        return age &gt; student.age    }}// 如果没有 infix 的调用方式：println(Student(23).big(Student)(12))// 如果使用 infix 修饰的调用方式:println(Student(23) big Student(12))</code></pre><p><strong><code>if</code>表达式</strong></p><p>直接来个例子</p><pre><code>val a = 20val b = 30val flag: Int = if(a &gt; b) a else b</code></pre><p><strong><code>When</code> 表达式</strong></p><p> 加强版的 <code>switch</code>，支持任意类型， 支持纯粹表达式条件分支(类似<code>if</code>)，举个栗子：</p><pre><code>val a = 5when(a) {    is Int -&gt; println(&quot;$a is Int&quot;)    in 1..6 -&gt; println(&quot;$a is in 1..6&quot;)    !in 1..4 -&gt; println(&quot;$a is not in 1..4&quot;)    else -&gt; {        println(&quot;null&quot;)    }}</code></pre><p> <strong><code>for</code>循环</strong></p><p> 基本写法</p><pre><code>for (element in elements)</code></pre><p><strong><code>while</code>循环</strong></p><p>基本写法</p><pre><code>while() {}do {} while()</code></pre><p>跳过和终止循环</p><pre><code>跳过当前循环用 continue终止循环用 break</code></pre><h4 id="6-异常捕获"><a href="#6-异常捕获" class="headerlink" title="6. 异常捕获"></a>6. 异常捕获</h4><p>同样也是表达式，可以用来赋值，举个例子</p><pre><code>return try{            x/y        }        catch(e: Exception) {            0        } finally {            //...        }</code></pre><p>如果没有异常则返回<code>x/y</code>,否则返回<code>0</code>,<code>finally</code>中的代码无论如何还是要执行的。</p><h4 id="7-具名参数、变长参数和默认参数"><a href="#7-具名参数、变长参数和默认参数" class="headerlink" title="7. 具名参数、变长参数和默认参数"></a>7. 具名参数、变长参数和默认参数</h4><p><strong>具名参数：</strong>给函数的实参附上形参</p><pre><code>fun sum(first: Int, second: Int) = first + secondsum(second = 2, first = 1)</code></pre><p><strong>变长参数：</strong>用<code>varary</code>修饰，使用起来是和数组一样，某个参数可以接收多个值，可以不作为最后一个参数，如果传参时有歧义，需要使用具名参数。</p><pre><code>fun hello(vararg ints: Int, string: String) = ints.forEach(println(it))hello(1,3,4,5,string = &quot;hello&quot;)// 如果最后一个参数也是 Intfun hello(varary ints: Int, anInt: Int)// 创建数组val arrayInt: IntArray = intArrayOf(1, 2, 3, 4)hello(ints = *arrayInt, anInt = 2)</code></pre><p><strong>默认参数：</strong>就是给参数传入一个默认的值</p><pre><code>fun hello(anInt: Int = 1, string: String)hello(string = &quot;aaa&quot;)</code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><p><strong>继承语法要点：</strong></p><ul><li>父类需要<code>open</code>才可以被继承</li><li>父类方法、属性需要<code>open</code>才可以被覆写</li><li>接口、接口方法、抽象类默认为<code>open</code></li><li>覆写父类(接口)成员需要<code>override</code>关键字</li></ul><p><strong>语法要点：</strong></p><ul><li><code>class A: B(), C, D</code></li><li>继承类时实际上调用了父类的构造方法</li><li>类只能单继承，接口可以多实现</li></ul><p><strong>接口代理：</strong></p><p>一个类可以直接将自己的任务委托给接口的方法实现，举个例子：</p><pre><code>interface Drive{    fun drive()}interface Sing{    fun sing()}class CarDrive: Drive{    override fun drive() {        println(&quot;我会开车呦&quot;)    }}class LoveSing: Sing{    override fun sing() {        println(&quot;我会唱歌呦&quot;)    }}class Manager(drive: Drive, sing: Sing): Drive by drive, Sing by singfun main(args: Array&lt;String&gt;) {    val carDrive = CarDrive()    val loveSing = LoveSing()    val manager = Manager(carDrive, loveSing)    manager.drive()    manager.sing()}</code></pre><p>这样，<code>manager</code>不用做任何事情，完全交付给接口实现.</p><p><strong>接口方法冲突：</strong></p><p>接口方法可以有默认实现，通过<code>super&lt;父类名&gt;</code>.<a href="[参数列表]">方法名</a></p><pre><code>interface A{    fun a() = 0}interface B{    fun a() = 1}interface C{    fun a() = 2}class D(var aInt: Int): A,B,C{    override fun a(): Int {        return when(aInt){            in 1..10 -&gt;{                super&lt;A&gt;.a()            }            in 11..100 -&gt;{                 super&lt;B&gt;.a()             }            else -&gt; {                println(&quot;dd&quot;)                super&lt;C&gt;.a()            }        }    }}</code></pre><h4 id="2-类及成员的可见性"><a href="#2-类及成员的可见性" class="headerlink" title="2. 类及成员的可见性"></a>2. 类及成员的可见性</h4><p>跟<code>java</code>类似，<code>private、protected、public</code>，其中<code>internal</code>代表的是模块内可见</p><h4 id="3-Object"><a href="#3-Object" class="headerlink" title="3. Object"></a>3. <code>Object</code></h4><p>相当于<code>Java</code>中的单例模式，有以下特点</p><ul><li>只有一个实例的类</li><li>不能自定义构造方法</li><li>可以实现接口、继承父类</li><li><p>本质上就是单例模式最基本的实现</p><pre><code>interface getDataSuccess{    fun success()}abstract class getDataField{    abstract fun failed()}object NetUtil: getDataField(), getDataSuccess{    override fun success() {        println(&quot;success&quot;)    }    override fun failed() {        println(&quot;failed&quot;)    }    val state: Int = 0    fun getData(): String = &quot;请求成功&quot;}</code></pre></li></ul><h4 id="3-伴生对象和静态成员"><a href="#3-伴生对象和静态成员" class="headerlink" title="3. 伴生对象和静态成员"></a>3. 伴生对象和静态成员</h4><p>相当于<code>java</code>中的静态方法</p><ul><li>每个类可以对应一个伴生对象</li><li>伴生对象的成员全局独一份</li><li><p>如果<code>java</code>中想直接调用<code>kotlin</code>中的静态方法或者静态变量，可以考虑使用<code>JvmField JvmStatic</code>.</p><pre><code>open class Util private constructor(var anInt: Int) {    companion object {        @JvmStatic        fun plus(first: Int, second: Int) = first + second        fun copy(util: Util) = Util(util.anInt)        @JvmField        val tag = &quot;tag&quot;    }}</code></pre></li></ul><h4 id="4-方法的重载"><a href="#4-方法的重载" class="headerlink" title="4. 方法的重载"></a>4. 方法的重载</h4><p>通过给方法的参数配置默认值，即可实现方法的重载，按理说，一切可以拥有默认值的方法重载才是合理的方法重载。</p><p>名称形同、参数不同，跟返回值没有关系</p><pre><code>class OverLoadTest {    @JvmOverLoads    fun a(anInt: Int = 0, string: String=&quot;&quot;) = 1}val test = OverLoadTest()test.a(1, &quot;&quot;)test.a()test.a(anInt = 2)test.a(string = &quot;&quot;)</code></pre><p>使用<code>JvmOverLoads</code>是为了方便<code>Java</code>中调用方法的重载.</p><h4 id="5-扩展方法"><a href="#5-扩展方法" class="headerlink" title="5. 扩展方法"></a>5. 扩展方法</h4><p><code>kotlin</code>中的扩展方法，我认为相当于<code>java</code>中的代理模式，拿到被代理的对象，然后进行一系列的操作。</p><pre><code>fun String.add(anInt: Int): String {    var sb = StringBuilder()    for (i in 0 until anInt) {        sb.append(this)    }    return sb.toString()}operator fun String.times(anInt: Int): String {    var sb = StringBuilder()    for (i in 0 until anInt) {        sb.append(this)    }    return sb.toString()}// 使用var string = &quot;xiaweizi&quot;println(string.add(5))println(string * (3))</code></pre><h4 id="6-属性代理"><a href="#6-属性代理" class="headerlink" title="6. 属性代理"></a>6. 属性代理</h4><p>类似之前说的<code>var anInt: Int by lazy{2}</code>,懒赋值就是使用的属性代理，来看个例子：</p><pre><code>fun main(args: Array&lt;String&gt;) {    val a: Int by DelegatesTest()    println(a)    var b: Int by DelegatesTest()    b = 3    println(b)}class DelegatesTest {    private var anInt: Int? = null    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Int {        println(&quot;getValue&quot;)        return anInt?:0    }    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: Int): Unit {        println(&quot;setValue&quot;)        this.anInt = value    }}</code></pre><blockquote><p><code>val</code> 对应 <code>getValue</code>，<code>var</code>对应<code>getValue和setValue</code>方法，这个时候声明的属性就全权交付给<code>DelegatesTest</code>类中的<code>anInt</code>代理，当<code>anInt</code>为空的时候返回<code>0</code>，否则返回<code>anInt</code>.</p></blockquote><h4 id="7-JavaBean"><a href="#7-JavaBean" class="headerlink" title="7. JavaBean"></a>7. JavaBean</h4><p>使用<code>data</code>修饰类，类似<code>java</code>中的<code>javaBean</code>,默认实现了<code>set get toString</code>等方法，并拥有<code>componentN</code>方法.</p><p>不过有个缺点就是，无法被继承，没有无参构造函数，可以通过安装<code>allOpen</code>和<code>noArg</code>插件解决这个问题.</p><pre><code>data class UserBean(var name: String, var age: Int)val userBean: UserBean = UserBean(&quot;小芳&quot;, 23)println(userBean.name)println(userBean.toString())println(userBean.component1())println(userBean.component2())val (name, age) = userBeanprintln(&quot;name: $name&quot;)println(&quot;age: $age&quot;)</code></pre><blockquote><p>至于这种写法<code>val (name, age) = userBean</code>，是因为定义了<code>component1</code>的运算符</p></blockquote><pre><code>class Complex{    operator fun component1() = &quot;你好呀&quot;    operator fun component2() = 2    operator fun component3() = &apos;a&apos;}val complex = Complex()val (a, b, c) = complexprintln(a + b + c)</code></pre><p>使用起来也是很简单的</p><h4 id="8-内部类"><a href="#8-内部类" class="headerlink" title="8. 内部类"></a>8. 内部类</h4><ul><li>定义在类内部的类</li><li>与类成员有相似的访问控制</li><li>默认是静态内部类，非静态用 <code>inner</code> 关键字</li><li><code>this@Outter</code> <code>this@Inner</code> 的用法</li><li>匿名内部类<ul><li>没有定义名字的内部类</li><li>类名编译时生成，类似<code>Outter$1.class</code></li><li>可继承父类，实现多个接口，与<code>Java</code>注意区别</li></ul></li></ul><p>举个例子：</p><pre><code>class Outer{    var string: String = &quot;outer&quot;    class Inner1{        var string: String = &quot;inner1&quot;        fun sum(first: Int, second: Int) = first + second    }    inner class Inner2{        var string: String = &quot;inner2&quot;        fun cha(first: Int, second: Int) = first - second        fun getInnerField() = this.string        fun getOuterField() = this@Outer.string    }}fun main(args: Array&lt;String&gt;) {    val inner1 = Outer.Inner1()    val inner2 = Outer().Inner2()    println(inner1.sum(1, 2))    println(inner2.cha(2, 1))    println(inner2.getInnerField())    println(inner2.getOuterField())}</code></pre><p><strong>匿名内部类:</strong></p><pre><code>val listener: onClickListener = object : Father(), Mother, onClickListener{    override fun sing() {        println(&quot;mother sing&quot;)    }    override fun teach() {        println(&quot;father teach&quot;)    }    override fun onClick() {        println(&quot;匿名内部类&quot;)    }}</code></pre><blockquote><p>使用<code>Object</code>实现匿名内部类</p></blockquote><h4 id="9-枚举和密封类"><a href="#9-枚举和密封类" class="headerlink" title="9. 枚举和密封类"></a>9. 枚举和密封类</h4><p>枚举是对象可数，每个状态相当于每个对象，是可以传构造参数的</p><p>密封类时子类可数，在<code>kotlin</code>大于1.1子类只需要与密封类在同一个文件加，保护子类的位置</p><pre><code>sealed class SealedClassTest{    class sum(first: Int, seocnd: Int): SealedClassTest()    class cha(first: Int, seocnd: Int): SealedClassTest()    object Bean: SealedClassTest()}enum class HttpStatus(val anInt: Int){    SUCCESS(0), FAILED(1), LOADING(2)}fun main(args: Array&lt;String&gt;) {    val class1 = SealedClassTest.cha(1, 2)    println(HttpStatus.SUCCESS)}</code></pre><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul><li>传入或者返回函数的函数</li><li>函数引用 <code>::println</code></li><li>带有<code>Receiver</code>的引用 <code>pdfPrinter::println</code></li></ul><p>有三种显示</p><pre><code>// 1. 包级函数intArray.forEach(::print)// 2. 类.方法intArray.forEach(Int::addOne)fun Int.addOne(): Unit {    println(&quot;addOne:$this&quot;)}// 3. 对象.方法intArray.forEach(AddTwo()::addTwo)class AddTwo {    fun addTwo(anInt: Int): Unit {        println(&quot;addTwo:$anInt&quot;)    }}</code></pre><h4 id="2-常用的高阶函数"><a href="#2-常用的高阶函数" class="headerlink" title="2. 常用的高阶函数"></a>2. 常用的高阶函数</h4><p>常用的高阶函数还是有很多的，会简单的使用例子即可：</p><pre><code>// 遍历fun forEachTest() {    val strings: Array&lt;String&gt; = arrayOf(&quot;aa&quot;, &quot;ee&quot;, &quot;bb&quot;, &quot;ll&quot;)    strings.forEach { println(it) } // 遍历每一个值    strings.forEachIndexed { index, s -&gt; println(&quot;index:$index,String:$s&quot;) } // 遍历 下标和值一一对应}// 重新拷贝一个值fun mapTest() {    val strings: Array&lt;String&gt; = arrayOf(&quot;aa&quot;, &quot;ee&quot;, &quot;bb&quot;, &quot;ll&quot;)    var map = strings.map { &quot;$it-test&quot; }    map.forEach { print(&quot;$it\t&quot;) }}// 将集合合体fun flatMapTest() {    val lists = listOf(1..10,            2..11,            3..12)    var flatMap = lists.flatMap {        it.map {            &quot;No.$it&quot;        }    }    flatMap.forEach(::println)}fun reduceTest() {    val ints = listOf(2, 3, 4, 5)    println(ints.reduce { acc, i -&gt;        acc + i    })}// 字符串连接fun foldTest(){    val ints = listOf(2, 3, 4, 5)    println(ints.fold(StringBuffer(), { acc, i -&gt; acc.append(&quot;$i,&quot;) }))    println(ints.joinToString(&quot;,&quot;))}fun filterTest() {    val ints = listOf(1, 2, 3, 4, 5, 6)    println(ints.filter { element -&gt; element % 2 == 0 })}// 当值不是奇数就去，遇到偶数就停止了fun takeWhileTest() {    val ints = listOf(1, 3, 3, 4, 5, 6)    println(ints.takeWhile { it % 2 != 0 })}fun letTest() {    findPerson()?.let { (name, age) -&gt; println(&quot;name:$name, age:$age&quot;) }    findPerson()?.apply { println(&quot;name:$name, age:$age&quot;) }    with(findPerson()!!) { println(&quot;name:$name, age:$age&quot;) }}data class Person(val name: String, val age: Int)fun findPerson(): Person? {    return Person(&quot;aa&quot;, 23)}</code></pre><h4 id="3-复合函数"><a href="#3-复合函数" class="headerlink" title="3. 复合函数"></a>3. 复合函数</h4><p>有点类似数据中的<code>f(g(x))</code></p><pre><code>fun main(args: Array&lt;String&gt;) {    val add1 = {int: Int -&gt;        println(&quot;add1&quot;)        int + 1}    val add2 = {int : Int -&gt;        println(&quot;add2&quot;)        int + 2}    var add3 = add1 addThen (add2)    println(add3(4))}infix fun &lt;P1, P2, R&gt; Function1&lt;P1, P2&gt;.addThen(function: Function1&lt;P2, R&gt;): Function1&lt;P1, R&gt; {    return fun(p: P1): R{        return function.invoke(this.invoke(p))    }}</code></pre><h4 id="4-Currying"><a href="#4-Currying" class="headerlink" title="4. Currying"></a>4. Currying</h4><p>简单来说就是多元函数变换成一元函数调用链式，举个简单的例子，这是优化之前：</p><pre><code>fun log(tag: String, out: OutputStream, message: String){    out.write(&quot;[$tag], $message&quot;.toByteArray())}</code></pre><p>优化之后</p><pre><code>fun log(tag: String)    = fun(out: OutputStream)    = fun(message: String)    = out.write(&quot;[$tag], $message&quot;.toByteArray())</code></pre><h4 id="5-计算文件字符串个数的小例子"><a href="#5-计算文件字符串个数的小例子" class="headerlink" title="5. 计算文件字符串个数的小例子"></a>5. 计算文件字符串个数的小例子</h4><p>首先将字符串转换成字符串数组：</p><pre><code>val map: HashMap&lt;Char, Int&gt; = HashMap()var toCharArray = File(&quot;build.gradle&quot;).readText().toCharArray()</code></pre><p>通过分组的方式，统计每个字符串的个数，并打印：</p><pre><code>toCharArray.groupBy { it }.map { it.key to  it.value.size }.forEach { println(it) }</code></pre><h2 id="kotlin和java的混合开发"><a href="#kotlin和java的混合开发" class="headerlink" title="kotlin和java的混合开发"></a><code>kotlin</code>和<code>java</code>的混合开发</h2><h4 id="1-基本的交互操作"><a href="#1-基本的交互操作" class="headerlink" title="1. 基本的交互操作"></a>1. 基本的交互操作</h4><p><strong>属性读写</strong></p><ul><li><code>Kotlin</code>自动识别 <code>Java Getter/Setter</code></li><li><code>Java</code>操作<code>Kotlin</code>属性通过<code>Getter/Setter</code></li></ul><p><strong>空安全类型</strong></p><ul><li><code>Kotlin</code>空安全类型的原理</li><li>平台类型<code>Platform Type</code></li><li><code>Java</code>可以通过<code>@Nullable、@NotNull</code></li></ul><p><strong>几类函数的调用</strong></p><ul><li>包级函数：静态方法</li><li>扩展方法：带<code>Receiver</code>的静态方法</li><li>运算符重载：带<code>Receiver</code>的对应名称的静态方法</li></ul><p><strong>几个常用的注解</strong></p><ul><li><code>@JvmField</code>：将属性编译为<code>Java变量</code></li><li><code>@JvmStatic</code>：将对象的方法编译成功<code>Java</code>静态方法</li><li><code>@JvmOverloads</code>：默认参数生成重载方法</li><li><code>@JvmName</code>：制定<code>Kotlin</code>文件编译后的类名</li></ul><p><strong>NoArg 和 AllOpen</strong></p><ul><li><code>NoArg</code>为被标注的类生成无参构造</li><li><code>AllOpen</code>为被标注的类去掉<code>final</code>，允许被继承</li></ul><p><strong>正则表达式</strong></p><ul><li>用<code>Raw</code>字符串定义正则表达式</li><li><code>Java</code>的<code>Pattern</code></li><li><code>Kotlin</code>的<code>Regex</code></li></ul><p>举个例子：</p><pre><code>val source = &quot;Hello This my phone number: 010-12345678.&quot;val pattern = &quot;&quot;&quot;.*(\d{3}-\d{8}).*&quot;&quot;&quot;Regex(pattern).findAll(source).toList().flatMap(MatchResult::groupValues).forEach(::print)</code></pre>]]></content>
      
      <categories>
          
          <category> 自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVVM之DataBinding入门</title>
      <link href="/article/41851/"/>
      <content type="html"><![CDATA[<h1 id="MVVM介绍"><a href="#MVVM介绍" class="headerlink" title="MVVM介绍"></a>MVVM介绍</h1><blockquote><p>本篇这是基础入门篇，要想看源码剖析请移步到 <a href="http://www.jianshu.com/p/c4f5411cb0ae" target="_blank" rel="noopener">DataBinding实现原理探析</a></p></blockquote><a id="more"></a><p><code>MVVM</code>框架类似于早期的<code>MVC</code>和最热的<code>MVP</code>，但是比起这两个更为强势。<code>MV-VM</code>相比于<code>MVP</code>，其实就是将<code>Presenter</code>层替换成了<code>ViewModel</code>层，我们都知道，<code>MVP</code>的好处就是将逻辑代码从<code>View</code>层抽离出来，做到与UI层的低耦合，但是无形中会创造出许多的接口，有些接口很是冗余，不仅如此，当后期修改数据或者添加新的功能还需要修改或是添加接口，很是麻烦。</p><p>这个时候<code>MV-VM</code>的优势就体现出来了，<code>ViewModel</code>层所需要做的完全就是跟逻辑相关的代码，完全不会涉及到UI。当数据变化，直接驱动UI的改变，中间省去了冗余的接口。同时，在<code>ViewModel</code>层编写代码中，要求开发者需要将每个方法尽可能的做的功能单一，不与外部有任何的引用或者是联系，无形中提高了代码的健壮性，方便了后期的单元测试。</p><p><code>DataBinding</code>其实就是谷歌出台的工具，是实现UI和数据绑定的框架，<code>View</code>和<code>ViewModel</code>通过<code>DataBinding</code>实现单向绑定或双向绑定，做到UI和数据的相互监听，同时开发者的任务分配也就很明确了，负责<code>ViewModel</code>的小伙伴完全不用考虑UI如何实现，很大程度上提高了代码的开发效率和后期出问题跟踪的准确性，针对这些好处，采用<code>MVVM</code>进行代码开发还是非常有必要的。</p><h1 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h1><h2 id="1-module的build-gradle文件加上一行配置代码"><a href="#1-module的build-gradle文件加上一行配置代码" class="headerlink" title="1. module的build.gradle文件加上一行配置代码"></a>1. <code>module</code>的<code>build.gradle</code>文件加上一行配置代码</h2><pre><code>android {    ...    dataBinding {        enabled = true    }}</code></pre><h2 id="2-创建布局文件"><a href="#2-创建布局文件" class="headerlink" title="2. 创建布局文件"></a>2. 创建布局文件</h2><p>只需要在之前布局的基础上，外层嵌套 <code>&lt;layout&gt;&lt;/layout&gt;</code>即可。</p><pre><code>&lt;layout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable            name=&quot;student&quot;            type=&quot;com.xiaweizi.bean.Student&quot;/&gt;        &lt;!-- 这里 type 必须传完整路径，或者用 import 方式也是可以的 --&gt;        &lt;!--            &lt;import type=&quot;com.xiaweizi.bean.Student&quot;/&gt;            &lt;variable                name=&quot;student&quot;                type=&quot;Student&quot;/&gt;        --&gt;    &lt;/data&gt;    &lt;!-- 对应之前的XML文件 --&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:gravity=&quot;center_horizontal&quot;        android:orientation=&quot;vertical&quot;&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p>因为<code>XML</code>是不支持自定义导包的，所以通过<code>import</code>先导包，如果类名相同的话可以通过<code>alias</code>进行区分：</p><pre><code>&lt;import type=&quot;android.view.View&quot;/&gt;&lt;import type=&quot;com.xiaweizi.View&quot;        alias=&quot;MyView&quot;/&gt;&lt;variable    name=&quot;view1&quot;    type=&quot;View&quot;/&gt;&lt;variable    name=&quot;view2&quot;    type=&quot;MyView&quot;/&gt;</code></pre><p>这个时候会在<code>app\build\generated\source\debug\包名</code>路径下生成对应的<code>binding</code>类，命名方式，举个例子最为直接：</p><pre><code>原XML名:activity_main  ----&gt; 生成对应的binding名: ActivityMainBinding</code></pre><h2 id="3-Activity中替换原来的setContentView-代码"><a href="#3-Activity中替换原来的setContentView-代码" class="headerlink" title="3. Activity中替换原来的setContentView()代码"></a>3. <code>Activity</code>中替换原来的<code>setContentView()</code>代码</h2><pre><code>ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);</code></pre><h2 id="4-接下来就是关键的ViewModel层"><a href="#4-接下来就是关键的ViewModel层" class="headerlink" title="4. 接下来就是关键的ViewModel层"></a>4. 接下来就是关键的<code>ViewModel</code>层</h2><h4 id="a-单向绑定"><a href="#a-单向绑定" class="headerlink" title="a. 单向绑定"></a>a. 单向绑定</h4><p>咱们先从简单的开始，<code>DataBinding</code>有个很大的好处就是摒弃原生<code>findViewById</code>频繁的遍历视图层和<code>ButterKnife</code>的反射，采用的是数组记录每个<code>view</code></p><pre><code>final Object[] bindings = mapBindings(bindingComponent, root, 8, sIncludes, sViewsWithIds);</code></pre><p>在<code>XML</code>创建一个<code>TextView</code></p><pre><code>&lt;TextView    android:id=&quot;@+id/tv_content&quot;    android:text=&quot;@{student.name}&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;50dp&quot;/&gt;</code></pre><p>在代码中通过<code>binding</code>直接可以获取到这个<code>TextView</code></p><pre><code>mBinding.tvContent</code></pre><p>那么如何实现单向绑定呢？</p><pre><code>Student student = new Student(&quot;xiaweizi&quot;, 12);mBinding.setStudent(student);</code></pre><p>这样就可以直接改变<code>TextView</code>的值。</p><p><code>ViewModel</code>就是简单的数据</p><pre><code>public class Student {    public String name;    public int age;    public Student(String name, int age) {        this.name = name;        this.age = age;    }}</code></pre><h4 id="b-双向绑定"><a href="#b-双向绑定" class="headerlink" title="b. 双向绑定"></a>b. 双向绑定</h4><p>之前说的单向绑定，即当数据变化，通过<code>mBinding.setStudent(student)</code>方式驱动UI的改变<br>而双向绑定，无论<code>View</code>还是<code>ViewModel</code>谁改变，都会驱动另一方的改变，实现双向绑定有两种方式：继承<code>BaseObservable</code>和使用<code>ObservableField</code>创建成员变量。</p><p>代码实现：<br>第一种继承<code>BaseObservable</code>：</p><pre><code>public class Student extends BaseObservable{    // 如果是 public 则在成员变量上方加上 @Bindable 注解    @Bindable    public String sex;    public void setSex(String sex) {        this.sex = sex;        notifyPropertyChanged(BR.sex);    }    /*************************** 我是分割线 ***************************/    // 如果是 private 则在成员变量的 get 方法中添加 @Bindable 注解    private String name;    @Bindable    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;        notifyPropertyChanged(BR.name);    }    public void setSexName(String name, String sex){        this.name = name;        this.sex = sex;        notifyChange();    }}</code></pre><p>这个时候当调用<code>setName()</code>方法,不仅数据改变，UI中的<code>TextView</code>内容也会随之改变。</p><p>我们可以发现有两个方法：<code>notifyPropertyChanged()</code>和<code>notifyChange</code>,一个是更新指定的变量，第二个是更新所有该<code>ViewModel</code>中的对象。</p><p>而<code>notifyPropertyChanged(int fieldId)</code>里面传的参数，即上面通过<code>@Bindable</code>注解创建对应的变量<code>id</code>。</p><p>第二种：使用<code>ObservableField</code></p><pre><code>public class Student extends BaseObservable{    public ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;();    private ObservableInt age = new ObservableInt();    public void setAge(int age) {        this.age.set(age);    }    public int getAge() {        return age.get();    }}</code></pre><p>通过使用<code>ObservableField</code>创建的对象作用相当于第一种的方案，支持<code>ObservableInt</code>、<code>ObservableBoolean</code>或者是<code>ObservableField&lt;T&gt;</code>指定的类型、<code>ObservableArrayMap&lt;String, Object&gt;</code>、<code>ObservableArrayList&lt;Object&gt;</code>等。</p><p><code>ObservableField</code>内部已经封装了<code>get</code>和<code>set</code>方法，如果成员变量是<code>public</code>属性，直接通过</p><pre><code>mStudent.name.set(&quot;shabi&quot;);String name = mStudent.name.get();</code></pre><p>设置和获取对应的成员变量的值。</p><h1 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h1><p>学会了上面基本的用户还是远远不够的，像按钮的点击事件或是<code>EditText</code>内容的监听，这些也是非常重要的，不过学会了一种，其他的举一反三就会容易的多了。</p><h3 id="1-事件处理"><a href="#1-事件处理" class="headerlink" title="1. 事件处理"></a>1. 事件处理</h3><p><code>dataBinding</code>需要你通过一些表达式来处理<code>view</code>的分发事件，除了少数例子外，事件元素的名称是由监听器中的方法所控制。比如<code>View.OnLongClickListener</code>内部有<code>onLongClick()</code>方法，所以<code>XML</code>定义的事件就为<code>android:onLongClick</code>.</p><p>可以直接在<code>Activity</code>内部定义一个类，用于处理事件的监听</p><pre><code>public class Presenter {    public void onClickExample(View view) {        Toast.makeText(SimpleActivity.this, &quot;点到了&quot;, Toast.LENGTH_SHORT).show();    }    public void onTextChanged(CharSequence s, int start, int before, int count) {        mStudent.name.set(s.toString());    }    public void onClickListenerBinding(Student student) {        Toast.makeText(SimpleActivity.this, student.name.get(),Toast.LENGTH_SHORT).show();    }}</code></pre><p><code>XML</code>中:</p><pre><code>&lt;EditText    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:hint=&quot;输入name&quot;    android:onTextChanged=&quot;@{presenter::onTextChanged}&quot;/&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:onClick=&quot;@{presenter.onClickExample}&quot;    android:text=&apos;@{&quot;年龄：&quot; + student.age}&apos;/&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_marginLeft=&quot;5dp&quot;    android:onClick=&quot;@{() -&gt; presenter.onClickListenerBinding(student)}&quot;    android:text=&apos;@{&quot;姓名：&quot; + student.name}&apos;/&gt;</code></pre><p>首先从点击事件开始分析，<code>android:onClick=&quot;@{presenter.onClickExample}&quot;</code> 里面对应的方法自然是要与<code>Presenter</code>定义的方法名一致，名字可以不为<code>onClickExample</code>，但是参数必须是<code>View</code>，参数要对应于<code>setOnClickListener(onClickListener listener)</code>对应的<code>onClickListener</code>要实现的接口，即<code>public void onClick(View)</code>。</p><p>同理，监听<code>EditText</code>文本的变化，一般只要注意<code>onTextChanged(CharSequence s, int start, int before, int count)</code>方法即可，那么我们可以创建与之对应的方法，在<code>XML</code>文件中引用：<code>android:onTextChanged=&quot;@{presenter::onTextChanged}&quot;</code>。</p><p>最后再来看从UI中获取数据，也就是数据的回调，即<code>DataBinding</code>的精髓支出，<code>View</code>和<code>ViewModel</code>双向绑定。<code>android:onClick=&quot;@{() -&gt; presenter.onClickListenerBinding(student)}</code>这里用到了<code>lamda</code>表达式，这样就可以不遵循默认的方法签名，将<code>student</code>对象直接传回点击方法中。来看一下实现效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-6355339021fd68cb.gif?imageMogr2/auto-orient/strip" alt="简单测试.gif"></p><p>一目了然，我就不赘述了，我们可以发现一点，一开始我们并没有给<code>Student</code>对象设置值，所以显示的是<code>null</code>，并没有报空指针异常，这也是<code>DataBinding</code>的有点之一。</p><p>其实<code>dataBinding</code>自带对数据监听的方法：</p><pre><code>&lt;EditText    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;@={student.name}&quot;/&gt;</code></pre><p>代码中：</p><pre><code>student.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {        @Override        public void onPropertyChanged(Observable observable, int i) {            // i 为 BR 文件中对应的 int 值            Log.i(&quot;xwz---&gt;&quot;, student.getName());            Log.i(&quot;xwz---&gt;&quot;, student.getAge());        }});</code></pre><p>这个对数据的监听建立在，使用<code>@Bindable</code>作为双向绑定为条件，当数据变化，便会出发<code>onPropertyChanged</code>方法。需要注意的是<code>android:text=&quot;@={student.name}&quot;</code>，@后面多了一个<code>=</code>。</p><h3 id="2-ViewStub和include"><a href="#2-ViewStub和include" class="headerlink" title="2. ViewStub和include"></a>2. <code>ViewStub</code>和<code>include</code></h3><p><code>dataBinding</code>同样是支持<code>ViewStub</code>的，使用起来也很简单，直接贴代码了。</p><pre><code>&lt;ViewStub    android:id=&quot;@+id/view_stub&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout=&quot;@layout/viewstub&quot;/&gt;</code></pre><p>代码中：</p><pre><code>View inflate = binding.viewStub.getViewStub().inflate();</code></pre><p><code>inflate</code>即为替代<code>ViewStub</code>的<code>View</code>.</p><p>至于<code>include</code>更简单，用法跟以前是差不多，唯一不同的是可以将<code>ViewModel</code>传到下一个<code>XML</code>中：</p><pre><code>&lt;include layout=&quot;@layout/layout_include&quot; bind:student=&quot;@{student}&quot;/&gt;</code></pre><p><code>layout_include</code>中同样可以共享<code>student</code>这个对象。</p><h3 id="3-BindingAdapter的使用"><a href="#3-BindingAdapter的使用" class="headerlink" title="3. BindingAdapter的使用"></a>3. <code>BindingAdapter</code>的使用</h3><p>我们之前用的都是<code>Android</code>自带的监听或是属性，比如<code>text</code>、<code>onClick</code>，但是如果项目中需要动态改变<code>ImageView</code>的内容，那我们应该怎么办呢？<code>dataBinding</code>给我们提供了<code>BindingAdapter</code>这个注解，方便我们定义自定义的属性。<br>假如我们有个需求，点击按钮更换图片，这个时候我们需要定义静态的方法：</p><pre><code>@BindingAdapter({&quot;url&quot;, &quot;name&quot;})public static void loadImageView(ImageView view, String url, String name) {    Log.i(&quot;xwz---&gt;&quot;, url + &quot;\t&quot; + name);    Glide.with(view.getContext())         .load(url)         .into(view);}</code></pre><p>在<code>XML</code>中使用</p><pre><code>&lt;ImageView    android:layout_width=&quot;160dp&quot;    android:layout_height=&quot;160dp&quot;    bind:name=&quot;@{student.name}&quot;    bind:url=&quot;@{student.imgUrl}&quot;/&gt;</code></pre><p>这里有必要解释一下，静态方法<code>loadImageView</code>里第一个参数为作用的<code>View</code>，这里是<code>ImageView</code>;后面的参数即分别对应于<code>@BindingAdapter</code>里面的参数。那这里是怎么跟<code>View</code>联系在一块呢？我们发现<code>XML</code>中有这样一行代码<code>bind:name=&quot;@{student.name}</code>这里的<code>name</code>对应的的<code>@BindingAdapter</code>注解里的参数<code>name</code>，并映射于<code>ViewModel</code>中的<code>student.name</code>。当<code>student.name</code>值改变，就会触发<code>loadImageView</code>方法，从而执行里面的方法。</p><p><code>bind</code>名称是任意的定义的，不过要定义对应的命名空间<code>xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</code>。</p><p>实现的效果就很简单了：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-4f03698849422487.gif?imageMogr2/auto-orient/strip" alt="bindAdapter.gif"></p><p>更强大的在于可以覆盖<code>Android</code>原生的元素设置属性，比如<code>android:text</code>最常见不过了</p><pre><code>@BindingAdapter (&quot;android:text&quot;)public static void setText(TextView view, String text) {    view.setText(text + &quot;xiaweizi&quot;);    Log.i(&quot;xwz---&gt;&quot;, text);}</code></pre><p>XML：</p><pre><code>&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&apos;@{&quot;测试&quot;}&apos;/&gt;</code></pre><p>这个时候所有设置<code>text</code>的地方后缀全部加上了<code>xiaweizi</code>.</p><h3 id="4-BindingConversion"><a href="#4-BindingConversion" class="headerlink" title="4. @BindingConversion"></a>4. <code>@BindingConversion</code></h3><p><code>dataBinding</code>还支持对数据的转换，或者是类型的转换</p><pre><code>@BindingConversionpublic static String addString(String text){    Log.i(&quot;xwz---&gt;&quot;, &quot;DemoBindingAdapter:  &quot; + &quot;addString: &quot; + text);    return text + &quot;xiaweizi&quot;;}</code></pre><p>这个时候会将项目中所有以<code>@{String}</code>方式用到的<code>String</code>后缀全部加上<code>xiaweizi</code>.</p><pre><code>@BindingConversionpublic static ColorDrawable convertColorToDrawable(int color){   return new ColorDrawable(color);}</code></pre><p><code>XML</code>:</p><pre><code>&lt;View   android:background=&quot;@{isError ? @color/red : @color/white}&quot;   android:layout_width=&quot;wrap_content&quot;   android:layout_height=&quot;wrap_content&quot;/&gt;</code></pre><p>这段代码的作用在于将<code>int</code>类型的<code>color</code>值，转换成了<code>ColorDrawable</code>类型.</p><h3 id="5-DataBindingComponent"><a href="#5-DataBindingComponent" class="headerlink" title="5. DataBindingComponent"></a>5. DataBindingComponent</h3><p>通过<code>BindingAdapter</code>是可以增加一些自定义的属性或者是修改<code>Android</code>原生的属性，但是它有一个弊端，就是全局修改所有的相关属性，不过配合上<code>DataBindingComponent</code>就可以解决这个问题。</p><pre><code>DataBindingUtil.setContentView(this, R.layout.activity_component, new FirstComponent());</code></pre><p>开始的是以一个参数的形式传入这个<code>View</code>中，那么只作用于当前的view。</p><pre><code>DataBindingUtil.setDefaultComponent(new FirstComponent());</code></pre><p>或者是这种设置全局的方式，也可以改变。</p><p><code>DataBindingComponent</code>其实是一个空方法的接口，你需要先创建一个拥有<code>@BindingAdapter</code>的类，这里就不能定义为<code>public</code>，因为这样<code>DataBindingComponent</code>就找不到对应的类，我们为了方便后期的开发，可以定义一个抽象类：</p><pre><code>public abstract class AbstractAdapter {    @BindingAdapter (&quot;text&quot;)    public abstract void setText(TextView textView, String text);}</code></pre><p>然后定义一个实现类：</p><pre><code>public class FirstAdapter extends AbstractAdapter{    @Override    public void setText(TextView textView, String text) {        Log.i(&quot;xwz---&gt;&quot;, &quot;FirstAdapter:  &quot; + &quot;setText: &quot;);        textView.setText(text+&quot;first&quot;);    }}</code></pre><p>这个时候当你创建一个实现<code>DataBindingComponent</code>接口的类时，会发现让你实现一个方法：</p><pre><code>public class FirstComponent implements android.databinding.DataBindingComponent {    @Override    public AbstractAdapter getAbstractAdapter() {        return new FirstAdapter();    }}</code></pre><p>这里返回的就是创建的<code>adapter</code>，可以根据需求创建对应的<code>component</code>.</p><h1 id="RecyclerView中的应用"><a href="#RecyclerView中的应用" class="headerlink" title="RecyclerView中的应用"></a>RecyclerView中的应用</h1><p>除了最基本的使用，还有一个频繁出现的就是列表了，那么我们这里就拿<code>RecyclerView</code>作为代表进行演示。</p><p><code>RecyclerView</code>的好处就不多说了，已经完全代替了之前的<code>ListView</code>和<code>GridView</code>，用法也就不赘述了，这里主要介绍一下适配器的编写。虽然网上有很多大神已经帮我们创建了各种通用的<code>adapter</code>，不过作为入门，我们还是要学习一下使用<code>dataBinding</code>创建<code>adapter</code>.</p><p>先来个简单的<code>XML</code>文件：</p><pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;import type=&quot;com.github.markzhai.sample.Person&quot;/&gt;        &lt;variable            name=&quot;person&quot;            type=&quot;Person&quot;/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;TextView            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:textSize=&quot;24sp&quot;            android:padding=&quot;5dp&quot;            android:textColor=&quot;#f0f&quot;            android:text=&apos;@{&quot;姓名：&quot; + person.name, default=&quot;aaa&quot;}&apos;/&gt;        &lt;TextView            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:textSize=&quot;15sp&quot;            android:padding=&quot;2dp&quot;            android:textColor=&quot;#090&quot;            android:gravity=&quot;right&quot;            android:layout_marginRight=&quot;80dp&quot;            android:text=&apos;@{&quot;年龄：&quot; + person.age, default=12}&apos;/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p>至于<code>ViewModel</code>就是一个简单的<code>Person</code>类，拥有<code>name</code>和<code>age</code>两个属性，接下来就是<code>adapte</code>的编写。</p><pre><code>public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; {    private List&lt;Person&gt; mList;        public MyAdapter() {        mList = new ArrayList&lt;&gt;();    }    public void setData(List&lt;Person&gt; persons) {        this.mList = persons;    }    @Override    public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {        ItemRecyclerBinding itemBinding =                     DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()),                                                                  R.layout.item_recycler,                                                                  parent,                                                                  false);        return new ViewHolder(itemBinding);    }    @Override    public void onBindViewHolder(MyAdapter.ViewHolder holder, int position) {        holder.bind(mList.get(position));    }    @Override    public int getItemCount() {        return mList.size();    }    public static class ViewHolder extends RecyclerView.ViewHolder {        final ItemRecyclerBinding itemBinding;        public ViewHolder(ItemRecyclerBinding binding) {            super(binding.getRoot());            this.itemBinding = binding;        }        void bind(Person person) {            itemBinding.setPerson(person);        }    }}</code></pre><p>通过<code>DataBindingUtil.inflate()</code>创建<code>item</code>布局，在<code>ViewHolder</code>中进行数据的绑定，这个时候，当数据源变化的时候，<code>RecyclerView</code>中的数据也跟着变化。</p><p>至于<code>item</code>的点击事件可以上面的<code>onClick</code>写法：</p><p>创建<code>Presenter</code>处理点击事件：</p><pre><code>public static class Presenter{    ItemRecyclerBinding mBinding;    public Presenter(ItemRecyclerBinding binding){        this.mBinding = binding;    }    public void onItemClick(Person person){        Log.i(&quot;xwz---&gt;&quot;, &quot;name: &quot; + person.getName() + &quot;\tage: &quot; + person.getAge());        Toast.makeText(mBinding.getRoot().getContext(), &quot;name: &quot; + person.getName() + &quot;\tage: &quot; + person.getAge(), Toast.LENGTH_SHORT).show();    }}</code></pre><p>在之前的<code>bind</code>方法中进行绑定：</p><pre><code>void bind(Person person) {    itemBinding.setPerson(person);    itemBinding.setPresenter(new Presenter(itemBinding));}</code></pre><p>在<code>XML</code>中设置点击事件即可：</p><pre><code>&lt;LinearLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:onClick=&quot;@{() -&gt; presenter.onItemClick(person)}&quot;    android:orientation=&quot;vertical&quot;&gt;...&lt;/LinearLayout&gt;</code></pre><p>这里就可以直接将数据直接回传。</p><p>看一下运行效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-50a7029e02b7693b.gif?imageMogr2/auto-orient/strip" alt="RecyclerView的使用.gif"></p><h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><h3 id="databinding支持一些java的表达式"><a href="#databinding支持一些java的表达式" class="headerlink" title="databinding支持一些java的表达式"></a><code>databinding</code>支持一些<code>java</code>的表达式</h3><ul><li><code>+ - * / %</code></li><li>字符串的连接<code>&quot;a&quot;+&quot;b&quot;</code></li><li>逻辑和位运算<code>&amp;&amp; || &amp; |</code></li><li>一元运算<code>+ - ! ~</code></li><li>移位 <code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li><li>比较 <code>== &gt; &lt; &gt;= &lt;=</code></li><li><code>instance of</code></li><li>支持数据类型:<code>character,String,numeric,null</code></li><li>强转<code>cast</code></li><li>方法的调用</li><li>成员变量的访问</li><li>数组访问</li><li>三元表达式<code>? :</code></li></ul><p>简单例子：</p><pre><code>android:text=&quot;@{String.valueOf(index + 1)}&quot;android:visibility=&quot;@{age &lt; 13 ? View.GONE : View.VISIBLE}&quot;android:transitionName=&apos;@{&quot;image_&quot; + id}&apos;</code></pre><h3 id="dataBinding不支持的Java特性"><a href="#dataBinding不支持的Java特性" class="headerlink" title="dataBinding不支持的Java特性"></a><code>dataBinding</code>不支持的<code>Java</code>特性</h3><ul><li><code>this</code></li><li>super</li><li>new</li><li>泛型</li></ul><h3 id="dataBinding判空处理"><a href="#dataBinding判空处理" class="headerlink" title="dataBinding判空处理"></a><code>dataBinding</code>判空处理</h3><p>使用<code>??</code>来进行判空操作</p><pre><code>android:text=&quot;@{user.displayName ?? user.lastName}&quot;</code></pre><p>如果不为空则选择左侧值，否则选择右侧值，类似于：</p><pre><code>android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot;</code></pre><h3 id="支持数组，集合，map"><a href="#支持数组，集合，map" class="headerlink" title="支持数组，集合，map"></a>支持数组，集合，<code>map</code></h3><pre><code>&lt;data&gt;    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;    &lt;import type=&quot;java.util.Map&quot;/&gt;    &lt;import type=&quot;java.util.List&quot;/&gt;    &lt;variable name=&quot;list&quot; type=&quot;List&lt;String&gt;&quot;/&gt;    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&lt;String&gt;&quot;/&gt;    &lt;variable name=&quot;map&quot; type=&quot;Map&lt;String, String&gt;&quot;/&gt;    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;&lt;/data&gt;…android:text=&quot;@{list[index]}&quot;…android:text=&quot;@{sparse[index]}&quot;…android:text=&quot;@{map[key]}&quot;</code></pre><h3 id="资源的访问"><a href="#资源的访问" class="headerlink" title="资源的访问"></a>资源的访问</h3><p><code>dataBinding</code>支持一般语法对资源的访问：</p><pre><code>android:padding=&quot;@{large? @dimen/largePadding : @dimen/smallPadding}&quot;</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>dataBinding</code>主要的作用就在于减少<code>Activity</code>和<code>Fragment</code>层的代码,不再使用<code>findViewById</code>，让<code>XML</code>从之前只用于显示视图，到现在可以做一些操作。在性能上更是有很大的提高，内部采用0反射，使用位标记检测需要更新的<code>view</code>，每次数据的改变是在下一帧开始改变等等。</p><p>当然也有一些不足之处，<code>Android Studio</code>的<code>IDE</code>支持还不是那么完善，在<code>XML</code>中一些方法不能智能生成和跳转，还有就是报错的错误信息，有的时候并不能定位到准确的位置。不过总体上来说<code>dataBinding</code>带来的好处远远的超过这些不足，所以还没有尝试的小伙伴，不妨试一试，相信你会爱上他的。</p><blockquote><p>感谢<a href="http://www.imooc.com/search/?words=databinding" target="_blank" rel="noopener">dataBinding视频</a><br><a href="http://blog.zhaiyifan.cn/" target="_blank" rel="noopener">markzhai</a><br><a href="https://developer.android.google.cn/topic/libraries/data-binding/index.html" target="_blank" rel="noopener">官方地址</a></p></blockquote><p><a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVVM </tag>
            
            <tag> DataBinding </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『自定义View实战』—— 实现图片的圆角效果</title>
      <link href="/article/35908/"/>
      <content type="html"><![CDATA[<blockquote><p>在工作中难免遇到自定义 <code>View</code> 的相关需求，本身这方面比较薄弱，因此做个记录，也是自己学习和成长的积累。<a href="https://link.jianshu.com/?t=http%3A%2F%2Fxiaweizi.cn%2Fcategories%2F%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589View%25E5%25AE%259E%25E6%2588%2598%2F" target="_blank" rel="noopener">自定义View实战</a></p></blockquote><p>上周接到个小需求，就是让一张图片的右下角为圆角，然后百度了一下，发现 <code>Glide</code> 直接支持对图片进行操作，只要继承 <code>BitmapTransformation</code>,或者实现 <code>Transformation</code>的接口，就可以获得原图的 <code>Bitmap</code>对象，通过 <code>Canvas</code>对图片重新绘制，最后 <code>Glide.with(this).load(R.drawable.test).asBitmap().transform(transformation).into(mImageView);</code>传入新建的<code>transformation</code>对象即可。</p><a id="more"></a><p>这里推荐<code>GitHub</code>上的一个开源库，完全满足日常需求:<a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="noopener">glide-transformations</a>,里面有各种各样的对图片的处理，很是强大。</p><p>不过实际使用的过程中，我倒是发现一个小问题…假如只有右下角是圆角的情况下，当服务器返回的是一张半透明的图片时，结果就成了这样:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-36eb01d918e79ca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终结果"></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-0335ab7c9965900c.gif?imageMogr2/auto-orient/strip" alt=""></p><p>原图其实是一张半透明矩形图，这就很尴尬，其实从图中不难发现作者的绘制思路，首先看一下作者的源码部分：</p><pre><code>canvas.drawRoundRect(new RectF(right - mDiameter, bottom - mDiameter, right, bottom), mRadius,mRadius, paint);canvas.drawRect(new RectF(mMargin, mMargin, right - mRadius, bottom), paint);canvas.drawRect(new RectF(right - mRadius, mMargin, right, bottom - mRadius), paint);</code></pre><p>并附上本人的草图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-7baad3b9b576f3e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作者的.png"></p><ul><li>第一步，绘制一个圆1</li><li>第二步绘制剩下的两个矩形2和3.</li></ul><p>这样给人的感觉，右下角就有了圆角效果，举一反三，其他的四个角也是这样绘制。不过这样有个缺点，作者这样虽然可以实现，但是会有重叠的部分，假如跟我一样是半透明的图片，那么出来的效果就很差强人意。</p><p>于是，我换个方法，有点大同小异，只是稍微做了点优化，如下图:</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9422183b9fae1da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本人的.png"></p><p>一目了然，其实我就是将作者的圆换成了弧，这样，半透明的图片就可以完美的拥有了圆角。既然这样，那么就重新写一个实现圆角的lib吧，其实很简单，这是运行过后的效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-8c2be5bd03d7a674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result.png"></p><p>很可爱吧！</p><p>附上 <code>GitHub</code>的项目地址：</p><div class="github-widget" data-repo="xiaweizi/RoundCornersView"></div><h4 id="使用起来就很简单了："><a href="#使用起来就很简单了：" class="headerlink" title="使用起来就很简单了："></a>使用起来就很简单了：</h4><ol><li><p>在你的项目根 <code>build.gradle</code> 文件下添加 <code>maven</code>地址</p><pre><code> allprojects {  repositories {    ...    maven { url &apos;https://jitpack.io&apos; }  }}</code></pre></li><li><p>在<code>module</code>对应的<code>build.gradle</code>下添加依赖</p><pre><code>dependencies {    compile &apos;com.github.xiaweizi:RoundCornersView:v1.0&apos;}</code></pre></li><li><p>在代码中使用(需要结合<code>Glide</code>搭配使用)</p><pre><code>RoundCornersTransformation transformation =        new RoundCornersTransformation(MainActivity.this,                                       dip2px(25),                                       mList.get(position).type);Glide.with(MainActivity.this)     .load(mList.get(position).resId)     .bitmapTransform(transformation)     .into(holder.mImageView);</code></pre></li></ol><p>创建<code>transformation</code>对象需传入圆角半径和指定圆角的位置,有以下几种可供选择，当然如果你有别的需要，相信您同样可以举一反三实现的。</p><pre><code>public enum CornerType {    /** 所有角 */    ALL,    /** 左上 */    LEFT_TOP,    /** 左下 */    LEFT_BOTTOM,    /** 右上 */    RIGHT_TOP,    /** 右下 */    RIGHT_BOTTOM,    /** 左侧 */    LEFT,    /** 右侧 */    RIGHT,    /** 下侧 */    BOTTOM,    /** 上侧 */    TOP,}</code></pre><p><a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 自定义View实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作积累 </tag>
            
            <tag> 自定义 View </tag>
            
            <tag> 第三方库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-性能优化小结</title>
      <link href="/article/9202/"/>
      <content type="html"><![CDATA[<blockquote><p>本周有个需求，对某个界面进行优化，然后看了一些文章，并进行小结，为了方便以后回头查看。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-7c357364ccfb7dbd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><p><em>仅供个人参考</em></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-323934e1385bfad3.gif?imageMogr2/auto-orient/strip" alt="我还可以继续战斗"></p><h3 id="一、界面绘制优化"><a href="#一、界面绘制优化" class="headerlink" title="一、界面绘制优化"></a>一、界面绘制优化</h3><h4 id="1-页面卡顿原因"><a href="#1-页面卡顿原因" class="headerlink" title="1. 页面卡顿原因"></a>1. 页面卡顿原因</h4><ul><li>布局 Layout 过于复杂，无法在16 ms 内完成渲染。</li><li>同一时间动画执行的次数过多，导致 CPU 或 GPU 负载过重</li><li>View 过度绘制，导致某些像素在同一帧时间内被绘制多次</li><li>UI 线程中做了稍微耗时的操作</li></ul><h4 id="2-解决工具"><a href="#2-解决工具" class="headerlink" title="2. 解决工具"></a>2. 解决工具</h4><ul><li>开发者选项-打开GPU渲染</li><li>使用 <code>Systrace</code></li><li>使用 <code>TraceView</code></li><li>使用 <code>Hierarchy Viewer</code> 观察每个 View 的绘制时间</li></ul><h4 id="3-解决策略"><a href="#3-解决策略" class="headerlink" title="3. 解决策略"></a>3. 解决策略</h4><ul><li>如果布局层数比较多的时候，推荐使用 RelativeLayout</li><li>如果布局嵌套比较多，推荐使用 LinearLayout (RelativeLayout 的view的排列方式是基于彼此于彼此依赖)</li><li>使用 include 标签进行布局复用</li><li>使用 merge 标签去除多余层级<ul><li>merge 标签最好是替代 FrameLayout 或者是布局一致的 LinearLayout，比如当前布局的 LinearLayout 是垂直方向的，被包含的布局的 LinearLayout 也是垂直方向的则可以使用 merge 标签。</li></ul></li><li>使用 ViewStub 延迟加载布局提高加载速度<ul><li>ViewStub 只能加载一次，加载后 ViewStub 被置为空 </li><li>ViewStub 不能嵌套 merge 标签</li><li>ViewStub 操作的是布局文件，如果想操作具体的 view，还是要使用 view 的visible 属性</li></ul></li><li>避免过度绘制、重绘<ul><li>移除不需要的 background</li><li>在自定义 view 的 onDraw 方法中，用 canvas.clipRect 来指定绘制的区域，放置重叠的组件发生过度绘制</li></ul></li></ul><h3 id="二、内存泄露"><a href="#二、内存泄露" class="headerlink" title="二、内存泄露"></a>二、内存泄露</h3><h4 id="1-主要原因分类"><a href="#1-主要原因分类" class="headerlink" title="1. 主要原因分类"></a>1. 主要原因分类</h4><ol><li>开发人员自己编写代码造成的内存泄漏</li><li>第三方框架造成的泄漏</li><li>由 Android 系统或者第三方 ROM 造成的内存泄漏</li></ol><h4 id="2-泄露场景"><a href="#2-泄露场景" class="headerlink" title="2. 泄露场景"></a>2. 泄露场景</h4><ul><li>非静态内部类的静态实例<ul><li>如果非静态内部类里面创建的实例是静态的，那么它会间接的长期维持着外部的引用，阻止被系统回收</li></ul></li><li>匿名内部类的静态实例</li><li>Handler 的内存泄露<ul><li>如果 Handler 是非静态的，那么 Handler 也会导致引用它的 Activity、Service or Fragment，导致内存泄露</li></ul></li><li>未正确使用 Context (最常见的就是单例模式)</li><li>静态的 view</li><li>资源对象未关闭(curson file)</li><li>集合中对象未清理</li><li>Bitmap 对象<ul><li>避免静态变量持有比较大的 btimap 对象或者其他大的数据对象，如果已持有，要尽快置空静态变量</li></ul></li><li>监听器未关闭<ul><li>很多系统的服务 TelephonyManager SensorManager 记得取消注册，或者注册 null</li></ul></li></ul><h2 id="三、开发过程中遵循的守则"><a href="#三、开发过程中遵循的守则" class="headerlink" title="三、开发过程中遵循的守则"></a>三、开发过程中遵循的守则</h2><h3 id="1-编程思想"><a href="#1-编程思想" class="headerlink" title="1. 编程思想"></a>1. 编程思想</h3><p>应用层的性能优化通常可以从以下几个方面考虑：</p><ul><li>了解编程语言的编译原理，使用高效编码方式从语法上提高程序性能；</li><li>采用合理的数据结构和算法提高程序性能，这往往是决定程序性能的关键；</li><li>重视界面布局优化；</li><li>采用多线程、缓存数据、延迟加载、提前加载等手段，解决严重的性能瓶颈；</li><li>合理配置虚拟机堆内存使用上限和使用率，减少垃圾回收频率；</li><li>合理使用native代码；</li><li>合理配置数据库缓存类型和优化SQL语句加快读取速度，使用事务加快写入速度；</li><li>使用工具分析性能问题，找出性能瓶颈；</li></ul><h3 id="2-编程技巧"><a href="#2-编程技巧" class="headerlink" title="2. 编程技巧"></a>2. 编程技巧</h3><p><strong>不执行不必要的操作(CPU)、不分配不必要的内存(内存)</strong></p><ul><li>避免创建不必要的对象<ul><li>分配内存本身需要时间，虚拟机运行时堆内存使用量是有上限的，容易出发 GC，使进程暂停，造成严重卡顿。</li></ul></li><li>合理使用 static 成员</li><li>不需要操作运行时的动态变量和方法，那么可以讲方法设置为 static</li><li>常量字段要声明为 static final，因为常量会被放在 dex 文件的静态字段初始化器中被直接访问。否在运行时会通过编译器自动生成一些函数来初始化此规则只对基本类型和 String 类型有效</li><li>避免创建 static 的 view or context，持有 Activity 的引用容易造成内存泄露</li><li>避免内部的 getter 和 setter<ul><li>尽量直接声明为 public，直接访问的速度比间接访问要快7倍</li></ul></li><li>合理使用浮点类型<ul><li>在 Android 设备中，浮点型大概比整形数据处理速度慢两倍</li></ul></li><li>移除 Activity 默认背景，提升 Activity 加载速度<ul><li><code>getWindow().setBackgroundDrawable(null);</code></li></ul></li><li>cursor stream 的关闭</li><li>广播的注册和取消注册</li><li>合理使用 <code>StringBuffer</code> <code>StringBuilder</code> <code>String</code></li><li>尽量使用局部变量</li><li>调用方法时传递的参数已经调用中创建的临时变量都保存在 stack 中，速度较快，其他变量(静态变量、成员变量)都在 heap 中创建，速度较慢</li><li>IntentService 代替 Service</li><li>使用 <code>ApplicationCotext</code> 代替 Activity 的 Context</li><li>集合中的对象及时清理</li><li>记得在 <code>onDestory()</code> 方法中，及时销毁 webView</li></ul>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何做个依赖库让别人依赖使用</title>
      <link href="/article/58454/"/>
      <content type="html"><![CDATA[<p><em><a href="http://xiaweizi.cn">我的博客地址</a></em></p><p>#前言<br>在我们的项目开发中经常会使用别人的第三方依赖库，在之前的 <code>Eclipse</code> 的时代，是通过拷贝 <code>jar</code> 包，引入到工程中去使用，比较麻烦。现如今，大部分 <code>Android</code> 开发者，都开始使用 <code>AndroidStudio</code> 工具进行开发，只需要在 module 下的 <code>build.gradle</code> 文件添加依赖，就可以完成第三方依赖库的引用。</p><a id="more"></a><p>别人的库用多了，就考虑是否自己也可以写个依赖库，让别人使用呢。在此前，我们就要知道如何才能将自己的库上传给别人使用。这里我就介绍一种上传到 <code>JitPack</code> 让别人使用的方式。</p><p>先预览一下运行结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3e6e823547b6c003.gif?imageMogr2/auto-orient/strip" alt="webView整体预览.gif"></p><blockquote><p>这里说明一下，我这个库，很简单，就是一个封装好的 <code>WebViewActivity</code>，当你需要打开一个外部 URL 链接，但是又不想使用系统自带的浏览器，只想在软件内部完成跳转的需求，那么您就可以使用我的这个依赖库了。</p></blockquote><h1 id="1-XWZWebView库-介绍"><a href="#1-XWZWebView库-介绍" class="headerlink" title="1. XWZWebView库 介绍"></a>1. <a href="https://github.com/xiaweizi/XWZWebView" target="_blank" rel="noopener">XWZWebView库</a> 介绍</h1><p>这个我就是参考一篇大神的文章  <a href="http://blog.csdn.net/qq_24530405/article/details/52067474" target="_blank" rel="noopener">WebView详解与简单实现Android与H5互调</a> 里的内容，并添加一点小功能，毕竟这不是本片文章的重点。</p><p>##1. 使用步骤：</p><p>####1. 在项目的 build.gradle 文件中添加</p><pre><code>allprojects {    repositories {        ...        maven { url &apos;https://jitpack.io&apos; }    }}</code></pre><p>####2. 在 module 的 build.gradle 文件中添加依赖</p><pre><code>dependencies {        compile &apos;com.github.xiaweizi:XWZWebView:1.1.0&apos;}</code></pre><p>####3. 一步调用</p><pre><code>WebViewActivity.startUrl(context, url);</code></pre><blockquote><p>第一个参数就是上下文，第二个参数就是跳转的链接 <code>URL</code></p></blockquote><hr><p>##2. 依赖库特点：</p><blockquote><ol><li>支持侧滑结束 WebViewActivity</li><li>支持缩放</li><li>设置缓存</li><li>进度显示</li><li>点击返回键回退到上个浏览记录</li></ol><p>等等…</p></blockquote><p>就一个类，<a href="https://github.com/xiaweizi/XWZWebView/blob/master/webviewlib/src/main/java/com/xiawei/webviewlib/WebViewActivity.java" target="_blank" rel="noopener">点击查看</a></p><p>#2. 上传库，让别人添加依赖使用<br><em>接下里到了重点部分，就是如何上传到 JitPack 上，然后添加依赖使用。</em></p><p>##1. 在 Android studio上创建库</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-509aef87157dcfec.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建lib.PNG"><br><img src="http://upload-images.jianshu.io/upload_images/4043475-7b7b3a272655cc16.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建Library.PNG"></p><blockquote><p>创建 Android Library</p></blockquote><p>##2. 添加代码<br>就像平常那样在里面添加代码，我这里就是一个 <a href="https://github.com/xiaweizi/XWZWebView/blob/master/webviewlib/src/main/java/com/xiawei/webviewlib/WebViewActivity.java" target="_blank" rel="noopener">Activity</a>，还有就是在 这个库的清单文件中添加了获取网络的权限。</p><p>##3. 上传到GitHub</p><blockquote><p>我是先在 <code>GitHub</code> 上创建仓库，然后通过 <code>git</code> 命令将本地仓库和远程仓库进行连接，最后 <code>push</code> 一下</p></blockquote><p>其实有个非常简单迅速的方法：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-d928d213a087b854.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传到GitHub.PNG"></p><blockquote><p>VCS –&gt; Import into Version Control –&gt; Share Project on GitHub</p></blockquote><p>在这之前要确认 在你的 <code>AndroidStudio</code> 中是否配置过 <code>GitHub</code></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-7a043efea84dab1c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置GitHub.PNG"></p><blockquote><p>并通过测试</p></blockquote><p>##4. 在 GitHub 上创建 release</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-259ad05e72d63e0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建 release"></p><p>第一次创建 release：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-d32770e1bed96c7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5M~B}NU0"></p><p>添加新的 release：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-120b1d529d2c2454.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加新的 release"></p><p>填写版本等信息</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-f69b5acfb6c66fea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="填写版本等信息"></p><p>##5. 上传到 <a href="https://jitpack.io/" target="_blank" rel="noopener">JitPack</a> 上</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-54bda69964cca485.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传到 JitPack 上"><br>按照上面步骤就可以完成啦！向着大牛又进了一步。</p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 造轮子 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jsoup爬虫简书首页数据做个小Demo</title>
      <link href="/article/64590/"/>
      <content type="html"><![CDATA[<p><em>昨天LZ去面试，遇到一个大牛，被血虐一番，发现自己基础还是很薄弱，对java一些原理掌握的还是不够稳固，比如java反射注解，知道一点就是说不出来，很尴尬… 生命不止，学习不止啊</em></p><blockquote><p>之前那个项目 QNews 用的是的第三方的数据平台，所以访问次数会有限制，这就很无奈。。。</p></blockquote><a id="more"></a><p><em><a href="http://xiaweizi.cn/">我的博客地址</a></em></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9c19479cc64957ec.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="次数限制.PNG"></p><blockquote><p>每天只能请求100次….但是LZ这个穷屌丝也买不起服务器，所以就上网查，有什么别的方法可以获取数据，意外之间发现了jsoup这个强大的框架，就花了上午时间学习了一下，然后下午做了一个小Demo，功能比较单一，请见谅。</p></blockquote><blockquote><p>其实一开始的时候是想 爬今日头条的数据，但是发现数据总是为空，我估计是上锁了… 然后就把矛头转向了 简书，哈哈哈…果然简书就是好，数据直接就可以爬到了， 好开心啊！！ </p></blockquote><div class="github-widget" data-repo="xiaweizi/jsoupJianshuDemo"></div><p>先演示一波动态图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-1015dbce5faa6a90.gif?imageMogr2/auto-orient/strip" alt="整体效果.gif"></p><blockquote><p>话说这个布局就花了我半个小时…</p></blockquote><blockquote><p>一些基础的我就不说了，就简单说明一下我的数据是如何爬到的。可以直接去看一下我的源码，写的比较仓促，一些细节没有处理好，多多指教。</p></blockquote><h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><h4 id="1-相关资料"><a href="#1-相关资料" class="headerlink" title="1. 相关资料"></a>1. 相关资料</h4><blockquote><p><a href="https://jsoup.org/cookbook/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://www.open-open.com/jsoup/" target="_blank" rel="noopener">中文文档</a></p></blockquote><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2. 添加依赖"></a>2. 添加依赖</h4><pre><code>compile &apos;org.jsoup:jsoup:1.9.2&apos;</code></pre><h4 id="3-打开简书首页"><a href="#3-打开简书首页" class="headerlink" title="3. 打开简书首页"></a>3. 打开简书首页</h4><p><img src="http://upload-images.jianshu.io/upload_images/4043475-47c5c0014f33995c.gif?imageMogr2/auto-orient/strip" alt="first.gif"></p><p>在单个部分上 右击，然后点击<strong>检查</strong>选项(我用的是QQ浏览器，其他未尝试)，底部就会跳出网页的源码，并且会跟踪到这个item对应的源码。</p><p>从上图可以大概了解到每个<code>&lt;li&gt;&lt;/li&gt;</code>标签里的内容就是我们每个item的信息。</p><h1 id="2-爬数据"><a href="#2-爬数据" class="headerlink" title="2. 爬数据"></a>2. 爬数据</h1><h4 id="1-获取-Document-对象"><a href="#1-获取-Document-对象" class="headerlink" title="1. 获取 Document 对象"></a>1. 获取 <code>Document</code> 对象</h4><pre><code>Document document = Jsoup.connect(&quot;http://www.jianshu.com/&quot;)                         .timeout(10000)                         .get();</code></pre><blockquote><p>这里通过建立与服务器的链接，并设置10s的超时连接来获取 <code>Document</code> 对象</p></blockquote><h4 id="2-获取跟标签的-Elements-对象"><a href="#2-获取跟标签的-Elements-对象" class="headerlink" title="2. 获取跟标签的 Elements 对象"></a>2. 获取跟标签的 <code>Elements</code> 对象</h4><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3c651e3f8adb56fc.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="first.PNG"></p><pre><code>Elements noteList = document.select(&quot;ul.note-list&quot;);Elements li = noteList.select(&quot;li&quot;);</code></pre><blockquote><p>找到文章列表模块，发现 <code>&lt;ul class=&quot;note-list&gt;&lt;/ul&gt;</code> 是我们需要信息的跟标签。通过 <code>select</code> 方法查询节点所有信息。</p></blockquote><pre><code>for (Element element : li) {    ...}</code></pre><blockquote><p>下面全部都是 <code>li</code>标签的列表，里面的内容大致相似，我们就可以通过循环来遍历里面的信息。</p></blockquote><h4 id="3-获取每个部分所有信息"><a href="#3-获取每个部分所有信息" class="headerlink" title="3. 获取每个部分所有信息"></a>3. 获取每个部分所有信息</h4><p>因为信息比较多，我就选择比较有代表性的来将一下。</p><p>有个非常简单的方式：直接在你需要获取内容的部分右击，点击 <strong>检查</strong>，就可以直接追踪到要查询的位置。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-97a92643e9d4212e.gif?imageMogr2/auto-orient/strip" alt="second.gif"></p><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h4><blockquote><p>就拿标题而言，直接在标题右击–&gt;检查，即可，一目了然。然后我把数据截图一下。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-79b584e8b487c788.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="second.PNG"></p><pre><code>String title = element.select(&quot;a.title&quot;).text()</code></pre><blockquote><p>通过 <code>select</code> 查询节点信息，然后<code>.text</code> 获取里面文本内容。</p></blockquote><h4 id="2-头像："><a href="#2-头像：" class="headerlink" title="2. 头像："></a>2. 头像：</h4><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9a1309b80f3eca30.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="third.PNG"></p><pre><code>String avatar = element.select(&quot;a.avatar&quot;).select(&quot;img&quot;).attr(&quot;src&quot;)</code></pre><blockquote><p>这个就是先找到头像 节点，然后图片节点，最后通过 <code>attr</code> 获取图片 <code>url</code></p></blockquote><h4 id="3-首页链接"><a href="#3-首页链接" class="headerlink" title="3. 首页链接"></a>3. 首页链接</h4><p><img src="http://upload-images.jianshu.io/upload_images/4043475-f74c2389c73ebcc6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="forth.PNG"></p><pre><code>String authorLink = element.select(&quot;a.blue-link&quot;).attr(&quot;abs:href&quot;)</code></pre><blockquote><p>这里注意 <code>href</code> 元素，他存放的就是跳转链接，不过是相对路径，这个时候就需要通过 <code>attr(&quot;abs:href&quot;)</code> 获取绝对路径。</p></blockquote><p>其他 就 大同小异，其实我知道也就这么多，也是不断尝试通过打印得出来的，还是比较心酸的，比较没学过 <code>js</code>，不过对 <code>js</code> 挺有兴趣的。</p><h1 id="3-封装"><a href="#3-封装" class="headerlink" title="3. 封装"></a>3. 封装</h1><p>剩下的就是将获取到的数据加载到bean对象中 </p><h4 id="1-创建-bean-对象"><a href="#1-创建-bean-对象" class="headerlink" title="1. 创建 bean 对象"></a>1. 创建 bean 对象</h4><pre><code>public class JianshuBean {    private String authorName;          // 作者    private String authorLink;          // 作者链接    private String time;                // 更新时间    private String primaryImg;          // 主图    private String avatarImg;           // 头像    private String title;               // 标题    private String titleLink;           // 标题链接    private String content;             // 内容    private String collectionTagLink;   // 专题链接    private String readNum;             // 阅读量    private String talkNum;             // 评论    private String likeNum;             // 喜欢    private String collectionTag;       // 专题    // ... get set}</code></pre><h4 id="2-将获取到的数据添加到集合中"><a href="#2-将获取到的数据添加到集合中" class="headerlink" title="2. 将获取到的数据添加到集合中"></a>2. 将获取到的数据添加到集合中</h4><pre><code>for (Element element : li) {    JianshuBean bean = new JianshuBean();    bean.setAuthorName(element.select(&quot;div.name&quot;).text()); // 作者姓名    bean.setAuthorLink(element.select(&quot;a.blue-link&quot;).attr(&quot;abs:href&quot;)); // 作者首页链接    bean.setTime(element.select(&quot;span.time&quot;).attr(&quot;data-shared-at&quot;));   // 发表时间    bean.setPrimaryImg(element.select(&quot;img&quot;).attr(&quot;src&quot;));  // 主图    bean.setAvatarImg(element.select(&quot;a.avatar&quot;).select(&quot;img&quot;).attr(&quot;src&quot;)); // 头像    bean.setTitle(element.select(&quot;a.title&quot;).text());    // 标题    bean.setTitleLink(element.select(&quot;a.title&quot;).attr(&quot;abs:href&quot;)); // 标题链接    bean.setContent(element.select(&quot;p.abstract&quot;).text());       // 内容    bean.setCollectionTagLink(element.select(&quot;a.collection-tag&quot;).attr(&quot;abs:href&quot;)); // 专题链接    String[] text = element.select(&quot;div.meta&quot;).text().split(&quot; &quot;);    if (text[0].matches(&quot;[0-9]+&quot;)) {        bean.setReadNum(text[0]);        bean.setTalkNum(text[1]);        bean.setLikeNum(text[2]);    } else {        bean.setCollectionTag(text[0]);        bean.setReadNum(text[1]);        bean.setTalkNum(text[2]);        bean.setLikeNum(text[3]);    }    mBeans.add(bean);}</code></pre><p>再来看一下效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-1015dbce5faa6a90.gif?imageMogr2/auto-orient/strip" alt="整体效果.gif"></p><p><a href="https://github.com/xiaweizi/jsoupJianshuDemo" target="_blank" rel="noopener">项目地址</a></p><ul><li>点击头像查看作者信息</li><li>点击图片或文字查看文章内容</li><li>点击专题查看专题内容</li><li>下拉刷新获取最新内容</li></ul><p>希望大家多多支持我，谢谢！</p><p><a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方库 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jsoup爬虫简书首页数据做个小Demo</title>
      <link href="/article/64591/"/>
      <content type="html"><![CDATA[<h1 id="篇前唠叨"><a href="#篇前唠叨" class="headerlink" title="篇前唠叨"></a>篇前唠叨</h1><p><em><a href="http://xiaweizi.cn/">我的博客地址</a></em><br>之前写了一个小项目 <a href="https://github.com/xiaweizi/QNews" target="_blank" rel="noopener">趣闻</a> ，是我找工作期间自己做的一个小Demo。花了一点时间完成后，便在简书上与大家分享 <a href="http://www.jianshu.com/p/ae4aa11f35a4" target="_blank" rel="noopener">快毕业了，撸一个小项目(新闻段子客户端)</a>,竟然在一天之间收到那么多的喜欢：</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/4043475-dd870b8e27244fb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="thank.png"></p><p>这让我这个小菜鸟是万万没有想到的，所以在这我要感谢所有给我鼓励，给我建议的撸友们，谢谢你们，我会努力的！</p><p><em>之前项目用的是 OkHttp 的开源框架完成的网络请求，但是我们程序员要跟得上时代的潮流!</em><br><img src="http://upload-images.jianshu.io/upload_images/4043475-67703efffc224725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="rank.png"></p><p><em>可以发现 RxJava 和 Retrofit 位居排行榜的第一第三，由此可见学习RxJava+Retrofit的必要性！</em></p><p>于是，我花了两天的时间学习了一下 Retrofit 和 RxJava，发现RxJava 真TM强呀！相见恨晚哪！</p><p>因为花的时间不多，所以只了解到一些皮毛，然后趁热打铁，尝试着在自己的项目中加入这个强大的框架，有些细节可能处理的不好，请多多指教！</p><blockquote><p>先声明：本篇文章只介绍如何简单的使用 Retrofit+RxJava, 详细部分就请大家自己查找资料，因为本人知道也太少…</p></blockquote><blockquote><p>推荐觉得比较好的文章：</p></blockquote><blockquote><ul><li><a href="https://github.com/rengwuxian" target="_blank" rel="noopener">扔物线</a> 的 <a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></li><li><a href="https://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="noopener">RxJava 与 Retrofit 结合的最佳实践</a></li><li><a href="http://www.jianshu.com/p/9a5233bc1da8" target="_blank" rel="noopener">Retrofit使用详解系列</a></li><li><a href="http://www.jianshu.com/p/d149043d103a" target="_blank" rel="noopener">手把手教你使用 RxJava 2.0系列</a></li></ul></blockquote><hr><blockquote><p>首先将需要添加的依赖全部添加，后面就不赘述了。</p><pre><code>//Retrofitcompile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos;//Retrofit通过GSON将结果转换为Bean对象compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;//让Retrofit支持RxJavacompile &apos;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&apos;//RxJavacompile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxjava:2.0.1&apos;//日志拦截器compile &apos;com.squareup.okhttp3:logging-interceptor:3.4.1&apos;</code></pre></blockquote><p>还是先来一波结果演示图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-72b7868b0f671268.gif?imageMogr2/auto-orient/strip" alt="运行结果.gif"></p><p>我就拿我的项目中<a href="https://www.juhe.cn/docs/api/id/95" target="_blank" rel="noopener">段子</a>模块来进行修改，数据还是来源 <a href="https://www.juhe.cn/docs/index/sortby/4" target="_blank" rel="noopener">聚合数据</a>。</p><h1 id="1-创建-javaBean-对象"><a href="#1-创建-javaBean-对象" class="headerlink" title="1. 创建 javaBean 对象"></a>1. 创建 javaBean 对象</h1><blockquote><p>我是从 <a href="https://www.juhe.cn/docs/index/sortby/4" target="_blank" rel="noopener">聚合数据</a> 这个平台获取到数据，当你从这个平台申请到这个服务，他会给你一个接口和Appkey，然后通过查询参数可以获取相应的数据。</p></blockquote><blockquote><p>这里我就把我的 <code>Appkey</code> 无私的贡献出来</p></blockquote><blockquote><p>这是我的数据接口 <a href="http://japi.juhe.cn/joke/content/text.from?key=ae240f7fba620fc370b803566654949e&amp;page=1&amp;pagesize=10" target="_blank" rel="noopener">http://japi.juhe.cn/joke/content/text.from?key=ae240f7fba620fc370b803566654949e&amp;page=1&amp;pagesize=10</a></p></blockquote><blockquote><p>相信大家都能看的懂吧，除了固定 <code>url</code>，后面参数分别代表 开发者的 <code>AppKey</code>、获取数据的页数和每页显示的条数。</p></blockquote><p>这是我从服务器获取到的 <code>json</code> 数据：</p><pre><code>{    &quot;error_code&quot;: 0,    &quot;reason&quot;: &quot;Success&quot;,    &quot;result&quot;: {&quot;data&quot;: [{        &quot;content&quot;: &quot;一男子跟朋友走在路上，突然发现五个女人正在围殴其丈母娘！　　朋友见状，忙问男子：\u201c你还不赶紧上去帮忙？！\u201d　　男子镇定地说：\u201c不用，五个人足够了！\u201d&quot;,        &quot;hashId&quot;: &quot;0a8b6fdd70daa311aa82a771132d9895&quot;,        &quot;unixtime&quot;: 1487980430,        &quot;updatetime&quot;: &quot;2017-02-25 07:53:50&quot;    }]}}</code></pre><p>然后通过 <code>Android Studio</code> 插件 <code>GsonFormat</code> 自动生成 <code>javaBean</code> 对象，这里我就不把代码贴出来了，太多了。 </p><h1 id="2-创建服务接口和获取数据的方法"><a href="#2-创建服务接口和获取数据的方法" class="headerlink" title="2. 创建服务接口和获取数据的方法"></a>2. 创建服务接口和获取数据的方法</h1><pre><code>public interface QNewsService {    public static final String DESC = &quot;desc&quot;; // 指定时间之前发布的    public static final String ASC = &quot;asc&quot;;   // 指定时间之后发布的    /**     * 查询最新的段子数据     *      * @param page      查询的页数     * @param pagesize  一页数据显示的条数     * @return          查询结束返回的被观察者     */    //接口完整地址    // http://japi.juhe.cn/joke/content/text.from?key=ae240f7fba620fc370b803566654949e    @GET(&quot;text.from?key=ae240f7fba620fc370b803566654949e&quot;)    Observable&lt;JokeBean&gt; getCurrentJokeData(            @Query(&quot;page&quot;) int page,            @Query(&quot;pagesize&quot;) int pagesize    );    /**     * 根据指定的时间，获取相关的段子数据     *      * @param time          要指定查询的时间     * @param page          查询的页数     * @param pagesize      一页数据显示的条数     * @param sort          判断是在指定时间之前还是之后     *                          {@value DESC 指定之前},{@value ASC 指定之后}     * @return              查询结束返回的被观察者     */    //接口完整地址    // http://japi.juhe.cn/joke/content/list.from?key=ae240f7fba620fc370b803566654949e&amp;page=1&amp;pagesize=5&amp;sort=desc    @GET(&quot;list.from?key=ae240f7fba620fc370b803566654949e&quot;)    Observable&lt;JokeBean&gt; getAssignJokeData(            @Query(&quot;time&quot;) long time,            @Query(&quot;page&quot;) int page,            @Query(&quot;pagesize&quot;) int pagesize,            @Query(&quot;sort&quot;) String sort    );}</code></pre><blockquote><p><code>@GET</code>： 请求方法为 <code>GET</code></p></blockquote><blockquote><p><code>(&quot;text.from?key=ae240f7fba620fc370b803566654949e&quot;)</code>：除去 <code>baseUrl</code>，因为 <code>AppKey</code> 值固定，就可以直接写进去，要查询的单独列出来</p></blockquote><blockquote><p><code>Observable&lt;JokeBean&gt;</code>:这个就是 <code>RxJava+Retrofit</code> 的简单结合体，当你从服务器获取数据直接返回JavaBean对象，是不是很强大，然后把它有转换成 被观察者，方便后面事件的传递。</p></blockquote><blockquote><p><code>@Query(&quot;page&quot;) int page</code>：通过 <code>@Query</code> 来设置查询条件</p></blockquote><h1 id="3-创建客户端"><a href="#3-创建客户端" class="headerlink" title="3. 创建客户端"></a>3. 创建客户端</h1><pre><code>public class QClitent {    private static QClitent mQClient;    private Retrofit mRetrofit;    private QClitent(){        mRetrofit = createRetrofit();    }    public static QClitent getInstance() {        if (mQClient == null){            synchronized (QClitent.class){                if (mQClient == null){                    mQClient = new QClitent();                }            }        }        return mQClient;    }    /**     * 创建相应的服务接口     */    public &lt;T&gt; T create(Class&lt;T&gt; service){        checkNotNull(service, &quot;service is null&quot;);        return mRetrofit.create(service);    }    /**     * 直接创建 QNewsService     */        public QNewsService createQNewsService(){        return mRetrofit.create(QNewsService.class);    }    private  &lt;T&gt; T checkNotNull(T object, String message) {        if (object == null) {            throw new NullPointerException(message);        }        return object;    }    private Retrofit createRetrofit() {        //初始化OkHttp        OkHttpClient.Builder builder = new OkHttpClient.Builder()                .connectTimeout(9, TimeUnit.SECONDS)    //设置连接超时 9s                .readTimeout(10, TimeUnit.SECONDS);      //设置读取超时 10s        if (BuildConfig.DEBUG) { // 判断是否为debug            // 如果为 debug 模式，则添加日志拦截器            HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();            interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);            builder.addInterceptor(interceptor);        }        // 返回 Retrofit 对象        return new Retrofit.Builder()                .baseUrl(Constants.BASE_JOKE_URL)                .client(builder.build()) // 传入请求客户端                .addConverterFactory(GsonConverterFactory.create()) // 添加Gson转换工厂                .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // 添加RxJava2调用适配工厂                .build();    }}</code></pre><blockquote><p>这里采用 单例模式 获取 <code>Retrofit</code> 对象，创建相应的服务接口。</p></blockquote><blockquote><p>注释写的比较详细，我就不多说了。</p></blockquote><h1 id="4-使用-RxJava-完成异步请求"><a href="#4-使用-RxJava-完成异步请求" class="headerlink" title="4. 使用 RxJava 完成异步请求"></a>4. 使用 RxJava 完成异步请求</h1><pre><code>private void updateDate() {    srlJoke.setRefreshing(true);    // 让SwipeRefreshLayout开启刷新    QClitent.getInstance()            .create(QNewsService.class) // 创建服务            .getCurrentJokeData(1, 8)   // 查询            .subscribeOn(Schedulers.io())   //  指定被观察者的操作在io线程中完成            .observeOn(AndroidSchedulers.mainThread())  // 指定观察者接收到数据，然后在Main线程中完成            .subscribe(new Consumer&lt;JokeBean&gt;() {                @Override                public void accept(JokeBean jokeBean) throws Exception {                    // 成功获取数据                    mAdapter.setNewData(jokeBean.getResult().getData());    // 给适配器设置数据                    srlJoke.setRefreshing(false);       // 让SwipeRefreshLayout关闭刷新                }            }, new Consumer&lt;Throwable&gt;() {                @Override                public void accept(Throwable throwable) throws Exception {                    // 获取数据失败                    Toast.makeText(getActivity(), &quot;获取数据失败&quot;, Toast.LENGTH_SHORT).show();                    srlJoke.setRefreshing(false);                }            });}</code></pre><blockquote><p><code>RxJava</code> 在 <code>GitHub</code> 主页上的自我介绍是<code>&quot;a library for composing asynchronous and event-based programs using observable sequences for the Java VM&quot;</code><br>（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p></blockquote><blockquote><p>通过强大的链式调用，一目了然，简单迅速的完成了网络的异步请求和数据加载。这就是 <code>RxJava+Retrofit</code> 的强大之处！其实这只是一小部分，<code>RxJava</code> 的功能远不止于此，强大的操作符基本上可以完成项目中所有事件传递的需要，推荐大家，一定好好研究一下这个强大的框架！</p></blockquote><p>最后的结果就是这样，跟之前没什么太大区别：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-72b7868b0f671268.gif?imageMogr2/auto-orient/strip" alt="运行结果.gif"></p><p>好了，到此，简单的 <code>RxJava+Retrofit</code> 小应用就结束了，虽然目前还是没有找到工作，但是丝毫不影响我继续学习下去，我相信，肯定有一家公司愿意收留我的！</p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方库 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快毕业了，撸一个小项目(新闻段子客户端)</title>
      <link href="/article/62207/"/>
      <content type="html"><![CDATA[<p><em>最近一直在找工作，感觉好难找呀，简历投了都没人打电话给我，伤心…但是不能闲着，于是利用大概七天的下午时间撸了一个小项目(QNews)作为我的毕业设计。项目地址</em></p><div class="github-widget" data-repo="xiaweizi/QNews"></div><p><em><a href="http://xiaweizi.cn/">我的博客地址</a></em></p><a id="more"></a><blockquote><p>上线的时候遇到了问题，这问题也是醉了…<br><img src="http://upload-images.jianshu.io/upload_images/4043475-db899365f04e45a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aa.png"></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-c6b119e8514b3629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bb.png"></p><blockquote><p>这个项目从头到尾是我一个人默默撸出来的，很心酸，可能有些代码写的不是很好，请见谅。这个项目虽然小，但是也遇到了很多bug，欣慰的是，最后都解决了，我想这是程序猿最大乐趣了。</p></blockquote><blockquote><p>我通过一下目录进行项目的演示：</p></blockquote><blockquote><p><a href="#title1">1. 整体风格和个人页面</a></p><p><a href="#title2">2. 跳转界面</a></p><p><a href="#title3">3. 新闻模块</a></p><p><a href="#title4">4. 段子模块</a></p><p><a href="#title5">5. 趣图模块</a></p><p><a href="#title6">6. 历史上的今天模块</a></p><p><a href="#title7">7. 图灵机器人模块</a></p><p><a href="#title8">8. 主题切换以及夜间模式模块</a></p><p><a href="#title9">9. 用到的第三方开源库</a></p></blockquote><p>##</p><p id="title1">1. 整体风格和个人页面</p><br><em>整体采用的是Material Design风格，看起来好看一点</em><br><img src="http://upload-images.jianshu.io/upload_images/4043475-eb1932393eedabec.gif?imageMogr2/auto-orient/strip" alt="整体风格.gif"><p></p><blockquote><p>如果觉得还行，请给个star吧</p></blockquote><p>##</p><p id="title2">2. 跳转界面</p><br><img src="http://upload-images.jianshu.io/upload_images/4043475-f8fdb6021cf5d558.gif?imageMogr2/auto-orient/strip" alt="跳转界面.gif"><p></p><blockquote><p>这个就是属性动画(translationX + translationY)</p></blockquote><p>##</p><p id="title3">3. 新闻模块</p><br><img src="http://upload-images.jianshu.io/upload_images/4043475-19e7b7c64e0989fc.gif?imageMogr2/auto-orient/strip" alt="新闻模块.gif"><p></p><blockquote><p>数据来源: 聚合数据</p><p>网络框架: okhttp</p><p>图片框架: Glide</p></blockquote><p>##</p><p id="title4">4. 段子模块</p><br><img src="http://upload-images.jianshu.io/upload_images/4043475-672753f228c57c18.gif?imageMogr2/auto-orient/strip" alt="段子模块.gif"><p></p><blockquote><p>支持下拉刷新，下拉加载更多</p></blockquote><p>##</p><p id="title5">5. 趣图模块</p><br><em>这个是个小彩蛋，在段子界面，在点击一下段子就会跳转到趣图模块</em><br><img src="http://upload-images.jianshu.io/upload_images/4043475-811a7bef92721664.gif?imageMogr2/auto-orient/strip" alt="趣图模块.gif"><p></p><blockquote><p>这里是随机从服务器中获取趣图，有时候也会有动态图</p></blockquote><p>##</p><p id="title6">6. 历史上的今天模块</p><br><em>这部分我觉得既好玩，又很有意义</em><br><img src="http://upload-images.jianshu.io/upload_images/4043475-2a88baf13919023b.gif?imageMogr2/auto-orient/strip" alt="历史上的今天.gif"><p></p><blockquote><p>说实话，我还挺喜欢叶圣陶的。</p></blockquote><blockquote><p>其实点进去上面是viewpager展示图片的，但是不知道怎么搞得，聚合数据图片不提供了，也是醉了。</p></blockquote><p>##</p><p id="title7">7. 图灵机器人模块</p><br><img src="http://upload-images.jianshu.io/upload_images/4043475-8858ce0eaeda160f.gif?imageMogr2/auto-orient/strip" alt="图灵机器人.gif"><p></p><blockquote><p>闲来没事，单身狗可以玩一下，嘻嘻…</p></blockquote><p>##</p><p id="title8">8. 主题切换以及夜间模式</p><br><img src="http://upload-images.jianshu.io/upload_images/4043475-211cf778e95c0898.gif?imageMogr2/auto-orient/strip" alt="换肤.gif"><p></p><blockquote><p>我用采用的方式比较简单，就是直接setTheme(int resId)方式，网上有一些好的实现方式，不妨上网搜一下。</p></blockquote><p>##</p><p id="title9">8. 用到的第三方开源库</p><p></p><ol><li>数据来源： <a href="https://www.juhe.cn/docs" target="_blank" rel="noopener">聚合数据</a></li><li>标题来源： <a href="http://www.akuziti.com/" target="_blank" rel="noopener">艺术字生成</a></li><li>小图标来源： <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">阿里适量图</a></li><li>图片加载框架： <a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a></li><li>网络请求框架： <a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener">鸿洋大神的okhttputils</a></li><li>view注解框架： <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a></li><li>基类适配器： <a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper" target="_blank" rel="noopener">BaseRecyclerViewAdapterHelper</a></li><li>指示器： <a href="https://github.com/hackware1993/MagicIndicator" target="_blank" rel="noopener">MagicIndicator</a></li><li>底部栏： <a href="https://github.com/Nightonke/BoomMenu" target="_blank" rel="noopener">BoomMenu</a></li></ol><blockquote><p>好了，到此项目已经大概结束了，有一些功能还没实现，比如数据库的缓存，第三方分享等，如果有兴趣的话，可以看一下我的源码 <a href="https://github.com/xiaweizi/QNews" target="_blank" rel="noopener">https://github.com/xiaweizi/QNews</a>，如果有那么点喜欢的话就star一下吧</p></blockquote><blockquote><p>如果有人能介绍我工作，本人不甚感激！！</p></blockquote><p><a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于MaterialDesign设计风格的妹纸app的简单实现</title>
      <link href="/article/7691/"/>
      <content type="html"><![CDATA[<p><em>今天看了郭神的第二行代码，深深的被MaterialDesign的设计风格所吸引，然后就照例做了一个小Demo，希望多多支持，图片资源来源于网络。先附上我的源码地址</em></p><div class="github-widget" data-repo="xiaweizi/MaterialDesign"></div><p><em><a href="http://xiaweizi.cn/">我的博客地址</a></em></p><a id="more"></a><p><strong>照例，一波动态图来袭：</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-df4822dd48cf72a6.gif?imageMogr2/auto-orient/strip" alt="MaterialDesign风格.gif"></p><blockquote><p>效果还不错吧，就是有点失真…其实在这之前Android的UI风格都不是很美观，所谷歌的设计工程师们就开始研究出了一种新的设计语言—MaterialDesign。在2015年得谷歌大会上推出了DesignSupport库，使得开发者在即使不了解MaterialDesign的情况下也能非常轻松地将自己得应用Material化。</p><p>接下来我会按照下面流程介绍如何实现这一效果</p></blockquote><ol><li><code>Toolbar</code></li><li><code>DrawerLayout</code></li><li><code>SnackBar</code></li><li><code>CardView</code></li><li><code>RecyclerView</code></li><li><code>SwipeRefreshLayout</code></li><li><code>AppBarLayout</code></li><li><code>CollapsingToolbarLayout</code></li><li><code>沉浸式状态栏</code></li></ol><p>首先添加依赖：</p><pre><code>compile &apos;com.android.support:appcompat-v7:24.2.1&apos;compile &apos;com.android.support:design:24.0.0&apos;compile&apos;com.android.support:recyclerview-v7:24.0.0&apos;compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;compile &apos;com.android.support:cardview-v7:24.1.1&apos;compile &apos;de.hdodenhof:circleimageview:2.1.0&apos;</code></pre><h1 id="1-Toolbar"><a href="#1-Toolbar" class="headerlink" title="1. Toolbar"></a>1. Toolbar</h1><p>效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/4043475-b6f5b86bc9b0840f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="toolbar.PNG"></p><p>它有点类似于之前得ActionBar，就是活动最顶部得哪个标题栏。但是，它只能位于活动得顶部，从而影响效果，所有官方现在已经不再建议使用ActionBar了。</p><h4 id="1-设置AppTheme-“NoActionBar”"><a href="#1-设置AppTheme-“NoActionBar”" class="headerlink" title="1. 设置AppTheme(“NoActionBar”)"></a>1. 设置AppTheme(“NoActionBar”)</h4><pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;    &lt;!-- Customize your theme here. --&gt;    ...&lt;/style&gt;</code></pre><h4 id="2-添加控件"><a href="#2-添加控件" class="headerlink" title="2. 添加控件"></a>2. 添加控件</h4><pre><code>&lt;android.support.v7.widget.Toolbar    android:id=&quot;@+id/toolbar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;?attr/actionBarSize&quot;    android:background=&quot;?attr/colorPrimary&quot;    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;    app:popupTheme=&quot;@style/Theme.AppCompat.Light&quot; /&gt;</code></pre><blockquote><p>其他属性我就不说了，<code>app:popupTheme</code> 这个是单独将弹出得菜单项指定成淡色主题。</p></blockquote><blockquote><p>这个时候需要指定一个新的命名空间 <code>xmlns:app</code> 这是由于MaterialDesign是在Android5.0系统中才出现得，而很多Material属性在5.0之前得系统中是不存在得，那么为了能够兼容之前得老系统，我们就得使用 <code>app:</code> 。 </p></blockquote><h4 id="3-在代码中使用"><a href="#3-在代码中使用" class="headerlink" title="3. 在代码中使用"></a>3. 在代码中使用</h4><pre><code>mToolbar = (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(mToolbar);</code></pre><blockquote><p>首先通过 <code>findViewById</code> 得到Toobar实例，然后调用setSupportActionBar()方法将实例传入。</p></blockquote><h4 id="4-设置菜单选项"><a href="#4-设置菜单选项" class="headerlink" title="4. 设置菜单选项"></a>4. 设置菜单选项</h4><pre><code>&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;&lt;item    android:id=&quot;@+id/backup&quot;    android:icon=&quot;@drawable/ic_backup&quot;    android:title=&quot;Backup&quot;    app:showAsAction=&quot;always&quot;/&gt;&lt;item    android:id=&quot;@+id/delete&quot;    android:icon=&quot;@drawable/ic_delete&quot;    android:title=&quot;Delete&quot;    app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;item    android:id=&quot;@+id/settings&quot;    android:icon=&quot;@drawable/ic_settings&quot;    android:title=&quot;Settings&quot;    app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt;</code></pre><blockquote><p>在menu文件夹中创建xml文件</p></blockquote><blockquote><p><code>app:showAsAction</code> 来指定按钮得显示位置</p></blockquote><blockquote><p><code>ifRoom</code>: 表示屏幕空间足够得情况下显示再Toolbar，不够就显示再菜单中</p></blockquote><blockquote><p><code>always</code>: 表示永远显示在Toolbar中，如果屏幕空间不够则不显示</p></blockquote><blockquote><p><code>never</code>: 表示永远显示在菜单当中</p></blockquote><h4 id="5-在代码中实用菜单选项"><a href="#5-在代码中实用菜单选项" class="headerlink" title="5. 在代码中实用菜单选项"></a>5. 在代码中实用菜单选项</h4><pre><code>/*************************** * 创建菜单 ***************************/@Overridepublic boolean onCreateOptionsMenu(Menu menu) {    getMenuInflater().inflate(R.menu.menu, menu);    return true;}/*************************** * 给菜单设置点击事件 ***************************/@Overridepublic boolean onOptionsItemSelected(MenuItem item) {    switch (item.getItemId()) {        case R.id.backup:            Toast.makeText(MainActivity.this, &quot;backup&quot;, Toast.LENGTH_SHORT).show();            break;        case R.id.delete:            Toast.makeText(this, &quot;delete&quot;, Toast.LENGTH_SHORT).show();            break;        case R.id.settings:            Toast.makeText(this, &quot;setting&quot;, Toast.LENGTH_SHORT).show();            break;        default:    }    return true;}</code></pre><h1 id="2-DrawerLayout"><a href="#2-DrawerLayout" class="headerlink" title="2. DrawerLayout"></a>2. DrawerLayout</h1><p>这个在我之前得文章讲过，可以直接点击查看 <a href="http://www.jianshu.com/p/ce8a7a20c03c" target="_blank" rel="noopener">高大上的侧滑菜单DrawerLayout，解决了不能全屏滑动的问题 </a><br>不过左侧可以再优化下，实用新的控件 <code>NavigationView</code><br><strong>NavigationView</strong></p><blockquote><p>在使用前，提前准备好两个东西：<code>menu</code> 和 <code>headerLayout</code> </p></blockquote><h4 id="1-创建menu"><a href="#1-创建menu" class="headerlink" title="1. 创建menu"></a>1. 创建menu</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;group android:checkableBehavior=&quot;single&quot;&gt;        &lt;item            android:id=&quot;@+id/nav_call&quot;            android:icon=&quot;@drawable/nav_call&quot;            android:title=&quot;妹纸&quot; /&gt;        &lt;item            android:id=&quot;@+id/nav_friends&quot;            android:icon=&quot;@drawable/nav_friends&quot;            android:title=&quot;段子&quot; /&gt;        &lt;item            android:id=&quot;@+id/nav_location&quot;            android:icon=&quot;@drawable/nav_location&quot;            android:title=&quot;新闻&quot; /&gt;        &lt;item            android:id=&quot;@+id/nav_mail&quot;            android:icon=&quot;@drawable/nav_mail&quot;            android:title=&quot;本地&quot; /&gt;        &lt;item            android:id=&quot;@+id/nav_task&quot;            android:icon=&quot;@drawable/nav_task&quot;            android:title=&quot;收藏&quot; /&gt;    &lt;/group&gt;&lt;/menu&gt;</code></pre><blockquote><p>将group得 <code>checkableBehavior</code> 属性指定为single，表示所有得菜单项只能单选</p></blockquote><h4 id="2-创建headerLayout"><a href="#2-创建headerLayout" class="headerlink" title="2. 创建headerLayout"></a>2. 创建headerLayout</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;180dp&quot;android:background=&quot;?attr/colorPrimary&quot;android:padding=&quot;10dp&quot;&gt;    &lt;de.hdodenhof.circleimageview.CircleImageView        android:id=&quot;@+id/icon_image&quot;        android:layout_width=&quot;70dp&quot;        android:layout_height=&quot;70dp&quot;        android:layout_centerInParent=&quot;true&quot;        android:src=&quot;@drawable/nav_icon&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/username&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:text=&quot;1012126908@qq.com&quot;        android:textColor=&quot;#FFF&quot;        android:textSize=&quot;14sp&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/mail&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_above=&quot;@id/username&quot;        android:text=&quot;夏韦子&quot;        android:textColor=&quot;#FFF&quot;        android:textSize=&quot;14sp&quot; /&gt;&lt;/RelativeLayout&gt;</code></pre><h4 id="3-在布局中使用"><a href="#3-在布局中使用" class="headerlink" title="3. 在布局中使用"></a>3. 在布局中使用</h4><pre><code>&lt;android.support.design.widget.NavigationView    android:id=&quot;@+id/nv_left&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_gravity=&quot;left&quot;    app:headerLayout=&quot;@layout/nav_header&quot;    app:menu=&quot;@menu/nav_menu&quot;&gt;&lt;/android.support.design.widget.NavigationView&gt;</code></pre><blockquote><p><code>app:headerLayout</code> ： headerLayout文件</p><p><code>app:menu</code>: menu文件</p></blockquote><blockquote><p><code>android:layout_gravity=&quot;left&quot;</code> 设置为左侧菜单</p></blockquote><h4 id="4-在代码中使用"><a href="#4-在代码中使用" class="headerlink" title="4. 在代码中使用"></a>4. 在代码中使用</h4><pre><code>//给NavigationView设置item选择事件mNavigationView.setCheckedItem(R.id.nav_call);mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {    @Override    public boolean onNavigationItemSelected(MenuItem item) {        ...        return true;    }});</code></pre><h1 id="3-SnackBar"><a href="#3-SnackBar" class="headerlink" title="3. SnackBar"></a>3. SnackBar</h1><p>跟Toast有点相似，不过不同点在于加入一个可交互按钮，当用户点击按钮得时候可以执行一些额外得逻辑操作</p><p>效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-218e6895dea63c4d.gif?imageMogr2/auto-orient/strip" alt="SnackBar.gif"></p><p>使用起来比较简单，跟Toast很像。</p><pre><code>Snackbar snackbar = Snackbar.make(getCurrentFocus(), item.getTitle(), Snackbar.LENGTH_SHORT);snackbar.setAction(&quot;Undo&quot;, new View.OnClickListener() {    @Override    public void onClick(View v) {    }});snackbar.setActionTextColor(Color.BLUE);snackbar.show();</code></pre><h1 id="4-CardView"><a href="#4-CardView" class="headerlink" title="4. CardView"></a>4. CardView</h1><p>效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-9621073a96aaae5a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CardView.PNG"></p><p><code>CardView</code> 其实是一个FrameLayout，只是额外提供了圆角和阴影效果，<br>直接在布局中使用。</p><pre><code>&lt;android.support.v7.widget.CardViewxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;wrap_content&quot;android:background=&quot;?android:attr/selectableItemBackground&quot;app:cardElevation=&quot;10dp&quot;android:layout_margin=&quot;5dp&quot;app:cardCornerRadius=&quot;18dp&quot;&gt;...//子布局&lt;/android.support.v7.widget.CardView&gt;</code></pre><blockquote><p><code>app:cardCornerRadius</code> 指定卡片圆角得弧度，数值越大，圆角得弧度越大</p></blockquote><blockquote><p><code>app:cardElevation</code> 制定卡片得高度，高度值越大，投影得范围越大</p></blockquote><h1 id="5-RecyclerView"><a href="#5-RecyclerView" class="headerlink" title="5. RecyclerView"></a>5. RecyclerView</h1><p>这个在之前得文章也说过，如果需要查看，请移驾到： <a href="http://www.jianshu.com/p/60819de9eb42" target="_blank" rel="noopener">简单粗暴—-RecyclerView</a><br>本次得Demo里数据我就不详细说了，太多了，很简单。</p><h1 id="6-SwipeRefreshLayout"><a href="#6-SwipeRefreshLayout" class="headerlink" title="6. SwipeRefreshLayout"></a>6. SwipeRefreshLayout</h1><p>效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-04b9cdd7c0b12784.gif?imageMogr2/auto-orient/strip" alt="SwipeRefreshLayout.gif"><br>使用 <code>SwipeRefreshLayout</code> 直接可以实现下拉刷新的功能</p><h4 id="1-在布局中添加"><a href="#1-在布局中添加" class="headerlink" title="1. 在布局中添加"></a>1. 在布局中添加</h4><pre><code>&lt;android.support.v4.widget.SwipeRefreshLayoutandroid:id=&quot;@+id/srl_main&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;    &lt;android.support.v7.widget.RecyclerView        android:id=&quot;@+id/rv_main&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;    &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</code></pre><h4 id="2-在代码中添加"><a href="#2-在代码中添加" class="headerlink" title="2. 在代码中添加"></a>2. 在代码中添加</h4><pre><code>mRefreshLayout.setColorSchemeColors(Color.RED, Color.BLUE, Color.YELLOW, Color.GREEN);mRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {    @Override    public void onRefresh() {        refreshFruits();    }});</code></pre><blockquote><p>可以给刷新得时候设置颜色的变换，在 <code>onRefresh()</code> 中实现刷新得功能</p></blockquote><h1 id="7-AppBarLayout"><a href="#7-AppBarLayout" class="headerlink" title="7. AppBarLayout"></a>7. AppBarLayout</h1><p>先看一下效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-95e4cd9a50ff7c15.gif?imageMogr2/auto-orient/strip" alt="AppBarLayout.gif"></p><blockquote><p><code>AppBarLayout</code> 实际是一个垂直方向得 <code>LinearLayout</code>，它在内部做了很多滚动事件得封装，并应用了MaterialDesign设计理念。</p></blockquote><p>在布局中实用：</p><pre><code>&lt;android.support.design.widget.CoordinatorLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;!--       android:theme 设置背景主题深色，这样字体会变成白色       app:popupTheme 设置弹出的主题是亮色    --&gt;    &lt;android.support.design.widget.AppBarLayout        android:fitsSystemWindows=&quot;true&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;android.support.v7.widget.Toolbar            android:id=&quot;@+id/toolbar&quot;            android:fitsSystemWindows=&quot;true&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;?attr/actionBarSize&quot;            android:background=&quot;?attr/colorPrimary&quot;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;            app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;            app:popupTheme=&quot;@style/Theme.AppCompat.Light&quot; /&gt;    &lt;/android.support.design.widget.AppBarLayout&gt;    &lt;android.support.v4.widget.SwipeRefreshLayout        ...        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;        ...    &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre><blockquote><p><code>app:layout_scrollFlags</code>： 当AppBarLayout接收到滚动事件得时候，它内部得子空间就是通过这个属性影响这些事件的</p></blockquote><blockquote><p><code>scroll</code>：表示当 <code>RecyclerView</code>向上滚动得时候，Toolbar会跟着一起向上滚动并实现隐藏。</p></blockquote><blockquote><p><code>enterAlways</code>:表示当 <code>RecyclerView</code>向下滚动得时候，Toolbar会跟着一起向下滚动并重新显示。</p></blockquote><blockquote><p><code>snap</code>：表示当Toolbar还没有完全隐藏或显示得时候，会根据当前滚动得距离，自动选择是隐藏还是显示。</p></blockquote><h1 id="8-CollapsingToolbarLayout"><a href="#8-CollapsingToolbarLayout" class="headerlink" title="8. CollapsingToolbarLayout"></a>8. CollapsingToolbarLayout</h1><p>效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-272ff740e4ec844b.gif?imageMogr2/auto-orient/strip" alt="CollapsingToolbarLayout.gif"><br><strong>可折叠式标题栏</strong>这个就比之前就负责点了，我先贴代码，然后一一解释。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayoutxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:fitsSystemWindows=&quot;true&quot;&gt;    &lt;android.support.design.widget.AppBarLayout        android:id=&quot;@+id/appBar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;250dp&quot;        android:fitsSystemWindows=&quot;true&quot;&gt;        &lt;android.support.design.widget.CollapsingToolbarLayout            android:id=&quot;@+id/collapsing_toolbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;            android:fitsSystemWindows=&quot;true&quot;            app:contentScrim=&quot;?attr/colorPrimary&quot;            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;            &lt;ImageView                android:id=&quot;@+id/fruit_image_view&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot;                android:scaleType=&quot;centerCrop&quot;                android:fitsSystemWindows=&quot;true&quot;                app:layout_collapseMode=&quot;parallax&quot; /&gt;            &lt;android.support.v7.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;?attr/actionBarSize&quot;                app:layout_collapseMode=&quot;pin&quot; /&gt;        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;    &lt;/android.support.design.widget.AppBarLayout&gt;    &lt;android.support.v4.widget.NestedScrollView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;android.support.v7.widget.CardView                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_marginBottom=&quot;15dp&quot;                android:layout_marginLeft=&quot;15dp&quot;                android:layout_marginRight=&quot;15dp&quot;                android:layout_marginTop=&quot;35dp&quot;                app:cardCornerRadius=&quot;4dp&quot;&gt;                &lt;TextView                    android:id=&quot;@+id/fruit_content_text&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;wrap_content&quot;                    android:layout_margin=&quot;10dp&quot; /&gt;            &lt;/android.support.v7.widget.CardView&gt;        &lt;/LinearLayout&gt;    &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre><blockquote><p><code>app:contentScrim</code>:在趋于折叠状态以及折叠之后得背景色</p></blockquote><blockquote><p><code>app:layout_scrollFlags</code> 这个之前讲过 </p><p><code>scroll</code> :表示 <code>CollapsingToolbarLayout</code>会随着妹纸内容详情得滚动一起滚动</p></blockquote><blockquote><p><code>exitUntilCollapsed</code>:表示当 <code>CollapsingToolbarLayout</code>随着滚动完成折叠之后就保留在界面上，不再移出屏幕</p></blockquote><blockquote><p><code>app:layout_collapseMode=&quot;pin&quot;</code> 把Toolbar指定成pin，表示在折叠的过程中位置始终保持不变</p></blockquote><blockquote><p><code>app:layout_collapseMode=&quot;parallax&quot;</code> ImageView 指定成 parallax，表示会在折叠得过程中产生一定得错位偏移，这种模式得视觉效果会非常好</p></blockquote><blockquote><p><code>NestedScrollView</code> ：在ScrollView基础上增加了嵌套响应滚动事件得功能</p></blockquote><h1 id="9-沉浸式状态栏"><a href="#9-沉浸式状态栏" class="headerlink" title="9. 沉浸式状态栏"></a>9. 沉浸式状态栏</h1><p>这个只是在Android5.0后才有的，设置状态栏为透明</p><p>在<code>setContentView();</code>之前添加代码：</p><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {    //透明状态栏    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);    //透明导航栏    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);}</code></pre><p>需要在直接子布局添加：<code>android:fitsSystemWindows=&quot;true</code> 表示该控件会出现在系统状态栏里</p><p>我的源码地址：<a href="https://github.com/xiaweizi/MaterialDesign" target="_blank" rel="noopener">https://github.com/xiaweizi/MaterialDesign</a></p><p><a href="http://xiaweizi.cn">我的博客</a></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Material Design </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于LitePal操作数据库的学生管理系统的简单实现</title>
      <link href="/article/2954/"/>
      <content type="html"><![CDATA[<h4 id="今天看了郭神的《第二行代码》的第六章，才发现LitePal用起来是多么方便简介，就花了下午的时间做了一个小Demo，界面功能都简单，请见谅"><a href="#今天看了郭神的《第二行代码》的第六章，才发现LitePal用起来是多么方便简介，就花了下午的时间做了一个小Demo，界面功能都简单，请见谅" class="headerlink" title="今天看了郭神的《第二行代码》的第六章，才发现LitePal用起来是多么方便简介，就花了下午的时间做了一个小Demo，界面功能都简单，请见谅"></a>今天看了郭神的《第二行代码》的第六章，才发现LitePal用起来是多么方便简介，就花了下午的时间做了一个小Demo，界面功能都简单，请见谅</h4><hr><p><em>本文只是LitePal的简单应用，目的是快速入门LitePal。界面和功能都简单，若不满，请自行添加。</em></p><a id="more"></a><p>照例来波动态图<br><img src="http://upload-images.jianshu.io/upload_images/4043475-0fff41c510bbc5c6.gif?imageMogr2/auto-orient/strip" alt="学生管理应用.gif"></p><blockquote><p>主要功能就是: 数据的 <strong>增、删、改、查</strong>。</p><p>主要知识点: <strong>LitePal的配置和使用</strong></p><p>界面我就不介绍了，用的是RecyclerView之前也讲过 <a href="http://www.jianshu.com/p/60819de9eb42" target="_blank" rel="noopener">简单粗暴—-RecyclerView</a></p><p>首先添加依赖 </p></blockquote><pre><code>compile&apos;com.android.support:recyclerview-v7:24.0.0&apos;compile &apos;org.litepal.android:core:1.4.1&apos;</code></pre><h1 id="1-LitePal简介"><a href="#1-LitePal简介" class="headerlink" title="1. LitePal简介"></a>1. LitePal简介</h1><p>LitePal是一款开源的Android数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用的一些数据库功能进行了封装，是的不用编写一行SQL语句就可以完成各种建表和增删改查的操作。</p><h1 id="2-LitePal的配置"><a href="#2-LitePal的配置" class="headerlink" title="2. LitePal的配置"></a>2. LitePal的配置</h1><p>创建一个 <code>assets</code> 目录，在 <code>assets</code> 目录下新建一个 <code>litepal.xml</code> 文件，接着编写文件内容，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;litepal&gt;    &lt;!-- 数据库名 --&gt;    &lt;dbname value=&quot;Student&quot;&gt;&lt;/dbname&gt;    &lt;!-- 版本号 --&gt;    &lt;version value=&quot;1&quot;&gt;&lt;/version&gt;    &lt;!-- 创建表 --&gt;    &lt;list&gt;        &lt;mapping class=&quot;映射的javaBean的完整类名&quot;&gt;&lt;/mapping&gt;    &lt;/list&gt;&lt;/litepal&gt;</code></pre><p>接下来修改清单文件代码，配置Application</p><pre><code>&lt;application    android:name=&quot;org.litepal.LitePalApplication&quot;    ...&lt;/application&gt;</code></pre><p>最后代码中创建数据库</p><pre><code>LitePal.getDatabase();</code></pre><h1 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h1><h4 id="a-需要一个JavaBean对象，也就是数据库的表"><a href="#a-需要一个JavaBean对象，也就是数据库的表" class="headerlink" title="a. 需要一个JavaBean对象，也就是数据库的表"></a>a. 需要一个JavaBean对象，也就是数据库的表</h4><hr><pre><code>public class Student extends DataSupport{    private int id;    private String name;//姓名    private int studentId;//学号    private String sex;//性别    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getStudentId() {        return studentId;    }    public void setStudentId(int studentId) {        this.studentId = studentId;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }}</code></pre><h4 id="b-修改litepal-xml中的代码"><a href="#b-修改litepal-xml中的代码" class="headerlink" title="b. 修改litepal.xml中的代码"></a>b. 修改litepal.xml中的代码</h4><hr><pre><code>&lt;list&gt;    &lt;mapping class=&quot;com.xiaweizi.studentsystem.Student&quot;&gt;&lt;/mapping&gt;&lt;/list&gt;</code></pre><blockquote><p>运行一下程序，然后你就可以在data/data/包名的文件下看到数据库已经创建了：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-7d01854c495230ad.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库.PNG"></p><blockquote><p>然后把他导出来，借用工具打开，然后就是下面界面</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-3e4c37de6dcd5cdb.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表的创建.PNG"></p><h1 id="4-增、删、改、查"><a href="#4-增、删、改、查" class="headerlink" title="4. 增、删、改、查"></a>4. 增、删、改、查</h1><h3 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="1. 添加数据"></a>1. 添加数据</h3><pre><code>Student student = new Student();student.setName(name);student.setSex(sex);student.setStudentId(Integer.parseInt(studentId));student.save();</code></pre><p>效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/4043475-bf48d4c2d74d168e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加数据.PNG"></p><h3 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2. 删除数据"></a>2. 删除数据</h3><pre><code>DataSupport.deleteAll(Student.class, &quot;id = ?&quot;, id +&quot;&quot;);</code></pre><blockquote><p>一行代码搞定，只要调用<code>DataSupport.deleteAll()</code>即可，第一参数，是要删除哪张表的数据，后面则为约束条件，不难看懂。</p></blockquote><h3 id="3-修改数据"><a href="#3-修改数据" class="headerlink" title="3. 修改数据"></a>3. 修改数据</h3><pre><code>Student student = new Student();student.setName(name);student.setSex(sex);student.setStudentId(Integer.parseInt(studentId));student.updateAll(&quot;id = ?&quot;, id+&quot;&quot;);</code></pre><blockquote><p>还是要new一个实例，然后要设置更新的数据，最后调用<code>updateAll()</code>方法执行更新操作。参数跟删除数据很像，也是约束条件，如果不传参数，则修改所有的数据。</p></blockquote><blockquote><p>这里需要注意一点，如果想让数据恢复成默认值，<strong>是不能直接设置默认值的。</strong></p><p>比如，如果让学号为0，是不能 <code>student.setStudentId(0);</code> 这是错误的！！！那么如果想恢复成默认值该怎么办呢，LitePal提供了<code>setToDefault()</code> 方法。</p></blockquote><pre><code>  Student student = new Student();student.setToDefault(&quot;studentId&quot;);student.updateAll();</code></pre><h3 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="4. 查询数据"></a>4. 查询数据</h3><pre><code>mList = DataSupport.findAll(Student.class);</code></pre><blockquote><p>一行代码搞定，直接就可以查询数据库中Student表的所有数据，返回这个对象的集合。<br>借用工具可以查看我们的所有数据：<br><img src="http://upload-images.jianshu.io/upload_images/4043475-436d22171cb8b0d0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="所有数据.PNG"></p></blockquote><p>到此一个简单的学生管理系统已经结束了，主要目的就是快速入门LitePal！</p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方库 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于环信的仿QQ即时通讯的简单实现</title>
      <link href="/article/276/"/>
      <content type="html"><![CDATA[<p><em><a href="http://xiaweizi.cn/">我的博客地址</a></em></p><h4 id="之前一直想实现聊天的功能，但是感觉有点困难，今天看了环信的API，就利用下午的时间动手试了试，然后做了一个小Demo。"><a href="#之前一直想实现聊天的功能，但是感觉有点困难，今天看了环信的API，就利用下午的时间动手试了试，然后做了一个小Demo。" class="headerlink" title="之前一直想实现聊天的功能，但是感觉有点困难，今天看了环信的API，就利用下午的时间动手试了试，然后做了一个小Demo。"></a>之前一直想实现聊天的功能，但是感觉有点困难，今天看了环信的API，就利用下午的时间动手试了试，然后做了一个小Demo。</h4><h4 id="因为没有刻意去做聊天软件，花的时间也不多，然后界面就很简单，都是一些基本知识，如果觉得功能简单，可以自行添加，我这就不多介绍了。"><a href="#因为没有刻意去做聊天软件，花的时间也不多，然后界面就很简单，都是一些基本知识，如果觉得功能简单，可以自行添加，我这就不多介绍了。" class="headerlink" title="因为没有刻意去做聊天软件，花的时间也不多，然后界面就很简单，都是一些基本知识，如果觉得功能简单，可以自行添加，我这就不多介绍了。"></a>因为没有刻意去做聊天软件，花的时间也不多，然后界面就很简单，都是一些基本知识，如果觉得功能简单，可以自行添加，我这就不多介绍了。</h4><a id="more"></a><p>照例先来一波动态演示：<br><img src="http://upload-images.jianshu.io/upload_images/4043475-d16a88926805236a.gif?imageMogr2/auto-orient/strip" alt="环信及时聊天.gif"></p><blockquote><p>功能很简单，注册用户 –&gt; 用户登录 –&gt; 选择聊天对象 –&gt; 开始聊天</p></blockquote><blockquote><p>使用到的知识点：</p></blockquote><ol><li><code>RecyclerView</code></li><li><code>CardView</code></li><li>环信的API的简单使用</li></ol><blockquote><p>依赖的库</p><pre><code>compile &apos;com.android.support:appcompat-v7:24.2.1&apos;compile &apos;com.android.support:cardview-v7:24.1.1&apos;compile &apos;com.android.support:recyclerview-v7:24.0.0&apos;    </code></pre></blockquote><h2 id="1、聊天页面"><a href="#1、聊天页面" class="headerlink" title="1、聊天页面"></a>1、聊天页面</h2><p><em>首先是看了郭神的《第二行代码》做了聊天界面，用的是RecyclerView</em></p><h4 id="a-消息类的封装"><a href="#a-消息类的封装" class="headerlink" title="a.  消息类的封装"></a>a.  消息类的封装</h4><hr><pre><code>public class MSG {    public static final int TYPE_RECEIVED = 0;//消息的类型:接收    public static final int TYPE_SEND = 1;    //消息的类型:发送    private String content;//消息的内容    private int type;       //消息的类型    public MSG(String content, int type) {        this.content = content;        this.type = type;    }    public String getContent() {        return content;    }    public int getType() {        return type;    }}</code></pre><h4 id="b-RecyclerView子项的布局"><a href="#b-RecyclerView子项的布局" class="headerlink" title="b.    RecyclerView子项的布局"></a>b.    RecyclerView子项的布局</h4><hr><pre><code>&lt;LinearLayout    android:id=&quot;@+id/ll_msg_left&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    &lt;!-- 设置点击效果为水波纹(5.0以上) --&gt;    android:background=&quot;?android:attr/selectableItemBackground&quot;    android:clickable=&quot;true&quot;    android:focusable=&quot;true&quot;    android:orientation=&quot;horizontal&quot;    android:padding=&quot;2dp&quot;&gt;    &lt;android.support.v7.widget.CardView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:cardCornerRadius=&quot;20dp&quot;        app:cardPreventCornerOverlap=&quot;false&quot;        app:cardUseCompatPadding=&quot;true&quot;&gt;        &lt;ImageView            android:layout_width=&quot;50dp&quot;            android:layout_height=&quot;50dp&quot;            android:scaleType=&quot;centerCrop&quot;            android:src=&quot;@mipmap/man&quot; /&gt;    &lt;/android.support.v7.widget.CardView&gt;    &lt;LinearLayout        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@drawable/message_left&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;TextView            android:id=&quot;@+id/tv_msg_left&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;center&quot;            android:layout_margin=&quot;10dp&quot;            android:textColor=&quot;#fff&quot; /&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;</code></pre><blockquote><p>这是左边的部分，至于右边应该也就简单了。我用CardView把ImageView包裹起来，这样比较好看。效果如下：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-76ea5370b4d09d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="item布局.png"></p><h4 id="c-RecyclerView适配器"><a href="#c-RecyclerView适配器" class="headerlink" title="c.    RecyclerView适配器"></a>c.    RecyclerView适配器</h4><hr><pre><code>    public class MsgAdapter extends RecyclerView.Adapter&lt;MsgAdapter.MyViewHolder&gt; {    private List&lt;MSG&gt; mMsgList;    public MsgAdapter(List&lt;MSG&gt; mMsgList) {        this.mMsgList = mMsgList;    }    @Override    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {        View view = View.inflate(parent.getContext(), R.layout.item_msg, null);        MyViewHolder holder = new MyViewHolder(view);        return holder;    }    @Override    public void onBindViewHolder(MyViewHolder holder, int position) {        MSG msg = mMsgList.get(position);        if (msg.getType() == MSG.TYPE_RECEIVED){            //如果是收到的消息，显示左边布局，隐藏右边布局            holder.llLeft.setVisibility(View.VISIBLE);            holder.llRight.setVisibility(View.GONE);            holder.tv_Left.setText(msg.getContent());        } else if (msg.getType() == MSG.TYPE_SEND){            //如果是发送的消息，显示右边布局，隐藏左边布局            holder.llLeft.setVisibility(View.GONE);            holder.llRight.setVisibility(View.VISIBLE);            holder.tv_Right.setText(msg.getContent());        }    }    @Override    public int getItemCount() {        return mMsgList.size();    }    static class MyViewHolder extends RecyclerView.ViewHolder{        LinearLayout llLeft;        LinearLayout llRight;        TextView tv_Left;        TextView tv_Right;        public MyViewHolder(View itemView) {            super(itemView);            llLeft = (LinearLayout) itemView.findViewById(R.id.ll_msg_left);            llRight = (LinearLayout) itemView.findViewById(R.id.ll_msg_right);            tv_Left = (TextView) itemView.findViewById(R.id.tv_msg_left);            tv_Right = (TextView) itemView.findViewById(R.id.tv_msg_right);        }    }}</code></pre><blockquote><p>这部分应该也没什么问题，就是适配器的创建，我之前的文章也讲过 传送门：<a href="http://www.jianshu.com/p/60819de9eb42" target="_blank" rel="noopener">简单粗暴—-RecyclerView</a></p></blockquote><h4 id="d-RecyclerView初始化"><a href="#d-RecyclerView初始化" class="headerlink" title="d.    RecyclerView初始化"></a>d.    RecyclerView初始化</h4><hr><p>就是一些基本的初始化，我就不赘述了，讲一下添加数据的细节处理</p><pre><code>btSend.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        String content = etInput.getText().toString().trim();        if (!TextUtils.isEmpty(content)){            ...//环信部分的发送消息            MSG msg = new MSG(content, MSG.TYPE_SEND);            mList.add(msg);            //当有新消息时，刷新RecyclerView中的显示            mAdapter.notifyItemInserted(mList.size() - 1);            //将RecyclerView定位到最后一行            mRecyclerView.scrollToPosition(mList.size() - 1);            etInput.setText(&quot;&quot;);        }    }});</code></pre><blockquote><p>至此界面已经结束了，接下来就是数据的读取</p></blockquote><h2 id="2-环信API的简单应用"><a href="#2-环信API的简单应用" class="headerlink" title="2. 环信API的简单应用"></a>2. 环信API的简单应用</h2><p><em>官网有详细的API介绍 <a href="http://docs.easemob.com/im/start" title="集成" target="_blank" rel="noopener">环信及时通讯V3.0</a>，我这里就简单介绍如何简单集成</em></p><h4 id="a-环信开发账号的注册"><a href="#a-环信开发账号的注册" class="headerlink" title="a.    环信开发账号的注册"></a>a.    环信开发账号的注册</h4><hr><p><a href="http://www.easemob.com/" target="_blank" rel="noopener">环信官网</a></p><blockquote><p>创建应用得到Appkey后面要用<br><img src="http://upload-images.jianshu.io/upload_images/4043475-e4dd45e05060467f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="环信注册.PNG"></p></blockquote><h4 id="b-SDK导入"><a href="#b-SDK导入" class="headerlink" title="b.    SDK导入"></a>b.    SDK导入</h4><hr><p>你可以直接下载然后拷贝工程的libs目录下</p><p>Android Studio可以直接添加依赖</p><blockquote><p>将以下代码放到项目根目录的build.gradle文件里</p></blockquote><pre><code>repositories {        maven { url &quot;https://raw.githubusercontent.com/HyphenateInc/Hyphenate-SDK-Android/master/repository&quot; }}</code></pre><blockquote><p>在你的module的build.gradle里加入以下代码</p></blockquote><pre><code>android {    //use legacy for android 6.0    useLibrary &apos;org.apache.http.legacy&apos;}dependencies {    compile &apos;com.android.support:appcompat-v7:23.4.0&apos;    //Optional compile for GCM (Google Cloud Messaging).    compile &apos;com.google.android.gms:play-services-gcm:9.4.0&apos;    compile &apos;com.hyphenate:hyphenate-sdk:3.2.3&apos;}</code></pre><blockquote><p>如果想使用不包含音视频通话的sdk，用<code>compile &#39;com.hyphenate:hyphenate-sdk-lite:3.2.3&#39;</code></p></blockquote><h4 id="c-清单文件配置"><a href="#c-清单文件配置" class="headerlink" title="c.    清单文件配置"></a>c.    清单文件配置</h4><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;Your Package&quot;    android:versionCode=&quot;100&quot;    android:versionName=&quot;1.0.0&quot;&gt;    &lt;!-- Required --&gt;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_MOCK_LOCATION&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt;      &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;    &lt;application        android:icon=&quot;@drawable/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:name=&quot;Your Application&quot;&gt;    &lt;!-- 设置环信应用的AppKey --&gt;        &lt;meta-data android:name=&quot;EASEMOB_APPKEY&quot;  android:value=&quot;Your AppKey&quot; /&gt;        &lt;!-- 声明SDK所需的service SDK核心功能--&gt;        &lt;service android:name=&quot;com.hyphenate.chat.EMChatService&quot; android:exported=&quot;true&quot;/&gt;        &lt;service android:name=&quot;com.hyphenate.chat.EMJobService&quot;            android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot;            android:exported=&quot;true&quot;            /&gt;        &lt;!-- 声明SDK所需的receiver --&gt;        &lt;receiver android:name=&quot;com.hyphenate.chat.EMMonitorReceiver&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot;/&gt;                &lt;data android:scheme=&quot;package&quot;/&gt;            &lt;/intent-filter&gt;            &lt;!-- 可选filter --&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;                &lt;action android:name=&quot;android.intent.action.USER_PRESENT&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/receiver&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>APP打包混淆</p><pre><code>-keep class com.hyphenate.** {*;}-dontwarn  com.hyphenate.**</code></pre><h4 id="d-初始化SDK"><a href="#d-初始化SDK" class="headerlink" title="d.    初始化SDK"></a>d.    初始化SDK</h4><hr><p><em>在自定义Application的onCreate中初始化</em></p><pre><code>public class MyApplication extends Application {    private Context appContext;    @Override    public void onCreate() {        super.onCreate();        EMOptions options = new EMOptions();        options.setAcceptInvitationAlways(false);        appContext = this;        int pid = android.os.Process.myPid();        String processAppName = getAppName(pid);        // 如果APP启用了远程的service，此application:onCreate会被调用2次        // 为了防止环信SDK被初始化2次，加此判断会保证SDK被初始化1次        // 默认的APP会在以包名为默认的process name下运行，如果查到的process name不是APP的process name就立即返回        if (processAppName == null || !processAppName.equalsIgnoreCase(appContext.getPackageName())) {            Log.e(&quot;---&gt;&quot;, &quot;enter the service process!&quot;);            // 则此application::onCreate 是被service 调用的，直接返回            return;        }        //初始化        EMClient.getInstance().init(getApplicationContext(), options);        //在做打包混淆时，关闭debug模式，避免消耗不必要的资源        EMClient.getInstance().setDebugMode(true);    }    private String getAppName(int pID) {        String processName = null;        ActivityManager am = (ActivityManager) this.getSystemService(ACTIVITY_SERVICE);        List l = am.getRunningAppProcesses();        Iterator i = l.iterator();        PackageManager pm = this.getPackageManager();        while (i.hasNext()) {            ActivityManager.RunningAppProcessInfo info = (ActivityManager.RunningAppProcessInfo) (i.next());            try {                if (info.pid == pID) {                    processName = info.processName;                    return processName;                }            } catch (Exception e) {                // Log.d(&quot;Process&quot;, &quot;Error&gt;&gt; :&quot;+ e.toString());            }        }        return processName;    }}</code></pre><h4 id="e-注册和登陆"><a href="#e-注册和登陆" class="headerlink" title="e.    注册和登陆"></a>e.    注册和登陆</h4><hr><p><em>注册要在子线程中执行</em></p><pre><code>//注册失败会抛出HyphenateExceptionEMClient.getInstance().createAccount(username, pwd);//同步方法EMClient.getInstance().login(userName,password,new EMCallBack() {//回调    @Override    public void onSuccess() {        EMClient.getInstance().groupManager().loadAllGroups();        EMClient.getInstance().chatManager().loadAllConversations();            Log.d(&quot;main&quot;, &quot;登录聊天服务器成功！&quot;);            }    @Override    public void onProgress(int progress, String status) {    }    @Override    public void onError(int code, String message) {        Log.d(&quot;main&quot;, &quot;登录聊天服务器失败！&quot;);    }});</code></pre><h4 id="f-发送消息"><a href="#f-发送消息" class="headerlink" title="f.    发送消息"></a>f.    发送消息</h4><hr><pre><code>//创建一条文本消息，content为消息文字内容，toChatUsername为对方用户或者群聊的id，后文皆是如此EMMessage message = EMMessage.createTxtSendMessage(content, toChatUsername);//发送消息EMClient.getInstance().chatManager().sendMessage(message);</code></pre><h4 id="g-接收消息"><a href="#g-接收消息" class="headerlink" title="g.    接收消息"></a>g.    接收消息</h4><hr><pre><code>msgListener = new EMMessageListener() {        @Override        public void onMessageReceived(List&lt;EMMessage&gt; messages) {            //收到消息            String result = messages.get(0).getBody().toString();            String msgReceived = result.substring(5, result.length() - 1);            Log.i(TAG, &quot;onMessageReceived: &quot; + msgReceived);            final MSG msg = new MSG(msgReceived, MSG.TYPE_RECEIVED);            runOnUiThread(new Runnable() {                @Override                public void run() {                    mList.add(msg);                    mAdapter.notifyDataSetChanged();                    mRecyclerView.scrollToPosition(mList.size() - 1);                }            });        }        @Override        public void onCmdMessageReceived(List&lt;EMMessage&gt; messages) {            //收到透传消息        }        @Override        public void onMessageRead(List&lt;EMMessage&gt; list) {        }        @Override        public void onMessageDelivered(List&lt;EMMessage&gt; list) {        }        @Override        public void onMessageChanged(EMMessage message, Object change) {            //消息状态变动        }    };</code></pre><blockquote><p>接收消息的监听器分别需要在OnResume()和OnDestory()方法中注册和取消注册</p></blockquote><pre><code>EMClient.getInstance().chatManager().addMessageListener(msgListener);//注册EMClient.getInstance().chatManager().removeMessageListener(msgListener);//取消注册</code></pre><blockquote><p>需要注意的是，当接收到消息，需要在<strong>主线程</strong>中更新适配器，否则会不能及时刷新出来</p></blockquote><p>到此，一个简单的及时聊天Demo已经完成，功能很简单，如果需要添加额外功能的话，可以自行参考官网，官网给出的教程还是很不错的！</p><p>最后希望大家能多多支持我，需要你们的支持喜欢！！</p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方库 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高大上的侧滑菜单DrawerLayout，解决了不能全屏滑动的问题</title>
      <link href="/article/7455/"/>
      <content type="html"><![CDATA[<h4 id="自从2014那年谷歌提出的Material-Design后，这种设计语言就广泛被程序猿使用，屡试不爽。在现如今的各个流行APP中，你都能发现它的身影。详细情况，自己百度吧，我只想说很装B。"><a href="#自从2014那年谷歌提出的Material-Design后，这种设计语言就广泛被程序猿使用，屡试不爽。在现如今的各个流行APP中，你都能发现它的身影。详细情况，自己百度吧，我只想说很装B。" class="headerlink" title="自从2014那年谷歌提出的Material Design后，这种设计语言就广泛被程序猿使用，屡试不爽。在现如今的各个流行APP中，你都能发现它的身影。详细情况，自己百度吧，我只想说很装B。"></a>自从2014那年谷歌提出的Material Design后，这种设计语言就广泛被程序猿使用，屡试不爽。在现如今的各个流行APP中，你都能发现它的身影。详细情况，自己百度吧，我只想说很装B。</h4><hr><a id="more"></a><p>####今天我就说一下其中的一个控件 DrawerLayout。在此之前，我一直用的是SlidingMenu，虽然体验也不错，但是也有一些bug…比如不能修改成沉浸式状态栏，后来有位大神跟我说如何修改，但对其印象就不是很好。当我接触到DrawerLayout，发现它用起来简单，方便，毕竟是谷歌亲儿子。</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-c6b4df995f7f075c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DrawerLayout预览"></p><p>####DrawerLayout主要功能就是 实现侧滑菜单效果的功能，并且可以通过增加一些设置来实现高大上的效果，那么就请看动态图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4043475-118894140cac3bca.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p>注意左上角那个图标，有木有很好玩，哈哈…</p></blockquote><h2 id="接下来就介绍如何实现这一功能"><a href="#接下来就介绍如何实现这一功能" class="headerlink" title="接下来就介绍如何实现这一功能"></a>接下来就介绍如何实现这一功能</h2><p>####1. 在项目对应的build.gradle中添加依赖</p><pre><code>dependencies {    ...//其他代码    compile &apos;com.android.support:appcompat-v7:24.0.0&apos;    compile &apos;com.android.support:design:24.0.0&apos;       ...//其他代码}</code></pre><p>####2. 添加ToolBar，创建toolbar.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;&gt;    &lt;android.support.v7.widget.Toolbar        android:id=&quot;@+id/toolbar&quot;        android:clipToPadding=&quot;true&quot;        android:fitsSystemWindows=&quot;true&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        app:title=&quot;资讯&quot;        app:titleTextColor=&quot;#fff&quot;&gt;    &lt;/android.support.v7.widget.Toolbar&gt;&lt;/RelativeLayout&gt;</code></pre><p>####3. 在main.xml中添加DrawerLayout    </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;!-- 添加ToolBar --&gt;    &lt;include layout=&quot;@layout/toolbar&quot;/&gt;    &lt;!--添加DrawerLayout--&gt;    &lt;android.support.v4.widget.DrawerLayout        android:id=&quot;@+id/drawerlayout&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;!-- 一般第一个位置的代表 主内容 --&gt;        &lt;FrameLayout            android:id=&quot;@+id/main&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;        &lt;/FrameLayout&gt;        &lt;!-- 左侧菜单(设置layout_gravity 为left) --&gt;        &lt;RelativeLayout            android:id=&quot;@+id/left&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_gravity=&quot;left&quot;&gt;        &lt;/RelativeLayout&gt;        &lt;!-- 右侧菜单(设置layout_gravity 为right) --&gt;        &lt;RelativeLayout            android:id=&quot;@+id/right&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_gravity=&quot;right&quot;&gt;        &lt;/RelativeLayout&gt;    &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/LinearLayout&gt;</code></pre><blockquote><p>DrawerLayout一般分为三个部分 主内容，左侧菜单，右侧菜单<br>每个部分的内容自行设置，我是采用Fragment方式设置内容，这里仅供参考</p></blockquote><pre><code>//新建Fragment，具体内容我就不详细说了fragmentMain = new FragmentMain();//添加内容，比较简单的getSupportFragmentManager().beginTransaction().replace(R.id.main, fragmentMain).commit();</code></pre><blockquote><p>到此为止已经初步实现了侧滑菜单的功能，来看一下效果</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-ddfb18ab465bd9e8.gif?imageMogr2/auto-orient/strip" alt="DrawerLayout初效果.gif"></p><p>##然后，就是给侧滑按钮添加效果了</p><p>####1. 在此之前要进行view的初始化</p><pre><code>mDrawerLayout = (DrawerLayout) findViewById(R.id.drawerlayout);toolbar = (Toolbar) this.findViewById(R.id.toolbar);setSupportActionBar(toolbar);</code></pre><p>####2. 通过ActionBarDrawerToggle来完成效果，操作很简单</p><pre><code>mToggle = new ActionBarDrawerToggle(HomeActivity.this,                                     mDrawerLayout,                                     toolbar,                                     R.string.open,                                      R.string.close);mToggle.syncState();mDrawerLayout.addDrawerListener(mToggle);</code></pre><blockquote><p>这样就结束了</p></blockquote><p>##最后就是解决DrawerLayout不能全屏滑动的问题</p><pre><code>private void setDrawerLeftEdgeSize (Activity activity, DrawerLayout drawerLayout, float displayWidthPercentage) {    if (activity == null || drawerLayout == null) return;    try {        // 找到 ViewDragHelper 并设置 Accessible 为true        Field leftDraggerField =                drawerLayout.getClass().getDeclaredField(&quot;mLeftDragger&quot;);//Right        leftDraggerField.setAccessible(true);        ViewDragHelper leftDragger = (ViewDragHelper) leftDraggerField.get(drawerLayout);        // 找到 edgeSizeField 并设置 Accessible 为true        Field edgeSizeField = leftDragger.getClass().getDeclaredField(&quot;mEdgeSize&quot;);        edgeSizeField.setAccessible(true);        int edgeSize = edgeSizeField.getInt(leftDragger);        // 设置新的边缘大小        Point displaySize = new Point();        activity.getWindowManager().getDefaultDisplay().getSize(displaySize);        edgeSizeField.setInt(leftDragger, Math.max(edgeSize, (int) (displaySize.x *                displayWidthPercentage)));    } catch (NoSuchFieldException e) {    } catch (IllegalArgumentException e) {    } catch (IllegalAccessException e) {    }}</code></pre><blockquote><p>直接调用这个方法即可！最后一个参数 传 1，即可实现全屏滑动。如果你想让右侧菜单也是全屏，只要将对应的 “mLeftDragger” 改为 “mRightDragger”。</p></blockquote><p><em><a href="http://blog.csdn.net/qq_22656383/article/details/54171112" target="_blank" rel="noopener">我的博客地址</a></em><br>再次感谢那些给我提供帮助的文章，博客和人！！我会努力的！！</p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Material Design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单粗暴----RecyclerView</title>
      <link href="/article/7798/"/>
      <content type="html"><![CDATA[<p>###RecyclerView初步使用，下拉刷新，点击事件</p><hr><p>###本篇文章只是给初次使用RecyclerView的兄弟一个简单的入门使用步骤。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/4043475-7ff5227d2f9e52f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RecyclerView预览"></p><p>###现如今，RecyclerView已经逐渐开始代替 ListView 和 GridView,只需要一步，就可以实现ListView 和 GridView 之间的切换，后面会叙述。当我们还在为ListView优化烦恼的时候，RecyclerView已经帮你封装好了，使用起来也很简单。</p><blockquote><p><strong><em>先看一下运行结果</em></strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-07f75443b572daa6.gif?imageMogr2/auto-orient/strip" alt=""></p><h2 id="1-初步使用"><a href="#1-初步使用" class="headerlink" title="1.初步使用"></a>1.初步使用</h2><h5 id="1-布局添加控件"><a href="#1-布局添加控件" class="headerlink" title="1. 布局添加控件"></a>1. 布局添加控件</h5><pre><code>&lt;android.support.v7.widget.RecyclerView    android:id=&quot;@+id/rv&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;     &lt;/android.support.v7.widget.RecyclerView&gt;</code></pre><h5 id="2-代码完成设置"><a href="#2-代码完成设置" class="headerlink" title="2. 代码完成设置"></a>2. 代码完成设置</h5><pre><code>rv = (RecyclerView) view.findViewById(R.id.rv);//新建适配器adapter = new MyNewsDataAdapter(MainActivity.this);//设置布局管理器(下面三种任选其中一个)//1. ListViewrv.setLayoutManager(new LinearLayoutManager(        MainActivity.this,                //上下文        LinearLayoutManager.VERTICAL,    //设置布局方向(垂直）        false));                        //是否翻转//2. GridViewrv.setLayoutManager(new GridLayoutManager(        MainActivity.this,                //上下文        3,                                //列或者行的数量        LinearLayoutManager.VERTICAL,    //布局方向        false                            //是否翻转));//3. 瀑布流rv.setLayoutManager(new StaggeredGridLayoutManager(        3,                                //如果方向垂直则代表列，否则代表行        StaggeredGridLayoutManager.VERTICAL//布局方向));//设置适配器rv.setAdapter(adapter);//添加数据到适配器中，(这个方法在适配器中)adapter.addDataToAdapter(dataBeens, true);</code></pre><h5 id="3-剩下就是适配器的设置"><a href="#3-剩下就是适配器的设置" class="headerlink" title="3. 剩下就是适配器的设置"></a>3. 剩下就是适配器的设置</h5><pre><code>1. 新建类继承自RecyclerView.Adapter&lt;MyNewsDataAdapter.MyViewHolder&gt;，此时会报红，那是因为要实现必须实现的方法。但是在实现方法之前，要创建一个继承自RecyclerView.ViewHolder的类。在里面声明，item的控件，并进行findViewById，找到对应xml中idclass MyViewHolder extends RecyclerView.ViewHolder {        public TextView  content;        public TextView  title;        public TextView  time;        public ImageView icon;        public MyViewHolder (View itemView) {            super(itemView);            content = (TextView) itemView.findViewById(R.id.tv_content);            title = (TextView) itemView.findViewById(R.id.tv_title);            icon = (ImageView) itemView.findViewById(R.id.iv_icon);            time = (TextView) itemView.findViewById(R.id.tv_time);            }    } 2. 创建构造函数，传入上下文，初始化数据public MyNewsDataAdapter (Context context) {        Log.i(TAG, &quot;MyAdapter: 初始化&quot;);        mDatas = new ArrayList&lt;&gt;();        this.context = context;    }  3. 创建方法传入数据到适配器中    /**     * 传入数据到适配器中，并判断是否清除老数据     * @param datas         传入的数据     * @param isClearOld    是否清除老数据     */    public void addDataToAdapter(List&lt;NewsData.DataBean&gt; datas, boolean isClearOld){        if (datas != null){            if (isClearOld){                mDatas.clear();            }            mDatas.addAll(datas);        }    } 4. 接下来，就是完成所需要实现的方法    a. getItemCount 返回数据的数量    @Override        public int getItemCount () {            return mDatas.size();        }    b. onCreateViewHolder 主要是自定义ViewHolder的初始化，并返回出去     @Override        public MyViewHolder onCreateViewHolder (ViewGroup parent, int viewType) {            View         view   = View.inflate(context, R.layout.item_news_data, null);            MyViewHolder holder = new MyViewHolder(view);                    return holder;        }    c. onBindViewHolder 这里就是给控件设置值    @Override        public void onBindViewHolder (MyViewHolder holder, final int position) {                      //获取数据            NewsData.DataBean dataBean = mDatas.get(position);            String            title    = dataBean.getTitle();            String            summary  = dataBean.getSummary();            String            iconUrl  = dataBean.getIcon();            String            stamp    = dataBean.getStamp();            //加载数据            holder.content.setText(summary);            holder.title.setText(title);            holder.time.setText(stamp);            /*使用Glide框架加载图片*/            Glide.with(context).load(iconUrl).into(holder.icon);        }</code></pre><p>###这个时候就大功告成了看一下运行结构，使用垂直ListView，其他方式就自己尝试把。<br><img src="http://upload-images.jianshu.io/upload_images/4043475-0de9ab408fee4f6a.gif?imageMogr2/auto-orient/strip" alt=""></p><blockquote><p>适配器里面代码虽然看起来有点多，但是只要使用过ListView的肯定能看懂，并且可以根据自己需求进行代码的删减。</p></blockquote><h2 id="2-RecyclerView下拉刷新"><a href="#2-RecyclerView下拉刷新" class="headerlink" title="2.RecyclerView下拉刷新"></a>2.RecyclerView下拉刷新</h2><p>###使用(SwipeRefreshLayout + RecyclerView)方式实现简单的下拉刷新</p><h5 id="1-在布局添加"><a href="#1-在布局添加" class="headerlink" title="1. 在布局添加"></a>1. 在布局添加</h5><pre><code>&lt;android.support.v4.widget.SwipeRefreshLayout        android:id=&quot;@+id/srl&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;android.support.v7.widget.RecyclerView            android:id=&quot;@+id/rv&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;                                           &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</code></pre><h5 id="2-在代码添加"><a href="#2-在代码添加" class="headerlink" title="2. 在代码添加"></a>2. 在代码添加</h5><pre><code>srl = (SwipeRefreshLayout) view.findViewById(R.id.srl);srl.setColorSchemeColors(Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW);//设置进度框颜色的切换srl.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {    @Override    public void onRefresh () {        srl.setRefreshing(false);//取消进度框        Toast.makeText(getActivity(), &quot;刷新成功&quot;, Toast.LENGTH_SHORT).show();    }});</code></pre><blockquote><p>就这么简单，来看一下效果</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4043475-6e5adf37203df250.gif?imageMogr2/auto-orient/strip" alt=""></p><h2 id="3-RecyclerView点击事件"><a href="#3-RecyclerView点击事件" class="headerlink" title="3.RecyclerView点击事件"></a>3.RecyclerView点击事件</h2><blockquote><p>RecyclerView是没有像ListView那样的点击事件的。啥？！！这个时候别慌，我们完全可以自己设置，正好顺便复习一下 <strong>java的回调机制</strong></p></blockquote><h5 id="1-在适配器中创建一个接口，定义两个方法"><a href="#1-在适配器中创建一个接口，定义两个方法" class="headerlink" title="1. 在适配器中创建一个接口，定义两个方法"></a>1. 在适配器中创建一个接口，定义两个方法</h5><pre><code>public interface OnRecyclerViewItemClickLisetener {            void onItemClick(View view, int position);       void onItemLongClick(View view, int position);}</code></pre><h5 id="2-在适配器中定义私有监听器"><a href="#2-在适配器中定义私有监听器" class="headerlink" title="2. 在适配器中定义私有监听器"></a>2. 在适配器中定义私有监听器</h5><pre><code>private OnRecyclerViewItemClickLisetener mListener = null;</code></pre><h5 id="3-在onBindViewHolder-方法中，给每个itemView设置点击事件，当itemView被点击的时候，回调自己定义接口，并将位置也传过去，类似，listview的onItemClickListener"><a href="#3-在onBindViewHolder-方法中，给每个itemView设置点击事件，当itemView被点击的时候，回调自己定义接口，并将位置也传过去，类似，listview的onItemClickListener" class="headerlink" title="3. 在onBindViewHolder()方法中，给每个itemView设置点击事件，当itemView被点击的时候，回调自己定义接口，并将位置也传过去，类似，listview的onItemClickListener."></a>3. 在onBindViewHolder()方法中，给每个itemView设置点击事件，当itemView被点击的时候，回调自己定义接口，并将位置也传过去，类似，listview的onItemClickListener.</h5><pre><code>holder.itemView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick (View v) {                mListener.onItemClick(v, position);            }        });holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {    @Override    public boolean onLongClick (View v) {        mListener.onItemLongClick(v, position);        return true;    }});</code></pre><h5 id="4-暴露一个方法，给使用者设置监听器"><a href="#4-暴露一个方法，给使用者设置监听器" class="headerlink" title="4. 暴露一个方法，给使用者设置监听器"></a>4. 暴露一个方法，给使用者设置监听器</h5><pre><code>public void setOnClickListener(OnRecyclerViewItemClickLisetener listener){        mListener = listener; }</code></pre><h5 id="5-最后使用就简单了"><a href="#5-最后使用就简单了" class="headerlink" title="5. 最后使用就简单了"></a>5. 最后使用就简单了</h5><pre><code>adapter.setOnClickListener(new MyNewsDataAdapter.OnRecyclerViewItemClickLisetener() {    @Override    public void onItemClick (View view, int position) {        Toast.makeText(MainActivity.this, position + &quot;位置&quot; + &quot;被点击了&quot;, Toast.LENGTH_SHORT).show();    }    @Override    public void onItemLongClick (View view, int position) {        Toast.makeText(MainActivity.this, position + &quot;位置&quot; + &quot;被长时间点击了&quot;, Toast.LENGTH_SHORT).show();    } });</code></pre><p>###看一下结果<br><img src="http://upload-images.jianshu.io/upload_images/4043475-737148dd65549f7e.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Material Design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之建造者模式学习笔记</title>
      <link href="/article/23091/"/>
      <content type="html"><![CDATA[<p><em><a href="http://xiaweizi.cn/">我的博客地址</a></em></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>主要参考了 /<em><a href="http://blog.csdn.net/bingjianit" target="_blank" rel="noopener">冰鉴</a></em>/ 的一篇博客，觉得写的很详细，然后自己敲了一遍。学习了 <strong>设计模式之建造者模式</strong>， 并做了一些笔记。</p></blockquote><a id="more"></a><h4 id="建造者模式简介"><a href="#建造者模式简介" class="headerlink" title="建造者模式简介"></a>建造者模式简介</h4><p>建造者模式(Buidler Pattern)又叫生成器模式， <strong>将一个复杂对象的构建和它的表示分离开,使得同样的构建过程可以创建不同的表示。</strong></p><h4 id="建造者模式有点"><a href="#建造者模式有点" class="headerlink" title="建造者模式有点"></a>建造者模式有点</h4><ol><li>封装性：不必知道实现的细节，直接得到产品</li><li>扩展性：Builder类相互独立，方便以后扩展</li><li>安全性：每个产品相互独立，建造的过程不会对其他产生影响</li></ol><h3 id="建造模式步骤以及实现"><a href="#建造模式步骤以及实现" class="headerlink" title="建造模式步骤以及实现"></a>建造模式步骤以及实现</h3><ol><li><p>创建产品类，是所有产品的父类。可以产生一个或多个产品，但是实现的接口可以完全不相关。</p><pre><code>   public class Person {    private String name;    //姓名    private int age;        //年龄    private String work;    //工作    public String getWork () {        return work;    }    public void setWork (String work) {        this.work = work;    }    public String getName () {        return name;    }    public void setName (String name) {        this.name = name;    }    public int getAge () {        return age;    }    public void setAge (int age) {        this.age = age;    }}</code></pre></li><li><p>由父类生成两个子产品<br> ###Student:</p><pre><code>public class Student extends Person {    private String sex = &quot;man&quot;;     //性别    public Student () {        this.setWork(&quot;student&quot;);    }    public String getSex () {        return sex;    }    public void setSex (String sex) {        this.sex = sex;    }    @Override    public String toString () {        return &quot;职业:\t&quot; + this.getWork() +                &quot;\n性别:\t&quot; + this.getSex() +                &quot;\n姓名:\t&quot; + this.getName() +                &quot;\n年龄:\t&quot; + this.getAge();    }}    </code></pre><p> ###Teather</p><pre><code>public class Teatcher extends Person {    private String sex;     //性别    public Teatcher () {        this.setWork(&quot;teacher&quot;);    }    public String getSex () {        return sex;    }    public void setSex (String sex) {        this.sex = sex;    }    @Override    public String toString () {        return &quot;职业:\t&quot; + this.getWork() +                &quot;\n性别:\t&quot; + this.getSex() +                &quot;\n姓名:\t&quot; + this.getName() +                &quot;\n年龄:\t&quot; + this.getAge();    }}</code></pre></li><li><p>创建接口，其中声明生产产品需要的方法</p><pre><code>public interface PersonBuilder {    void buildName();   //制造姓名    void buildAge();    //制造年龄    void buildSex();    //制造性别    Person getResult(); //返回产品}</code></pre></li><li><p>创建具体的建造类，开始生产产品啦…<br> ###制造学生</p><pre><code>public class StudentBuilder implements PersonBuilder {    private Student stu = new Student();    @Override    public void buildName () {        stu.setName(&quot;a&quot;);    }    @Override    public void buildAge () {        stu.setAge(12);    }    @Override    public void buildSex () {        stu.setSex(&quot;man&quot;);    }    @Override    public Person getResult () {        return stu;    }}</code></pre><p> ###制造教师</p><pre><code>public class TeatcherBuilder implements PersonBuilder {    private Teatcher teatcher = new Teatcher();    @Override    public void buildName () {        teatcher.setName(&quot;b&quot;);    }    @Override    public void buildAge () {        teatcher.setAge(23);    }    @Override    public void buildSex () {        teatcher.setSex(&quot;woman&quot;);    }    @Override    public Person getResult () {        return teatcher;    }}</code></pre></li><li><p>创建导演类，将制造过程放进去</p><pre><code>public class PersonDirector {    private PersonBuilder builder;    //制造学生    public Student constructStudent(){        builder = new StudentBuilder();        builder.buildAge();        builder.buildName();        builder.buildSex();        //产品生产完成，将产品返回出去        return (Student) builder.getResult();    }    //制造老师    public Teatcher constructTeacher(){        builder = new TeatcherBuilder();        builder.buildAge();        builder.buildName();        builder.buildSex();        return (Teatcher) builder.getResult();    }}</code></pre></li><li><p>最后进行测试，看能不能创建成功</p><pre><code>PersonDirector director = new PersonDirector();//生产学生Student student = director.constructStudent();Log.i(TAG, student.toString());//生产老师Teatcher teatcher = director.constructTeacher();Log.i(TAG, teatcher.toString());</code></pre><blockquote><p>结果打印</p></blockquote><pre><code>01-04 14:10:31.907 2565-2565/xiaweizi.com.net I/MainActivity---&gt;: 职业:    student                                                                  性别:    man                                                                  姓名:    a                                                                  年龄:    1201-04 14:10:31.907 2565-2565/xiaweizi.com.net I/MainActivity---&gt;: 职业:    teacher                                                                  性别:    woman                                                                  姓名:    b                                                                  年龄:    23</code></pre><p>####其实Dialog的链式使用可以采用建造者模式来完成</p><p> public class MyDialog {</p><pre><code>//警告框标题private String title;//警告框图标资源IDprivate int iconId;//上线文private Context context;public String getTitle () {    return title;}public int getIconId () {    return iconId;}public Context getContext () {    return context;}public static class Builder{    //给自己的dialog设置默认内容    private String title = &quot;title&quot;;    private int iconId = 0;    private Context context;    public Builder (Context context) {        this.context = context;    }    public Builder setTitle(String title){        this.title = title;        return this;    }    public Builder setIconId(int iconId){        this.iconId = iconId;        return this;    }    //应用自己的配置    private void applyConfig(MyDialog myDialog){        myDialog.title = title;        myDialog.iconId = iconId;        myDialog.context = context;    }    public MyDialog show(){        MyDialog myDialog = new MyDialog();        applyConfig(myDialog);        return myDialog;    }}</code></pre><p> }</p></li></ol><p>#######使用就简单了<br>    MyDialog myDialog =<br>                    new MyDialog.Builder(this).setTitle(“标题”).setIconId(R.mipmap.ic_launcher).show();</p><blockquote><p>最后还是很感谢 <em><a href="http://blog.csdn.net/bingjianit/article/details/53607856" target="_blank" rel="noopener">大神的文章</a></em>，本篇文章作为个人笔记，有点局限，易于理解，方便事后查看。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个菜鸟的图片三级缓存笔记</title>
      <link href="/article/17984/"/>
      <content type="html"><![CDATA[<p><em>先附上我的源码Github地址<br><a href="https://github.com/xiaweizi/ImageCache.git" target="_blank" rel="noopener">https://github.com/xiaweizi/ImageCache.git</a></em></p><p><em><a href="http://xiaweizi.cn/">我的博客地址</a></em></p><a id="more"></a><h5 id="图片的缓存虽然现在已经有不少的框架，但是我还是想自己学习一下图片的缓存机制。图片缓存的大概逻辑就是：当需要获取图片的时候，首先判断内存是否有，有—加载，无—从本地中获取图片，有–加载，无–从网络中下载，然后缓存到内存和本地中。大概流程图如下："><a href="#图片的缓存虽然现在已经有不少的框架，但是我还是想自己学习一下图片的缓存机制。图片缓存的大概逻辑就是：当需要获取图片的时候，首先判断内存是否有，有—加载，无—从本地中获取图片，有–加载，无–从网络中下载，然后缓存到内存和本地中。大概流程图如下：" class="headerlink" title="图片的缓存虽然现在已经有不少的框架，但是我还是想自己学习一下图片的缓存机制。图片缓存的大概逻辑就是：当需要获取图片的时候，首先判断内存是否有，有—加载，无—从本地中获取图片，有–加载，无–从网络中下载，然后缓存到内存和本地中。大概流程图如下："></a>图片的缓存虽然现在已经有不少的框架，但是我还是想自己学习一下图片的缓存机制。图片缓存的大概逻辑就是：当需要获取图片的时候，首先判断<strong>内存</strong>是否有，有—加载，无—从<strong>本地</strong>中获取图片，有–加载，无–从网络中下载，然后缓存到内存和本地中。大概流程图如下：</h5><p><img src="http://upload-images.jianshu.io/upload_images/4043475-2af93392e70190ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片的三级缓存.png"></p><p>##首先从易到难</p><p>####1. 内存缓存<br>    １. 新建LruCache对象<br>    private LruCache&lt;String, Bitmap&gt; mMemoryCache;</p><pre><code>2. 在构造函数中初始化LruCache        final long maxMemory = Runtime.getRuntime().maxMemory() / 8;        mMemoryCache = new LruCache&lt;String, Bitmap&gt;((int) maxMemory){            @Override            protected int sizeOf (String key, Bitmap value) {                int byteCount = value.getByteCount();                Log.i(TAG, &quot;每个Bitmap大小：&quot; + byteCount + &quot;每个程序最大内存&quot; + maxMemory);                return byteCount;            }        };3. 利用键值对的方式存到内存中    public void setBitmapToMemory(Bitmap bitmap, String url){        Log.i(TAG, &quot;图片已经保存到内存中: &quot;);        mMemoryCache.put(url, bitmap);    }4. 从内存中取出图片    public Bitmap getBitmapFromMemory(String url){        return mMemoryCache.get(url);    }</code></pre><p>#####2.本地缓存</p><pre><code>1. 创建要缓存的路径private static final String CACHE_PATH = Environment.getExternalStorageDirectory().getAbsolutePath();2. 利用输入流进行文件的本地存储，其中对文件名进行了MD5加密    try {        Log.i(TAG, &quot;cachePath: &quot; + CACHE_PATH);        String filename = MD5Encoder.encode(url);        File file = new File(CACHE_PATH, filename);        File parentFile = file.getParentFile();        if (!parentFile.exists()){            parentFile.mkdirs();        }        Log.i(TAG, &quot;图片存到本地中: &quot;);        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, new FileOutputStream(file));    } catch (FileNotFoundException e) {        e.printStackTrace();        Log.i(TAG, &quot;setBitmapToLocal: &quot; + e);    }3. 利用输出流进行文件的读取    try {        String fileName = MD5Encoder.encode(url);        File file = new File(CACHE_PATH, fileName);        Bitmap bitmap = BitmapFactory.decodeStream(new FileInputStream(file));        Log.i(TAG, &quot;从本地获取图片: &quot;);        return bitmap;    } catch (FileNotFoundException e) {        e.printStackTrace();    }    return null;</code></pre><p>#####3.从网络中获取图片</p><pre><code>1. 利用构造函数获取LocalCacheUtil和MemoryCacheUtil对象public NetCache (LocalCache mLocache, MemoryCache mMemoryCache) {    this.mLocache = mLocache;    this.mMemoryCache = mMemoryCache;}2. 新建私有类，从url中获取图片        HttpURLConnection conn = null;        try {            conn = (HttpURLConnection) new URL(url).openConnection();            conn.setConnectTimeout(4000);            conn.setReadTimeout(4000);            conn.setRequestMethod(&quot;GET&quot;);            int responseCode = conn.getResponseCode();            if (responseCode == 200){                //图片压缩                BitmapFactory.Options options = new BitmapFactory.Options();                options.inSampleSize = 2;//宽高压缩为原来的1/2                options.inPreferredConfig = Bitmap.Config.ARGB_4444;                Bitmap bitmap = BitmapFactory.decodeStream(conn.getInputStream(), null, options);                return bitmap;            }        } catch (IOException e) {            e.printStackTrace();            Log.i(TAG, &quot;downLoadBitmap: &quot; + e);        }finally {            conn.disconnect();        }    return null;    }3. 利用AsyncTask的方式异步加载数据class BitmapTask extends AsyncTask&lt;Object, Integer, Bitmap&gt;{    @Override    protected void onPreExecute () {        Log.i(TAG, &quot;onPreExecute: &quot;);        super.onPreExecute();    }    @Override    protected void onProgressUpdate (Integer... values) {        Log.i(TAG, &quot;onProgressUpdate: &quot;);        super.onProgressUpdate(values);    }    @Override    protected Bitmap doInBackground (Object... params) {        Log.i(TAG, &quot;doInBackground: &quot;);        iv = (ImageView) params[0];        url = (String) params[1];        Bitmap bitmap = downLoadBitmap(url);        return bitmap;    }    @Override    protected void onPostExecute (Bitmap bitmap) {        Log.i(TAG, &quot;onPostExecute: &quot;);        if (bitmap != null){            Log.i(TAG, &quot;已经从网络中获取到图片: &quot;);            iv.setImageBitmap(bitmap);            Log.i(TAG, &quot;url: &quot; + url + &quot;Bitmap&quot; + bitmap.getByteCount());            mMemoryCache.setBitmapToMemory(bitmap, url);            mLocache.setBitmapToLocal(bitmap, url);        }    }</code></pre><p>#####4.最后创建一个util进行逻辑的封装，即一开始的流程图<br>    public class MyBitmapUtil {</p><pre><code>private static final String TAG = &quot;MyBitmapUtil-----&gt;&quot;;private LocalCache mLocal;private MemoryCache mMemory;private NetCache mNet;public MyBitmapUtil () {    mLocal = new LocalCache();    mMemory = new MemoryCache();    mNet = new NetCache(mLocal, mMemory);}public void disPlay(ImageView iv, String url){    iv.setImageResource(R.mipmap.ic_launcher);    Bitmap bitmap = null;    bitmap = mMemory.getBitmapFromMemory(url);    if (bitmap != null){        iv.setImageBitmap(bitmap);        return;    }    bitmap = mLocal.getBitmapFromLocal(url);    if (bitmap != null){        iv.setImageBitmap(bitmap);        mMemory.setBitmapToMemory(bitmap, url);        return;    }    mNet.getBitmapFromNet(iv, url);}}</code></pre><p><em>最后附上我的源码Github地址<br><a href="https://github.com/xiaweizi/ImageCache.git" target="_blank" rel="noopener">https://github.com/xiaweizi/ImageCache.git</a></em></p>]]></content>
      
      <categories>
          
          <category> Android 自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 15-泛型</title>
      <link href="/article/thinking_in_java_15/"/>
      <content type="html"><![CDATA[<h2 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h2><p>泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器你来保证类型的正确性，Java 泛型的核心概念，告诉编译器想使用什么类型，然后编译器帮你处理一切细节。</p><p><strong>元组类库</strong></p><p>比如要想实现一个元组(它是将一组对象直接打包存储存于其中的一个单一对象)类库，实现如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        first = a;</span><br><span class="line">        second = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + first + <span class="string">", "</span> + second + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序可以读取<code>first</code>或<code>second</code>所引用的对象，然后可以随心所欲地使用这两个对象。但是，它们却无法将其他值赋予<code>first</code>或<code>second</code>。因为<code>final</code>声明为你买了安全保险，实现了<code>Java</code>编程的安全性原则，而且这种格式更加简洁明了。</p><p><strong>堆栈类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node() &#123;</span><br><span class="line">            item = <span class="keyword">null</span>;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt;  lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">"aaa bbb ccc"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String temp;</span><br><span class="line">        <span class="keyword">while</span> ((temp = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">ccc</span></span><br><span class="line"><span class="comment">bbb</span></span><br><span class="line"><span class="comment">aaa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ol><li>可以在类中包含参数化方法，而这个方法所在的类可以是泛型类，也可以不是泛型类。也就是说，是否拥有泛型方法，与其所在的类是否是泛型没有关系。</li><li>如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型化，另外对于一个static方法而言，无法访问泛型类的类型参数，所以如果static方法需要使用泛型能力，就必须使其成为泛型方法。</li><li>要定义泛型方法，只需将泛型参数列表置于返回值之前。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    System.out.println(x.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用<strong>f()</strong>时传入的是基本类型，自动打包机制就会介入其中，将基本类型的值包装为对应的对象。</p><h4 id="可变参数与泛型方法"><a href="#可变参数与泛型方法" class="headerlink" title="可变参数与泛型方法"></a>可变参数与泛型方法</h4><p>泛型方法与可变参数列表能够很好的共存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T items : args) &#123;</span><br><span class="line">        result.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简化元组的使用"><a href="#简化元组的使用" class="headerlink" title="简化元组的使用"></a>简化元组的使用</h4><p>我们现在可以重新编写之前的元组工具，使其成为更通用的工具类库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B&gt; <span class="function">TwoTuple&lt;A, B&gt; <span class="title">tuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TwoTuple&lt;A, B&gt;(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"><span class="function"><span class="keyword">static</span> TwoTuple&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Tuple.tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> TwoTuple <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Tuple.tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        TwoTuple&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(f());</span><br><span class="line">        System.out.println(f2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2)</span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(c1.getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(c2.getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li><strong>ArrayList<string></string></strong>和<strong>ArrayList<integer></integer></strong>很容易被误认为是两种不同的类型，但它们是相同的。首先我们可以看到，上面的程序会认为它们是相同的类型。另外，程序中使用的<strong>Class.getTypeParameters()</strong>可以返回一个<strong>TypeVariable</strong>对象数组，表示有泛型声明所声明的类型参数，但是我们能够发现的只有用作参数占位符的标识符。因此我们得出结论：<strong>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</strong></li></ol><ol><li>Java泛型是使用擦除来实现的，这意味着<strong>当你在使用泛型时，任何具体的类型信息都被擦除了</strong>，你唯一知道的就是你在使用一个对象。因此<strong>List<string></string></strong>和<strong>List<integer></integer></strong>在运行时都被擦除成它们的“原生”类型<strong>List</strong>。</li><li>由于擦除，<strong>在使用泛型时，这些类型参数都会被当作Object进行处理</strong>。</li></ol><h2 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h2><p>擦除丢失了在泛型代码中执行某些操作的能力。<strong>任何在运行时需要知道的确切类型信息的操作都将无法工作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;)                    <span class="comment">//ERROR</span></span><br><span class="line">        T var = <span class="keyword">new</span> T();                             <span class="comment">//ERROR</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];                <span class="comment">//ERROR</span></span><br><span class="line">        T[] array = (T) <span class="keyword">new</span> Object[SIZE];  <span class="comment">//ERROR</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建类型实例</strong></p><p>对于上面这个问题Java的解决方法是使用工厂对象来创建新的实例，建议使用显式工厂，并限制其类型，使得只能接受实现了这个工厂的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends Factory&lt;T&gt;&gt; Foo(F Factory) &#123;</span><br><span class="line">        x = factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WidgetFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> WidgetFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo&lt;Widget&gt;(<span class="keyword">new</span> Widget.WidgetFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>1.边界使得我们可以在用于泛型的类型参数类型上设置限制条件。因为擦除了类型信息，所以可以用无界泛型参数调用的方法只是那些可以用 <code>Object</code>调用的方法。但是，如果能够将这个参数限制为某个类型子集，那就可以用类型子集来调用方法。</p><p>2.为了执行对泛型参数的限制，<code>Java</code>重用了<code>extends</code>关键字。</p><p>3.对泛型进行参数限制也有多继承，并且也可以通过继承消除冗余。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">C</span> &amp; <span class="title">A</span> &amp; <span class="title">B</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E&lt;D&gt; e = <span class="keyword">new</span> E&lt;D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.下面的程序展示了如何在继承的每个层次上添加边界限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   T item;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.item = item;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span>&gt; <span class="keyword">extends</span> <span class="title">B</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   T item;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>,item = item;</span><br><span class="line">       item.set();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>数组具有<strong>协变性</strong>：可以向导出类型的数组赋予基类型的数组引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple(); <span class="comment">//OK</span></span><br><span class="line">        fruit[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan(); <span class="comment">//OK</span></span><br><span class="line">        fruit[<span class="number">2</span>] = <span class="keyword">new</span> Orange(); <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码不会出现编译问题，因为<code>Apple</code>、<code>Orange</code>、<code>Jonathan</code>都是<code>Fruit</code>的子类型，<code>Fruit</code>类型的引用持有它们并没有任何问题，是有意义的。但是<code>fruit[2] = new Orange();</code>这一句在运行时会抛出<code>ArrayStoreException</code>异常，因为数组fruit在运行时的实际类型为<code>Apple</code>。</p><p><strong>数组的协变性对List并不起作用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line"><span class="comment">//Compile Error: can't add any type of object</span></span><br><span class="line"><span class="comment">//flist.add(new Apple());</span></span><br><span class="line"><span class="comment">//flist.add(new Fruit);</span></span><br><span class="line"><span class="comment">//flist.add(new Object());</span></span><br></pre></td></tr></table></figure><p>上面代码中唯一的限制就是这个<code>List</code>要持有某种具体的<code>Fruit</code>或<code>Fruit</code>的子类型，但是编译器实际上并不知道<code>List</code>持有什么类型，那么也就不能安全地向其中添加对象，因此会出现编译时错误。</p><p>虽然在上面的程序中<code>List</code>的<code>add()</code>方法不可用，但是并不是所有的方法都是不可用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple) flist.get(<span class="number">0</span>);</span><br><span class="line">        flist.contains(<span class="keyword">new</span> Apple());</span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段程序的区别在于<code>add()</code>方法将接受一个具有泛型参数类型的参数，但是<code>contains()</code>和<code>indexOf()</code>将返回或者接受<code>Object</code>类型的参数。因此，在指定一个<code>ArrayList&lt;? extends Fruit&gt;</code>时，<code>add()</code>的参数就变成了”<code>? extends Fruit</code>“，此时，编译器并不能了解这里需要<code>Fruit</code>的哪个具体子类型，因此它不会接受任何类型的<code>Fruit</code>。而另外的方法使用了<code>Object</code>，并不涉及通配符，因此编译器也将允许这个调用。而上面的<code>get()</code>方法只会也只能返回<code>Fruit</code>对象，这是在该泛型参数所给定了边界——“任何扩展自<code>Fruit</code>的对象”之后所能做的唯一的事情了。</p><p><strong>逆变</strong></p><p>超类通配符：使用方法是由某个特定类的任何基类来界定的即<strong>&lt;? super MyClass&gt;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Apple&gt; apples = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">apples.add(<span class="keyword">new</span> Fruit()); <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><p><strong>无界通配符</strong></p><ol><li>第一种情况下<strong>无界通配符</strong>意味着“任何事物”，即编译器很少关心使用的是原生类型还是<strong>&lt;?&gt;</strong>。因此，<strong>&lt;?&gt;</strong>是在声明：<strong>我是想用Java的泛型来编写代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型</strong>。</li><li>泛型的另一种应用是：<strong>当你在处理多个参数时，优势允许一个参数可以时任喝类型，同时为其他参数确定某种特定类型</strong>，如<code>Map&lt;String, ?&gt; map = new HashMap&lt;String, Integer&gt;</code>。</li><li><strong>List</strong>实际表示“持有任何<strong>Object</strong>类型的<strong>List</strong>”，而<strong>List&lt;?&gt;</strong>表示“具有<strong>某种特定类型</strong>的非原生<strong>List</strong>，只是我们不知道那种类型是什么。”</li><li>使用确切类型来代替通配符，可以使用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。</li></ol><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。</p><p>使用带有泛型参数类型的转型或<strong>instanceof</strong>不会带有任何效果。</p><h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>1.自限定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>SelfBounded</strong>类接受泛型参数<strong>T</strong>，而<strong>T</strong>由一个边界限定，这个边界就是拥有<strong>T</strong>作为其参数的<strong>SelfBounded</strong>。<br>2.自限定强制泛型当作自己的边界参数来使用。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>3.自限定限制只能强制作用于继承关系。如果食用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。</p><h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>1.Java SE5中的<strong>java.util.Collections</strong>中有一组工具用于检查容器所持有的类型是否是我们所需要的，它们是：<strong>静态方法checkedCollection()</strong>、<strong>checkedList()</strong>、<strong>checkedMap()</strong>、<strong>checkedSet()</strong>、<strong>checkedSortedMap()</strong>、<strong>checkedSortedSet()</strong>。这些方法会将你希望动态检查的容器当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dog&gt; dogs = Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(), Dog.class);</span><br></pre></td></tr></table></figure><p>2.因为可以向Java SE5之前的代码传递泛型容器，所以旧式代码仍旧有可能破坏你的容器，此时上述工具就可以解决在这种情况下的类型检查问题。</p><h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>1.混型的最基本的概念是混合多个类的能力。以产生一个可以表示混型中所有与类型的类。</p><p><strong>一.与接口混合</strong></p><p>1.一种常见的产生混型效果的方法是使用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampedImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeStampedImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumbered</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumberedImp</span> <span class="keyword">implements</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixmin</span> <span class="keyword">extends</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span>, <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TimeStamped timeStamp = <span class="keyword">new</span> TimeStampedImp();</span><br><span class="line">    <span class="keyword">private</span> SerialNumbered serialNumber = <span class="keyword">new</span> SerialNumberedImp();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp.getStamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber.getSerialNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mixmins</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        Mixmin mixmin1 = <span class="keyword">new</span> Mixmin(), mixmin2 = <span class="keyword">new</span> Mixmin();</span><br><span class="line">        mixmin1.set(<span class="string">"string1"</span>);</span><br><span class="line">        mixmin2.set(<span class="string">"string1"</span>);</span><br><span class="line">        System.out.println(mixmin1.get() + <span class="string">"  "</span> + mixmin1.getStamp() + <span class="string">"  "</span> + mixmin1.getSerialNumber());</span><br><span class="line">        System.out.println(mixmin2.get() + <span class="string">"  "</span> + mixmin2.getStamp() + <span class="string">"  "</span> + mixmin2.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例的使用方法非常简单，但是当使用更加复杂的混型时，代码量会急速增加。</p><p><strong>二.使用装饰器模式</strong> </p><p>1.装饰器是通过使用组合和形式化结构来实现的，而混型时基于继承的。因此可以将基于参数化类型的混型当作一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Basic basic;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basic = basic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        basic.set(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> basic.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStamped</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeStampedImp</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumbered</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerialNumbered</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span> </span>&#123;</span><br><span class="line">        TimeStamped t = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic());</span><br><span class="line">        TimeStamped t2 = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic()));</span><br><span class="line"></span><br><span class="line">        SerialNumbered t = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic());</span><br><span class="line">        SerialNumbered t2 = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic()));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于装饰器来说，其明显的缺陷谁它只能有效地工作于装饰中的最后一层，而混型方法显然会更佳自然一些，因此，装饰器只是对由混型提出的问题的一种局限的解决方案。</p><p><strong>三.与动态代理结合</strong> </p><p>1.可以使用动态代理来创建一种比装饰器更贴近混型模型的机制。由于动态代理的限制，每个被混入的类都必须时某个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixminProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MixminProxy</span><span class="params">(TwoTuple&lt;Object, Class&lt;?&gt;&gt;... pairs)</span> </span>&#123;</span><br><span class="line">        delegatesByMethod = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TwoTuple&lt;Object, Class&lt;?&gt;&gt; pair : pairs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : pair.second.getMethods()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="keyword">if</span> (!delegatesByMethod.containsKey(methodName)) </span><br><span class="line">                    delegatesByMethod.put(methodName, pair.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Object delegate = delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(TwoTuple... pairs)</span> </span>&#123;</span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i ++) &#123;</span><br><span class="line">            interfaces[i] = (Class) pairs[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader cl = pair[<span class="number">0</span>].first.getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(cl, interfaces, <span class="keyword">new</span> MixminProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixmin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        Object mixmin = MixminProxy.newInstance(</span><br><span class="line">            tuple(<span class="keyword">new</span> BasicImp(), Basic.class), </span><br><span class="line">            tuple(<span class="keyword">new</span> TimeStampedImp(), TimeStamped.class), </span><br><span class="line">            tuple(<span class="keyword">new</span> SerialNumberedImp(), SerialNumbered.class));</span><br><span class="line">        Basic b = (Basic) mixmin;</span><br><span class="line">        TimeStamped t = (TimeStamped) mixmin;</span><br><span class="line">        SerialNumbered s = (SerialNumbered) mixmin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(b.get());</span><br><span class="line">        System.out.println(t.get());</span><br><span class="line">        System.out.println(s.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案要比上面两种方式更加接近于真正的混型。</p><h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>1.某些编程语言提供了一种机制——<strong>潜在类型机制</strong>。<br>2.泛型代码典型地将在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法的子集，而不是某个特定类或接口，从而放松了这种限制。<br>3.潜在类型机制是一种代码组织和复用机制。有了它编写出来的代码相对于没有它编写出的代码，能够更容易滴复用。<br>4.由于泛型是后期才加进Java的，因此没有任何机会可以去实现任何类型的潜在类型机制，因此Java没有对这种类型的支持。</p><h2 id="对缺乏潜在类型机制的补偿"><a href="#对缺乏潜在类型机制的补偿" class="headerlink" title="对缺乏潜在类型机制的补偿"></a>对缺乏潜在类型机制的补偿</h2><h5 id="一-反射"><a href="#一-反射" class="headerlink" title="一.反射"></a>一.反射</h5><p>在Java中使用潜在类型机制，可以使用的一种方式是反射，下面的<strong>perform()</strong>方法就是用了潜在类型机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Mime &#123;</span><br><span class="line">    public void walkAgainstTheWind() &#123;&#125;</span><br><span class="line">    public void sit() &#123; print(&quot;Pretending to sit&quot;); &#125;</span><br><span class="line">    public void pushInvisibleWalls() &#123;&#125;</span><br><span class="line">    public String toString() &#123; return &quot;Mime&quot;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SmartDog &#123;</span><br><span class="line">    public void speak() &#123; print(&quot;Woof!&quot;); &#125;</span><br><span class="line">    public void sit() &#123; print(&quot;Sittint&quot;); &#125;</span><br><span class="line">    public void reproduce() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CommunicateReflectively &#123;</span><br><span class="line">    public static void perform(Object speaker) &#123;</span><br><span class="line">        Class&lt;?&gt; spkr = speaker.getClass();</span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Method speak = spkr.getMethod(&quot;speak&quot;);</span><br><span class="line">                speak.invoke(speaker);</span><br><span class="line">            &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                print(speaker + &quot;cannot speak&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Method sit = spkr.getMethod(&quot;sit&quot;);</span><br><span class="line">                sit.invoke(sit);</span><br><span class="line">            &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                print(speaker + &quot;cannot sit&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(speaker.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LatentReflection &#123;</span><br><span class="line">    public static void main(String.... args) &#123;</span><br><span class="line">        CommunicateReflectively.perform(new SmartDog());</span><br><span class="line">        CommunicateReflectively.perform(new Robot());</span><br><span class="line">        CommunicateReflectively.perform(new Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，这些类都是彼此分离的。</p><p><strong>将一个方法应用于序列</strong></p><p>1.反射虽然提供了潜在类型机制的可能性，但是它将所有类型检查都转移到了运行时。如果能够实现编译期类型检查，这通常会更加符合要求。<br>2.假设想要创建一个方法，它能够将任何方法应用于某个系列中的所有对象。我们可以使用上面的反射以及可变参数来解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123; print(<span class="keyword">this</span> + <span class="string">" rotate"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">" resize"</span> + newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S extends Iterable&lt;? extends T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">apply</span> <span class="params">(S seq, Method f, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : seq) &#123;</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilledLIst</span><span class="params">(Class&lt;? extends T&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                add(type.newInstance());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapes = <span class="keyword">new</span> ArrayList&lt;Shape&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">            shapes.add(<span class="keyword">new</span> Shape());</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Shape.class, <span class="number">10</span>), Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管之中方法的解决方法背证明很优雅， 但是我们必须知道使用反射比非反射可能要慢一些，因为动作都是在运行时发生的。</p><p><strong>三.当你并未碰巧拥有正确的接口时</strong></p><p>1.如果具有潜在类型机制的参数化类型机制，你不会受任何特定类库的创建者过去所作的设计的支配，不想上面的代码需要适合需求的接口，因此这样的代码不是特别的“泛化”。</p><p><strong>四.用适配器模仿潜在类型机制</strong></p><p>1.实际上，潜在类型机制创建一个包含所需方法的<em>隐式接口</em>。因此它遵循这样的规则L如果我们手工编写了必需的接口，那么它就应该能够解决问题。<br>2.从我们拥有的接口中编写代码来产生我们需要的接口，这是适配器设计模式的一个典型示例。我们可以使用适配器来适配已有的接口，以产生想要的接口。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://www.jianshu.com/p/adf709de8001" target="_blank" rel="noopener">《Thinking in Java》学习</a></p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 14-类型信息</title>
      <link href="/article/thinking_in_java_14/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p>运行时类型信息使得你可以在程序运行时发现和使用类型信息。</p><p>Java 通过两种方式在运行时识别对象和类信息的，一种是 <strong>传统的RTTI</strong>，(RunTime Type Identification 运行时类型定义)，假定我们在编译时已经知道了所有的类型。第二种是 <strong>反射机制</strong>，它允许在运行时发现和使用类信息。</p></blockquote><h2 id="为什么需要-RTTI"><a href="#为什么需要-RTTI" class="headerlink" title="为什么需要 RTTI"></a>为什么需要 RTTI</h2><p><strong>啥叫多态</strong>，父类方法在子类可能会被覆盖，但是由于方法是动态绑定的，所以即使是通过泛化的父类引用来调用方法，也是可以产生正确的行为，这就是多态。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类  </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">".draw()"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 子类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Circle"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//子类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Square"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//子类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Triangle"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 利用父类引用调用子类方法的荔枝  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 把 Shape子类数组转换为 泛型为Shape的List容器  </span></span><br><span class="line">        List&lt;Shape&gt; shapeList = Arrays.asList(<span class="keyword">new</span> Circle(), <span class="keyword">new</span> Square(), <span class="keyword">new</span> Triangle());  </span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapeList)  </span><br><span class="line">            shape.draw();  </span><br><span class="line">          </span><br><span class="line">        System.out.println();  </span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapeList)             </span><br><span class="line">            System.out.println(<span class="string">"does "</span> + shape.getClass().getName() + <span class="string">" belong to Circle = "</span> + rotate(shape));  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">rotate</span><span class="params">(Shape s)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(s <span class="keyword">instanceof</span> Circle) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Circle.draw() </span></span><br><span class="line"><span class="comment">Square.draw() </span></span><br><span class="line"><span class="comment">Triangle.draw() </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">does chapter14.Circle belong to Circle = true </span></span><br><span class="line"><span class="comment">does chapter14.Square belong to Circle = false </span></span><br><span class="line"><span class="comment">does chapter14.Triangle belong to Circle = false </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>RTTI的基本形式</strong>，当从数组中取出元素时， <code>RTTI</code> 会将 <code>Object</code> 转换成 <code>Shape</code> 类型， <code>RTTI</code> 类型转换并不彻底，因为把所有的 <code>Object</code> 转换成 <code>Shape</code> 父类，而不是转换到 <code>Circle</code> 或 <code>Square</code> 或 <code>Triangle</code> 。</p><h2 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h2><ul><li>类型信息在运行时是如何表示的：这项工作是由 Class 对象的特殊对象完成的。</li><li>Class 对象的作用：用来创建类的所有常规对象和保存对象在运行时的类型信息。</li><li>Java 使用 Class 对象来实现 RTTI，即类型转换。</li><li>每个类都有一个 Class 对象：每当编写并且编译一个新类，就会产生一个 Class 对象。</li><li>所有的类都是在第一次使用时，动态加载到 jvm 中的：当程序创建第一个对类的静态成员的引用时，就会加载这个类。</li><li>Java 程序在它运行之前并非被完全加载，其各个部分是在必需时才加载。</li><li>类加载器加载 Class 对象：类加载器首先检查这个类的 Class 对象是否已经被加载。如果没有加载，则默认的类加载器会根据类名查找 <code>.class</code> 文件。</li><li>一旦某个类的 Class 对象被载入内存，他就被用来创建这个类的所有对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"name is loading"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"sex is loading"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String desc = <span class="string">"desc"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"age is loading"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Age() &#123;</span><br><span class="line">        System.out.println(<span class="string">"age construct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Name();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TYPE == <span class="keyword">boolean</span>.class) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Class.forName(<span class="string">"chapter14.Sex"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Age();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">name is loading</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">sex is loading</span></span><br><span class="line"><span class="comment">age is loading</span></span><br><span class="line"><span class="comment">age construct</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>Class 仅在需要的时候才被加载， static 初始化是在类加载时就被加载。</p><p>Class.forname() 取得 Class 对象引用的方法。</p></blockquote><h2 id="Class-方法列表"><a href="#Class-方法列表" class="headerlink" title="Class 方法列表"></a>Class 方法列表</h2><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td>getName()</td><td>Class 类型信息所存储的全限定类名</td></tr><tr><td>isInterface()</td><td>是否是接口</td></tr><tr><td>getSimpleName()</td><td>Class 类型信息存储的类名(不包含包名的类名)</td></tr><tr><td>getCanonicalName()</td><td>Class 类型信息所有存储的全限定类名</td></tr><tr><td>getInterfaces()</td><td>返回接口数组</td></tr><tr><td>getSuperClass()</td><td>返回直接基类</td></tr><tr><td>newInstance()</td><td>创建 class 运行时类型信息对象对应的实例</td></tr></tbody></table><h4 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h4><p>使用类字面常量生成对<code>Class</code>对象的引用： 如 <code>FancyToy.class</code>；这种做法不仅简单而且安全，因为它在编译时就会受到检查（不需要放在 <code>try</code> 块中），并且根除了对 <code>forName()</code>的调用，所以高效。</p><p>类字面常量应用范围于 普通类，接口，数组，基本数据类型和包装器类， 以及一个标准字段TYPE等。TYPE字段：是一个引用，指向对应的基本数据类型的 Class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>.class 等价于 Boolean.TYPE  </span><br><span class="line"><span class="keyword">char</span>.class 等价于 Character.TYPE  </span><br><span class="line"><span class="keyword">byte</span>.class 等价于 Byte.TYPE  </span><br><span class="line"><span class="keyword">short</span>.class 等价于 Short.TYPE  </span><br><span class="line"><span class="keyword">int</span>.class 等价于 Integer.TYPE  </span><br><span class="line"><span class="keyword">long</span>.class 等价于 Long.TYPE  </span><br><span class="line"><span class="keyword">float</span>.class 等价于 Float.TYPE  </span><br><span class="line"><span class="keyword">double</span>.class 等价于 Double.TYPE  </span><br><span class="line"><span class="keyword">void</span>.class 等价于 Void.TYPE</span><br></pre></td></tr></table></figure><p><em>推荐使用 .class 的形式，以保持与普通类的一致性</em></p><p>当使用  <code>.class</code> 来创建<code>Class</code>对象的引用时，不会自动初始化该 <code>Class</code> 对象。</p><p>为使用类而做的准备工作包含3个步骤。</p><ol><li><strong>加载</strong>。这是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个 Class 对象。</li><li><strong>链接</strong>。验证类的字节码，为静态区域分配空间，如果需要的话，解析这个类创建的其他类的所有引用。</li><li><strong>初始化</strong>。如果该类有超类，对超类初始化，执行静态初始化器 和 静态初始化代码块</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">47</span>; <span class="comment">// 编译期常量  </span></span><br><span class="line">    <span class="comment">// staticFinal2 是运行时常量，因为它需要调用其他类的方法进行赋值.  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class="number">1000</span>);   </span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"Initializing Initable"</span>); &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable2</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">147</span>; <span class="comment">// 非编译期常量  </span></span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"Initializing Initable2"</span>); &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable3</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">74</span>; <span class="comment">// 非编译期常量  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"Initializing Initable3"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"staticNonFinal = "</span> + staticNonFinal);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialization</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Class initable = Initable.class; <span class="comment">// Initable.class  不会触发初始化  </span></span><br><span class="line">        <span class="comment">// 不会触发类初始化(调用常量)  </span></span><br><span class="line">        System.out.println(<span class="string">"Initable.staticFinal = "</span> + Initable.staticFinal + <span class="string">"\n"</span>);  </span><br><span class="line">        <span class="comment">// 会触发初始化（调用常量， 但常量是有其他静态方法进行赋值的）  </span></span><br><span class="line">        System.out.println(<span class="string">"Initable.staticFinal2 = "</span> + Initable.staticFinal2 + <span class="string">"\n"</span>);  </span><br><span class="line">        <span class="comment">// 会触发初始化（调用非final static 变量，非常数静态域）  </span></span><br><span class="line">        System.out.println(<span class="string">"Initable2.staticNonFinal = "</span> + Initable2.staticNonFinal+<span class="string">"\n"</span>);  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"======"</span>);  </span><br><span class="line">        Class initable3 = Class.forName(<span class="string">"chapter14.Initable3"</span>); <span class="comment">// Class.forName() 触发类初始化  </span></span><br><span class="line">        System.out.println(<span class="string">"\nAfter creating Initable3 ref"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"Initable3.staticNonFinal = "</span> + Initable3.staticNonFinal); <span class="comment">// 已经触发了Initable3初始化，不会再次触发了（仅初始化一次）  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Initable.staticFinal = 47 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Initializing Initable </span></span><br><span class="line"><span class="comment">Initable.staticFinal2 = 258 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Initializing Initable2 </span></span><br><span class="line"><span class="comment">Initable2.staticNonFinal = 147 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">====== </span></span><br><span class="line"><span class="comment">Initializing Initable3 </span></span><br><span class="line"><span class="comment">staticNonFinal = 74 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">After creating Initable3 ref </span></span><br><span class="line"><span class="comment">Initable3.staticNonFinal = 74 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="class-对象的-cast-方法"><a href="#class-对象的-cast-方法" class="headerlink" title="class 对象的 cast() 方法"></a>class 对象的 cast() 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123; &#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; &#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123; &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 荔枝-class对象的cast()方法，类型转换（特别是父类转子类的荔枝）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasts</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Father father = <span class="keyword">new</span> Child();  </span><br><span class="line">        Class&lt;Child&gt; childType = Child.class;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// classObj.cast(otherObj) 将 otherObj 转换为 classObj 对应的对象引用（父类对象引用转换为 子类对象引用）   </span></span><br><span class="line">        Child child = childType.cast(father);  <span class="comment">//    </span></span><br><span class="line">        System.out.println(child.getClass().getName()); <span class="comment">// chapter14.Child  </span></span><br><span class="line">          </span><br><span class="line">        child = (Child)father; <span class="comment">// 也是将 Father 对象转换为 Child 对象（同样的效果）  </span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 自定义测试  </span></span><br><span class="line"><span class="comment">//      child = childType.cast(new Apple());  // 编译期不报错，运行时报错  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// chapter14.Child</span></span><br></pre></td></tr></table></figure><h2 id="类型转换前先检查"><a href="#类型转换前先检查" class="headerlink" title="类型转换前先检查"></a>类型转换前先检查</h2><ol><li><p>传统的类型转换： 由RTTI 确保类型转换的正确性，若有错误抛出 ClassCastException 异常（类型转换异常）；</p></li><li><p>封装对象的运行时类型信息的Class对象： 通过查询 Class 对象可以获取运行时类型信息；</p></li><li><p>RTTI还有第3中方式：关键字 instanceof；它返回一个 boolean值，表示对象是否属于某种类型；</p><p>如果程序中出现了过多的 instanceof，说明程序设计存在瑕疵。</p></li></ol><h2 id="注册工厂"><a href="#注册工厂" class="headerlink" title="注册工厂"></a>注册工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Part</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">static</span> List&lt;Factory&lt;? extends Part&gt;&gt; partFactories = <span class="keyword">new</span> ArrayList&lt;Factory&lt;? extends Part&gt;&gt;();      </span><br><span class="line">  <span class="keyword">static</span> &#123;  </span><br><span class="line">    <span class="comment">// Collections.addAll() gives an "unchecked generic  </span></span><br><span class="line">    <span class="comment">// array creation ... for varargs parameter" warning.  </span></span><br><span class="line">    partFactories.add(<span class="keyword">new</span> FuelFilter.Factory());  </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> AirFilter.Factory());  </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> CabinAirFilter.Factory());  </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> OilFilter.Factory());  </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> FanBelt.Factory());  </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> PowerSteeringBelt.Factory());  </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> GeneratorBelt.Factory());  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Part <span class="title">createRandom</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = rand.nextInt(partFactories.size()); <span class="comment">// partFactories.size() = 7   </span></span><br><span class="line">    <span class="keyword">return</span> partFactories.get(n).create();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;     </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="keyword">extends</span> <span class="title">Part</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuelFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// Create a Class Factory for each specific type:  </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">FuelFilter</span>&gt; </span>&#123; <span class="comment">// 静态内部类作为工厂方法类  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FuelFilter <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> FuelFilter(); &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">AirFilter</span>&gt; </span>&#123;<span class="comment">// 静态内部类作为工厂方法类  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AirFilter <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AirFilter(); &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;     </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CabinAirFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">CabinAirFilter</span>&gt; </span>&#123;<span class="comment">// 静态内部类作为工厂方法类  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CabinAirFilter <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> CabinAirFilter(); &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OilFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">OilFilter</span>&gt; </span>&#123;<span class="comment">// 静态内部类作为工厂方法类  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OilFilter <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> OilFilter(); &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;     </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Belt</span> <span class="keyword">extends</span> <span class="title">Part</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FanBelt</span> <span class="keyword">extends</span> <span class="title">Belt</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">FanBelt</span>&gt; </span>&#123;<span class="comment">// 静态内部类作为工厂方法类  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanBelt <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> FanBelt(); &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorBelt</span> <span class="keyword">extends</span> <span class="title">Belt</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">GeneratorBelt</span>&gt; </span>&#123;<span class="comment">// 静态内部类作为工厂方法类  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GeneratorBelt <span class="title">create</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GeneratorBelt();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;     </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerSteeringBelt</span> <span class="keyword">extends</span> <span class="title">Belt</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">PowerSteeringBelt</span>&gt; </span>&#123;<span class="comment">// 静态内部类作为工厂方法类  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PowerSteeringBelt <span class="title">create</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PowerSteeringBelt();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;     </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisteredFactories</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  </span><br><span class="line">      System.out.println(Part.createRandom());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">GeneratorBelt </span></span><br><span class="line"><span class="comment">CabinAirFilter </span></span><br><span class="line"><span class="comment">GeneratorBelt </span></span><br><span class="line"><span class="comment">AirFilter </span></span><br><span class="line"><span class="comment">PowerSteeringBelt </span></span><br><span class="line"><span class="comment">CabinAirFilter </span></span><br><span class="line"><span class="comment">FuelFilter </span></span><br><span class="line"><span class="comment">PowerSteeringBelt </span></span><br><span class="line"><span class="comment">PowerSteeringBelt </span></span><br><span class="line"><span class="comment">FuelFilter </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Instanceof-与-Class-的等价性"><a href="#Instanceof-与-Class-的等价性" class="headerlink" title="Instanceof 与 Class 的等价性"></a>Instanceof 与 Class 的等价性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;     </span><br><span class="line"><span class="comment">// 荔枝-instanceof 与 直接比较Class对象的区别  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamilyVsExactType</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object x)</span> </span>&#123;  </span><br><span class="line">    print(<span class="string">"class Derived extends Base &#123;&#125;"</span>);  </span><br><span class="line">    print(<span class="string">"x.getClass() "</span> + x.getClass());  </span><br><span class="line">    print(<span class="string">"(x instanceof Base) "</span> + (x <span class="keyword">instanceof</span> Base));  </span><br><span class="line">    print(<span class="string">"(x instanceof Derived) "</span>+ (x <span class="keyword">instanceof</span> Derived));  </span><br><span class="line">    print(<span class="string">"Base.class.isInstance(x) "</span>+ Base.class.isInstance(x));  </span><br><span class="line">    print(<span class="string">"Derived.class.isInstance(x) "</span> + Derived.class.isInstance(x));  </span><br><span class="line">    print(<span class="string">"(x.getClass() == Base.class) "</span> + (x.getClass() == Base.class));  </span><br><span class="line">    print(<span class="string">"(x.getClass() == Derived.class) "</span> + (x.getClass() == Derived.class));  </span><br><span class="line">    print(<span class="string">"(x.getClass().equals(Base.class)) "</span>+ (x.getClass().equals(Base.class)));  </span><br><span class="line">    print(<span class="string">"(x.getClass().equals(Derived.class)) "</span> + (x.getClass().equals(Derived.class)));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    test(<span class="keyword">new</span> Base());  </span><br><span class="line">    System.out.println(<span class="string">"==============================="</span>);  </span><br><span class="line">    test(<span class="keyword">new</span> Derived());  </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">============ Base 父类=================== </span></span><br><span class="line"><span class="comment">class Derived extends Base &#123;&#125; </span></span><br><span class="line"><span class="comment">x.getClass() class typeinfo.Base </span></span><br><span class="line"><span class="comment">(x instanceof Base) true </span></span><br><span class="line"><span class="comment">(x instanceof Derived) false </span></span><br><span class="line"><span class="comment">Base.class.isInstance(x) true </span></span><br><span class="line"><span class="comment">Derived.class.isInstance(x) false </span></span><br><span class="line"><span class="comment">(x.getClass() == Base.class) true </span></span><br><span class="line"><span class="comment">(x.getClass() == Derived.class) false </span></span><br><span class="line"><span class="comment">(x.getClass().equals(Base.class)) true </span></span><br><span class="line"><span class="comment">(x.getClass().equals(Derived.class)) false </span></span><br><span class="line"><span class="comment">============ Derived 子类=================== </span></span><br><span class="line"><span class="comment">class Derived extends Base &#123;&#125; </span></span><br><span class="line"><span class="comment">x.getClass() class typeinfo.Derived </span></span><br><span class="line"><span class="comment">(x instanceof Base) true // 子类是父类的实例 </span></span><br><span class="line"><span class="comment">(x instanceof Derived) true </span></span><br><span class="line"><span class="comment">Base.class.isInstance(x) true // 子类是父类的实例 </span></span><br><span class="line"><span class="comment">Derived.class.isInstance(x) true  </span></span><br><span class="line"><span class="comment">(x.getClass() == Base.class) false </span></span><br><span class="line"><span class="comment">(x.getClass() == Derived.class) true </span></span><br><span class="line"><span class="comment">(x.getClass().equals(Base.class)) false </span></span><br><span class="line"><span class="comment">(x.getClass().equals(Derived.class)) true </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>instanceof 和 isInstance() 方法返回的结果完全一样，equals 和 == 的返回结果也一样</li><li>instanceof 和 isInstance() 保持了类型的概念，它表达的是“你是这个类吗？你是这个类的派生类吗？”</li><li>而 ==比较了实际的 Class对象，就没有考虑继承，它或者是这个这个确切类型，或者不是</li></ol><h2 id="反射：运行时类信息"><a href="#反射：运行时类信息" class="headerlink" title="反射：运行时类信息"></a>反射：运行时类信息</h2><ul><li>如何在运行时识别对象类型：RTTI可以告诉你对象的确切类型：前提条件，这个类在编译时类型必须被编译器知晓，这样RTTI才可以识别。</li><li>存在这样一种情况：在编译完成后再手动利用一串字节创建这个类的对象，即在运行时利用字节流创建对象，而不是在编译时这个对象的类型就已经知道了，如反序列化 或 远程方法调用（RMI）；这种情况下，如何知道运行时对象的确切类型呢？</li><li>想要获取运行时对象的类型信息的另一个动机：希望提供在跨网络的远程平台上创建和运行对象，这就是远程方法调用 RMI，RMI 允许一个java程序将对象分布到多台服务器上；</li><li>反射机制能够解决这个问题：即反射能够识别在运行时手动利用字节流创建的对象类型信息，即便编译器无法知道这个对象的创建；</li><li>Class类 与 java.lang.reflect 类库一起对反射提供支持；<ul><li>该类库包括的类：Field、Method、Constructor（都继承自Member接口）；这些类型的对象是 jvm 在运行时创建的，用来表示未知类里的成员；</li><li>如何使用这些类和方法呢？使用Constructor 创建新对象，用 get 和 set方法 读取和修改 与 Field对象相关联的字段，用invoke() 调用与 Method对相关联的方法；还有 getFields()， getMethods()， getConstuctors() 分别返回字段，方法，构造器对象数组；</li></ul></li><li>当通过反射与一个未知类型的对象打交道时： 在使用该对象前，必须先加载该对象所属类型的Class对象；</li><li>因此，那个未知对象所属类的 .class 文件对于jvm来说是必须要获取的： 要么通过本地，要么通过网络；</li><li>反射与 RTTI的区别在于： 对于RTTI来说， 编译器在编译时打开和检查 .class 文件；而对于反射机制来说， .class文件在编译时是不可获取的，所以在运行时打开和检查 .class 文件；</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理是基本的设计模式之一，代理用来代替实际对象的对象，代理充当着中间人的角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface anInterface)</span> </span>&#123;</span><br><span class="line">        anInterface.doSomeThing();</span><br><span class="line">        anInterface.doSomeThingElse(<span class="string">"biu~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        consumer(<span class="keyword">new</span> RealObject());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        consumer(<span class="keyword">new</span> ProxyObject(<span class="keyword">new</span> RealObject()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThingElse</span><span class="params">(String args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doSomeThing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThingElse</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doSomeThingElse:"</span> + args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Interface anInterface;</span><br><span class="line"></span><br><span class="line">    ProxyObject(Interface anInterface) &#123;</span><br><span class="line">        <span class="keyword">this</span>.anInterface = anInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProxyObject doSomeThing"</span>);</span><br><span class="line">        anInterface.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThingElse</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProxyObject doSomeThingElse:"</span> + args);</span><br><span class="line">        anInterface.doSomeThingElse(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理的目的在于，任何时刻，只要你想要将额外的操作从实际对象中分离到不同地方，特别是当你希望能够做出修改时，从没有使用额外操作转为使用这些操作，或者反过来，代理就特别有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line">    DynamicProxyHandler(Object proxied) &#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DynamicProxy "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">doSomeThing</span></span><br><span class="line"><span class="comment">doSomeThingElse:biu~</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ProxyObject doSomeThing</span></span><br><span class="line"><span class="comment">doSomeThing</span></span><br><span class="line"><span class="comment">ProxyObject doSomeThingElse:biu~</span></span><br><span class="line"><span class="comment">doSomeThingElse:biu~</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DynamicProxy doSomeThing</span></span><br><span class="line"><span class="comment">doSomeThing</span></span><br><span class="line"><span class="comment">DynamicProxy doSomeThingElse</span></span><br><span class="line"><span class="comment">doSomeThingElse:biu~</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="接口与类型的信息"><a href="#接口与类型的信息" class="headerlink" title="接口与类型的信息"></a>接口与类型的信息</h2><ul><li>Interface 接口的重要目的：允许程序员隔离构件，进而降低耦合性。</li><li>接口并非对解耦提供了百分百的保障，因为通过类型信息，耦合性还是会传播回去。</li></ul><p><strong>通过反射可以访问私有方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenImplementation</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        A a = HiddenC.makeA();  </span><br><span class="line">          </span><br><span class="line">        a.f();  </span><br><span class="line">        System.out.println(<span class="string">"a.getClass().getName() = "</span> + a.getClass().getName());  </span><br><span class="line">        <span class="comment">/* 这里编译报错: 找不到类表示C2 （如果C2 与 HiddenImplementation 不在同一个包下） </span></span><br><span class="line"><span class="comment">         * if(a instanceof C) &#123; C c = (C)a; c.g(); &#125; </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 通过反射可以访问 私有方法，受保护或包可见性方法。  </span></span><br><span class="line">        callHiddenMethod(a, <span class="string">"g"</span>);  </span><br><span class="line">        <span class="comment">// And even methods that are less accessible!  </span></span><br><span class="line">        callHiddenMethod(a, <span class="string">"u"</span>);  </span><br><span class="line">        callHiddenMethod(a, <span class="string">"v"</span>);  </span><br><span class="line">        callHiddenMethod(a, <span class="string">"w"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callHiddenMethod</span><span class="params">(Object a, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Method g = a.getClass().getDeclaredMethod(methodName); <span class="comment">// 获取对象a的方法对象  </span></span><br><span class="line">        g.setAccessible(<span class="keyword">true</span>); <span class="comment">// 设置访问权限为可访问  </span></span><br><span class="line">        g.invoke(a); <span class="comment">// 触发调用 对象a 的 g() 方法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">public C.f() </span></span><br><span class="line"><span class="comment">a.getClass().getName() = chapter14.C2 </span></span><br><span class="line"><span class="comment">public C.g() </span></span><br><span class="line"><span class="comment">package C.u() </span></span><br><span class="line"><span class="comment">protected C.v() </span></span><br><span class="line"><span class="comment">private C.w() </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C2默认为包可见性  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        print(<span class="string">"public C.f()"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        print(<span class="string">"public C.g()"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        print(<span class="string">"package C.u()"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        print(<span class="string">"protected C.v()"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        print(<span class="string">"private C.w()"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenC</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C2();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过使用反射，仍旧可以调用所有方法，包括private方法！如果知道方法名，就可以在其Method方法对象上调用 setAccessible(true)；</li><li>有些人可能认为，通过只发布编译后的代码来阻止这种情况（如外部程序调用private方法），但并不能解决问题。因为执行 javap 反编译器可以突破这个限制</li></ul><p><strong>通过反射访问私有内部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"bbbb"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"cccc"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"dddd"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callHideMethod</span><span class="params">(String className, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">            Method method = aClass.getMethod(methodName);</span><br><span class="line">            Object instance = aClass.newInstance();</span><br><span class="line">            method.invoke(instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = AnonymousTest.makeA();</span><br><span class="line">        a.a();</span><br><span class="line">        System.out.println();</span><br><span class="line">        String name = a.getClass().getName();</span><br><span class="line">        callHideMethod(name, <span class="string">"b"</span>);</span><br><span class="line">        callHideMethod(name, <span class="string">"c"</span>);</span><br><span class="line">        callHideMethod(name, <span class="string">"d"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过反射修改私有变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithPrivateFinalField</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s = <span class="string">"I'm totally safe"</span>; <span class="comment">// 常量字符串  </span></span><br><span class="line">    <span class="keyword">private</span> String s2 = <span class="string">"Am I safe?"</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"private int i = "</span> + i + <span class="string">", private final String s = "</span> + s + <span class="string">", private String s2 = "</span> + s2;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 荔枝-通过反射访问和修改私有变量，私有常量的荔枝  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModifyingPrivateFields</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        WithPrivateFinalField pf = <span class="keyword">new</span> WithPrivateFinalField();  </span><br><span class="line">          </span><br><span class="line">        System.out.println(pf + <span class="string">"\n"</span>);  </span><br><span class="line">        <span class="comment">// 通过反射访问私有变量i  </span></span><br><span class="line">        Field f = pf.getClass().getDeclaredField(<span class="string">"i"</span>);  </span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>); <span class="comment">// 设置字段 i 的可访问权限为true  </span></span><br><span class="line">        System.out.println(<span class="string">"Field f = pf.getClass().getDeclaredField(\"i\"); f.setAccessible(true); f.getInt(pf) = "</span> + f.getInt(pf));  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 通过反射更改私有变量i  </span></span><br><span class="line">        f.setInt(pf, <span class="number">47</span>);  </span><br><span class="line">        System.out.println(<span class="string">"f.setInt(pf, 47); f.get(pf) = "</span> + f.get(pf));  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 通过反射访问私有常量s  </span></span><br><span class="line">        f = pf.getClass().getDeclaredField(<span class="string">"s"</span>);  </span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>); <span class="comment">// 设置字段 s 的可访问权限为true  </span></span><br><span class="line">        System.out.println(<span class="string">"f = pf.getClass().getDeclaredField(\"s\"); f.setAccessible(true); f.get(pf) 静态常量修改前 = "</span> + f.get(pf));  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 但通过反射甚至可以修改私有常量(final) s   </span></span><br><span class="line">        f.set(pf, <span class="string">"No, you're not!"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"f.set(pf, \"No, you're not!\");, f.get(pf) 静态常量修改后 = "</span> + f.get(pf));  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 通过反射访问私有变量s2  </span></span><br><span class="line">        f = pf.getClass().getDeclaredField(<span class="string">"s2"</span>);  </span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">        System.out.println(<span class="string">"f = pf.getClass().getDeclaredField(\"s2\"); f.setAccessible(true); f.get(pf) = "</span> + f.get(pf));  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 通过反射修改私有变量s2  </span></span><br><span class="line">        f.set(pf, <span class="string">"No, you're not!"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"f.set(pf, \"No, you're not!\"); f.get(pf) = "</span> + f.get(pf));  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">private int i = 1, private final String s = I'm totally safe, private String s2 = Am I safe? </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Field f = pf.getClass().getDeclaredField("i"); f.setAccessible(true); f.getInt(pf) = 1 // 通过反射机制【访问】私有变量 </span></span><br><span class="line"><span class="comment">f.setInt(pf, 47); f.get(pf) = 47 // 通过反射机制 【修改】 私有变量 </span></span><br><span class="line"><span class="comment">f = pf.getClass().getDeclaredField("s"); f.setAccessible(true); f.get(pf) = I'm totally safe // 通过反射机制【访问】私有常量 </span></span><br><span class="line"><span class="comment">f.set(pf, "No, you're not!");, f.get(pf) = No, you're not! // 通过反射机制【修改】私有常量【（这个牛逼了）】 </span></span><br><span class="line"><span class="comment">f = pf.getClass().getDeclaredField("s2"); f.setAccessible(true); f.get(pf) = Am I safe? // 通过反射机制【访问】私有变量 </span></span><br><span class="line"><span class="comment">f.set(pf, "No, you're not!"); f.get(pf) = No, you're not! // 通过反射机制【修改】私有变量 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面向对象编程语言的目的：凡是可以在使用的地方都使用多态机制，只在必需的时候使用 RTTI 。</p><p>不要过早关注程序的效率问题。最好首先让程序运行起来，然后考虑他的速度。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://blog.csdn.net/pacosonswjtu/article/details/78817812" target="_blank" rel="noopener">thinking-in-java（14）类型信息</a></p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 13-字符串</title>
      <link href="/article/thinking_in_java_13/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><h2 id="不可变-String"><a href="#不可变-String" class="headerlink" title="不可变 String"></a>不可变 String</h2><blockquote><p><code>String</code> 对象是不可变的，具有只读特性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String q = <span class="string">"howdy"</span>;  </span><br><span class="line">        print(q); <span class="comment">// howdy  </span></span><br><span class="line">        String qq = upcase(q);  </span><br><span class="line">        print(qq); <span class="comment">// HOWDY  </span></span><br><span class="line">        print(q); <span class="comment">// howdy(原有 String 没有改变)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// out:</span></span><br><span class="line"><span class="comment">// howdy  </span></span><br><span class="line"><span class="comment">// HOWDY  </span></span><br><span class="line"><span class="comment">// howdy</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="重载运算符-与-StringBuilder"><a href="#重载运算符-与-StringBuilder" class="headerlink" title="重载运算符 + 与 StringBuilder"></a>重载运算符 + 与 StringBuilder</h2><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><blockquote><p> 一个操作符在应用于特定的类时， 被赋予特殊意义。用于<code>String</code> 的 + 和 +=  是java中仅有的两个重载过的操作符，而java 并不允许程序员重载任何操作符</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concatenation</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String mango = <span class="string">"mango"</span>;  </span><br><span class="line">        String s = <span class="string">"abc"</span> + mango + <span class="string">"def"</span> + <span class="number">47</span>;  </span><br><span class="line">        System.out.println(s);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// out:</span></span><br><span class="line"><span class="comment">// abcmangodef47</span></span><br></pre></td></tr></table></figure><p>字符串连接符 + 的性能非常低下。。因为为了生成最终的 <code>string</code>， 会产生大量需要垃圾回收的中间对象.</p><h4 id="通过-javap-来反编译-Concatenation"><a href="#通过-javap-来反编译-Concatenation" class="headerlink" title="通过 javap 来反编译 Concatenation"></a>通过 javap 来反编译 Concatenation</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Concatenation.java"</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">chapter13</span>.<span class="title">Concatenation</span> &#123;</span>  </span><br><span class="line">  <span class="keyword">public</span> chapter13.Concatenation();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V  </span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(java.lang.String[]);  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String mango  </span></span><br><span class="line">       <span class="number">2</span>: astore_1  </span><br><span class="line">       <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/StringBuilder  </span></span><br><span class="line">       <span class="number">6</span>: dup  </span><br><span class="line">       <span class="number">7</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder."&lt;init&gt;":()V  </span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String abc  </span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  </span></span><br><span class="line">      <span class="number">15</span>: aload_1  </span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  </span></span><br><span class="line">      <span class="number">19</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String def  </span></span><br><span class="line">      <span class="number">21</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  </span></span><br><span class="line">      <span class="number">24</span>: bipush        <span class="number">47</span>  </span><br><span class="line">      <span class="number">26</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;  </span></span><br><span class="line">      <span class="number">29</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;  </span></span><br><span class="line">      <span class="number">32</span>: astore_2  </span><br><span class="line">      <span class="number">33</span>: getstatic     #<span class="number">10</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;  </span></span><br><span class="line">      <span class="number">36</span>: aload_2  </span><br><span class="line">      <span class="number">37</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V  </span></span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器自动引入了 <code>java.lang.StringBuilder</code> 类，即使源代码中没有使用 <code>StringBuilder</code>， 但是显然<code>StringBuilder</code> 更加有效。</p><h4 id="编译器对-String-的优化"><a href="#编译器对-String-的优化" class="headerlink" title="编译器对 String 的优化"></a>编译器对 String 的优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 StringBuilder.append() 来重载 + 运算符  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitherStringBuilder</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">implicit</span><span class="params">(String[] fields)</span> </span>&#123; <span class="comment">// 方法一：使用多个String对象  </span></span><br><span class="line">        String result = <span class="string">""</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) <span class="comment">// （效率低）隐式创建 StringBuilder  </span></span><br><span class="line">            result += fields[i];   </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125; <span class="comment">// 因为 StringBuilder是在循环内创建的，这意味着 每经过循环一次，就会创建一个新的 StringBuilder对象  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">explicit</span><span class="params">(String[] fields)</span> </span>&#123;  <span class="comment">// 方法二：使用StringBuilder，因为效率高  </span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(); <span class="comment">// （效率高）显式创建 StringBuilder  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++)  </span><br><span class="line">            result.append(fields[i]);  </span><br><span class="line">        <span class="keyword">return</span> result.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringBuilder-其他特点"><a href="#StringBuilder-其他特点" class="headerlink" title="StringBuilder 其他特点"></a>StringBuilder 其他特点</h4><p>可以为<code>StringBuilder</code> 预先指定大小，如果知道最终的字符串长度，可以预先指定<code>StringBuilder</code>的大小， 以避免多次 重新分配缓冲。</p><p>如果要在toString() 方法中使用循环的话，最好自己创建一个<code>StringBuidler</code> 对象。</p><p> insert, replace, substring, reverse, 最常用的方法是 <code>append</code> 和 <code>toString()</code> 方法。</p><p><code>StringBuilder</code> 线程不安全，效率高， <code>StringBuffer</code> 线程安全，效率低。</p><h2 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h2><p><strong>所有java的根基类都是 Object，</strong> 所以容器类都有 <code>toString()</code> 方法。 容器的<code>toString()</code> 方法都能够表达容器自身和容器所包含的 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限递归 使得 java虚拟机栈被顶满, 然后抛出异常  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         <span class="comment">// toString() 中的this关键字是 引起无限递归的原因  </span></span><br><span class="line"><span class="comment">//      return " InfiniteRecursion address: " + this + "\n"; // Exception in thread "main" java.lang.StackOverflowError  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" InfiniteRecursion address: "</span> + <span class="keyword">super</span>.toString() + <span class="string">"\n"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;InfiniteRecursion&gt; v = <span class="keyword">new</span> ArrayList&lt;InfiniteRecursion&gt;();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  </span><br><span class="line">            v.add(<span class="keyword">new</span> InfiniteRecursion());  </span><br><span class="line">        System.out.println(v);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[ InfiniteRecursion address: chapter13.InfiniteRecursion@15db9742 </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@6d06d69c </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@7852e922 </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@4e25154f </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@70dea4e </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@5c647e05 </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@33909752 </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@55f96302 </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@3d4eac69 </span></span><br><span class="line"><span class="comment">,  InfiniteRecursion address: chapter13.InfiniteRecursion@42a57993 </span></span><br><span class="line"><span class="comment">] </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>这里发生了自动类型转换：</strong> 由 <code>InfiniteRecursion</code>类型转换为 <code>String</code> 类型。 this前面的是字符串，后面是换行符， 所以 <code>this</code> 转换为 <code>String</code>， 即调用了 <code>this.toString()</code> 方法， 于是就发生了 <strong>递归调用 toString() 方法</strong>，无限递归使得 java 虚拟机栈被顶满； 然后抛出异常；<strong>把this换做 super.toString() 方法后 执行成功</strong></p><h2 id="String-上的操作"><a href="#String-上的操作" class="headerlink" title="String 上的操作"></a>String 上的操作</h2><p><code>String</code> 对象的基本方法</p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-04-15-String%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95.png" alt="String基本方法1"></p><p><img src="http://owj4ejy7m.bkt.clouddn.com/2018-04-15-String%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95.png" alt="String基本方法2"></p><p>当需要改变字符串的内容， <code>String</code> 类的方法都会返回一个新的 <code>String</code> 对象，如果没有改变，则返回原对象的引用。</p><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>通过 <code>System.out.format()</code> 输出格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// System.out.format() 输出格式  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFormat</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;  </span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">5.332542</span>;  </span><br><span class="line">        <span class="comment">// The old way:  </span></span><br><span class="line">        System.out.println(<span class="string">"Row 1: ["</span> + x + <span class="string">" "</span> + y + <span class="string">"]"</span>);  </span><br><span class="line">        <span class="comment">// The new way:  </span></span><br><span class="line">        System.out.format(<span class="string">"Row 1: [%d %f]\n"</span>, x, y); <span class="comment">// format() 方法的荔枝  </span></span><br><span class="line">        <span class="comment">// or  </span></span><br><span class="line">        System.out.printf(<span class="string">"Row 1: [%d %f]\n"</span>, x, y); <span class="comment">// printf() 方法荔枝  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542] </span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542] </span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542] </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>具体转换字符格式</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>整数型(10进制)</td></tr><tr><td>c</td><td>Unicode 字符</td></tr><tr><td>b</td><td>Boolean 值</td></tr><tr><td>s</td><td>String</td></tr><tr><td>f</td><td>浮点数</td></tr><tr><td>x</td><td>整数(16进制)</td></tr><tr><td>h</td><td>散列码(16进制)</td></tr><tr><td>%</td><td>字符 % 或类型转换字符前缀</td></tr></tbody></table><p>具体例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Formatter 对各种数据类型转换的荔枝 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Conversion</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Formatter f = <span class="keyword">new</span> Formatter(System.out);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">char</span> u = <span class="string">'a'</span>;    </span><br><span class="line">        System.out.println(<span class="string">"u = 'a'"</span>); <span class="comment">// u = 'a'  </span></span><br><span class="line">          </span><br><span class="line">        f.format(<span class="string">"%%s: %s\n"</span>, u); <span class="comment">// %s: a  </span></span><br><span class="line">          </span><br><span class="line">        f.format(<span class="string">"%%c: %c\n"</span>, u); <span class="comment">// %c: a  </span></span><br><span class="line">        f.format(<span class="string">"%%b: %b\n"</span>, u); <span class="comment">// %b: true  </span></span><br><span class="line">        f.format(<span class="string">"%%h: %h\n"</span>, u); <span class="comment">// %h: 61  </span></span><br><span class="line"><span class="comment">//       f.format("d: %d\n", u); //  java.util.IllegalFormatConversionException: d != java.lang.Character  </span></span><br><span class="line"><span class="comment">//       f.format("f: %f\n", u); // java.util.IllegalFormatConversionException: f != java.lang.Character  </span></span><br><span class="line"><span class="comment">//       f.format("e: %e\n", u); // java.util.IllegalFormatConversionException: e != java.lang.Character  </span></span><br><span class="line"><span class="comment">//       f.format("x: %x\n", u); // java.util.IllegalFormatConversionException: x != java.lang.Character  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">121</span>;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(<span class="string">"v = 121"</span>); <span class="comment">// v = 121  </span></span><br><span class="line">          </span><br><span class="line">        f.format(<span class="string">"%%d: %d\n"</span>, v); <span class="comment">// %d: 121  </span></span><br><span class="line">        f.format(<span class="string">"%%c: %c\n"</span>, v); <span class="comment">// %c: y  </span></span><br><span class="line">        f.format(<span class="string">"%%b: %b\n"</span>, v); <span class="comment">// %b: true   </span></span><br><span class="line">        f.format(<span class="string">"%%s: %s\n"</span>, v); <span class="comment">// %s: 121  </span></span><br><span class="line">        f.format(<span class="string">"%%x: %x\n"</span>, v); <span class="comment">// %x: 79  </span></span><br><span class="line">        f.format(<span class="string">"%%h: %h\n"</span>, v); <span class="comment">// %h: 79   </span></span><br><span class="line"><span class="comment">//       f.format("f: %f\n", v); // java.util.IllegalFormatConversionException: f != java.lang.Integer  </span></span><br><span class="line"><span class="comment">//       f.format("e: %e\n", v); // java.util.IllegalFormatConversionException: e != java.lang.Integer  </span></span><br><span class="line">  </span><br><span class="line">        BigInteger w = <span class="keyword">new</span> BigInteger(<span class="string">"50000000000000"</span>);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(<span class="string">"w = new BigInteger(\"50000000000000\")"</span>); <span class="comment">// w = new BigInteger("50000000000000")  </span></span><br><span class="line">        f.format(<span class="string">"%%d: %d\n"</span>, w); <span class="comment">// %d: 50000000000000  </span></span><br><span class="line">        f.format(<span class="string">"%%b: %b\n"</span>, w); <span class="comment">// %b: true  </span></span><br><span class="line">        f.format(<span class="string">"%%s: %s\n"</span>, w); <span class="comment">// %s: 50000000000000  </span></span><br><span class="line">        f.format(<span class="string">"%%x: %x\n"</span>, w); <span class="comment">// %x: 2d79883d2000  </span></span><br><span class="line">        f.format(<span class="string">"%%h: %h\n"</span>, w); <span class="comment">// %h: 8842a1a7  </span></span><br><span class="line"><span class="comment">//       f.format("c: %c\n", w); // java.util.IllegalFormatConversionException: c != java.math.BigInteger  </span></span><br><span class="line"><span class="comment">//       f.format("f: %f\n", w); // java.util.IllegalFormatConversionException: f != java.math.BigInteger  </span></span><br><span class="line"><span class="comment">//       f.format("e: %e\n", w); // java.util.IllegalFormatConversionException: e != java.math.BigInteger  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">179.543</span>;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(<span class="string">"x = 179.543"</span>); <span class="comment">// x = 179.543  </span></span><br><span class="line">        f.format(<span class="string">"%%b: %b\n"</span>, x); <span class="comment">// %b: true  </span></span><br><span class="line">        f.format(<span class="string">"%%s: %s\n"</span>, x); <span class="comment">// %s: 179.543  </span></span><br><span class="line">        f.format(<span class="string">"%%f: %f\n"</span>, x); <span class="comment">// %f: 179.543000  </span></span><br><span class="line">        f.format(<span class="string">"%%e: %e\n"</span>, x); <span class="comment">//%e: 1.795430e+02, 科学表示法  </span></span><br><span class="line">        f.format(<span class="string">"%%h: %h\n"</span>, x); <span class="comment">// %h: 1ef462c  </span></span><br><span class="line"><span class="comment">//       f.format("d: %d\n", x); // java.util.IllegalFormatConversionException: d != java.lang.Double  </span></span><br><span class="line"><span class="comment">//       f.format("c: %c\n", x); // java.util.IllegalFormatConversionException: c != java.lang.Double  </span></span><br><span class="line"><span class="comment">//       f.format("x: %x\n", x); // java.util.IllegalFormatConversionException: x != java.lang.Double  </span></span><br><span class="line">  </span><br><span class="line">        Conversion y = <span class="keyword">new</span> Conversion();  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(<span class="string">"y = new Conversion()"</span>); <span class="comment">// y = new Conversion()  </span></span><br><span class="line">        f.format(<span class="string">"%%b: %b\n"</span>, y); <span class="comment">// %b: true  </span></span><br><span class="line">        f.format(<span class="string">"%%s: %s\n"</span>, y); <span class="comment">// %s: chapter13.Conversion@4aa298b7  </span></span><br><span class="line">        f.format(<span class="string">"%%h: %h\n"</span>, y); <span class="comment">// %h: 4aa298b7  </span></span><br><span class="line"><span class="comment">//       f.format("d: %d\n", y); // java.util.IllegalFormatConversionException: d != chapter13.Conversion  </span></span><br><span class="line"><span class="comment">//       f.format("c: %c\n", y); // java.util.IllegalFormatConversionException: c != chapter13.Conversion  </span></span><br><span class="line"><span class="comment">//       f.format("f: %f\n", y); // java.util.IllegalFormatConversionException: f != chapter13.Conversion  </span></span><br><span class="line"><span class="comment">//       f.format("e: %e\n", y); // java.util.IllegalFormatConversionException: e != chapter13.Conversion  </span></span><br><span class="line"><span class="comment">//       f.format("x: %x\n", y); // java.util.IllegalFormatConversionException: x != chapter13.Conversion  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">boolean</span> z = <span class="keyword">false</span>;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(<span class="string">"z = false"</span>); <span class="comment">// z = false  </span></span><br><span class="line">        f.format(<span class="string">"%%b: %b\n"</span>, z); <span class="comment">// %b: false  </span></span><br><span class="line">        f.format(<span class="string">"%%s: %s\n"</span>, z); <span class="comment">// %s: false  </span></span><br><span class="line">        f.format(<span class="string">"%%h: %h\n"</span>, z); <span class="comment">// %h: 4d5  </span></span><br><span class="line"><span class="comment">//       f.format("d: %d\n", z); // java.util.IllegalFormatConversionException: d != java.lang.Boolean  </span></span><br><span class="line"><span class="comment">//       f.format("c: %c\n", z); // java.util.IllegalFormatConversionException: c != java.lang.Boolean  </span></span><br><span class="line"><span class="comment">//       f.format("f: %f\n", z); // java.util.IllegalFormatConversionException: f != java.lang.Boolean  </span></span><br><span class="line"><span class="comment">//       f.format("e: %e\n", z); // java.util.IllegalFormatConversionException: e != java.lang.Boolean  </span></span><br><span class="line"><span class="comment">//       f.format("x: %x\n", z); // java.util.IllegalFormatConversionException: x != java.lang.Boolean  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>要想学好正则表达式，基本上要记住的就是一堆语法。</p><p>废话不多说，直接看如何创建正则表达式。</p><p><strong>字符</strong></p><table><thead><tr><th>正则表达式</th><th>说明</th></tr></thead><tbody><tr><td>B</td><td>指定字符B</td></tr><tr><td>\xhh</td><td>十六进制值为0xhh的字符</td></tr><tr><td>\uhhhh</td><td>十六进制表示为0xhhhh的Unicode字符</td></tr><tr><td>\t</td><td>制表符Tab</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\e</td><td>转义</td></tr></tbody></table><p><strong>字符类</strong></p><table><thead><tr><th>正则表达式</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>[abc]</td><td>包含a、b和c的任何字符</td></tr><tr><td>[^abc]</td><td>除了a、b和c之外的任何字符(否定)</td></tr><tr><td>[a-zA-Z]</td><td>从a到z或从A到Z的任何字符(范围)</td></tr><tr><td>[abc[hij]]</td><td>任意abchij字符</td></tr><tr><td>[a-z&amp;&amp;[hij]]</td><td>任意h、i或j(相交)</td></tr><tr><td>\s</td><td>空白符(空格、tab、换行和回车)</td></tr><tr><td>\S</td><td>非空白符</td></tr><tr><td>\d</td><td>数字[0-9]</td></tr><tr><td>\D</td><td>非数字<code>[^0-9]</code></td></tr><tr><td>\w</td><td>词字符([a-zA-Z0-9])</td></tr><tr><td>\W</td><td>非词字符</td></tr></tbody></table><p><strong>逻辑操作符</strong></p><table><thead><tr><th>正则表达式</th><th>说明</th></tr></thead><tbody><tr><td>XY</td><td>Y跟在后面</td></tr><tr><td>`X\</td><td>Y`</td><td>X或Y</td></tr><tr><td>(X)</td><td>捕获组</td></tr></tbody></table><p><strong>量词</strong></p><table><thead><tr><th style="text-align:center">贪婪型</th><th style="text-align:center">勉强型</th><th style="text-align:center">占有型</th><th style="text-align:center">如何匹配</th></tr></thead><tbody><tr><td style="text-align:center">X?</td><td style="text-align:center">X??</td><td style="text-align:center">X?+</td><td style="text-align:center">一个或零个X</td></tr><tr><td style="text-align:center">X*</td><td style="text-align:center">X*?</td><td style="text-align:center">X*+</td><td style="text-align:center">零个或多个X</td></tr><tr><td style="text-align:center">X+</td><td style="text-align:center">X+?</td><td style="text-align:center">X++</td><td style="text-align:center">一个或多个X</td></tr><tr><td style="text-align:center">X{n}</td><td style="text-align:center">x{n}?</td><td style="text-align:center">X{n}+</td><td style="text-align:center">恰好n次X</td></tr><tr><td style="text-align:center">X{n,}</td><td style="text-align:center">X{n,}?</td><td style="text-align:center">X{n,}+</td><td style="text-align:center">至少n次X</td></tr><tr><td style="text-align:center">X{n,m}</td><td style="text-align:center">X{n,m}?</td><td style="text-align:center">X{n,m}+</td><td style="text-align:center">X至少n次，且不超过m次</td></tr></tbody></table><p>表达式 X 通常必须用圆括号括起来。</p><h4 id="Pattern-和-Matcher"><a href="#Pattern-和-Matcher" class="headerlink" title="Pattern 和 Matcher"></a>Pattern 和 Matcher</h4><ol><li>Pattern.compile(regex) 编译 <code>regex</code> 并产生 <code>Pattern</code> 对象。</li><li>Pattern.matcher(检索的字符串)生成一个 <code>Matcher</code> 对象。</li></ol><p><strong>基本用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String[] array = &#123;<span class="string">"aabbcc"</span>, <span class="string">"aab"</span>, <span class="string">"aab+"</span>, <span class="string">"(b+)"</span>&#125;;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (String arg : array) &#123;  </span><br><span class="line">            System.out.println();  </span><br><span class="line">            print(<span class="string">"Regular expression: \""</span> + arg + <span class="string">"\""</span>);  </span><br><span class="line">            Pattern p = Pattern.compile(arg); <span class="comment">// step1: Pattern 表示编译后的匹配模型Pattern.（编译后的正则表达式）  </span></span><br><span class="line">            Matcher m = p.matcher(<span class="string">"aabbcc"</span>); <span class="comment">// step2: 模型实例 检索 待匹配字符串并 生成一个匹配对象Matcher， Matcher有很多方法  </span></span><br><span class="line">            <span class="keyword">while</span> (m.find()) &#123;  </span><br><span class="line">                print(<span class="string">"Match \""</span> + m.group() <span class="comment">// 待匹配的字符串  </span></span><br><span class="line">                                 + <span class="string">"\" at positions "</span>   </span><br><span class="line">                                 + m.start() <span class="comment">// 字符串匹配regex的起始位置  </span></span><br><span class="line">                                 + <span class="string">"-"</span> + (m.end() - <span class="number">1</span>)); <span class="comment">// 字符串匹配regex的终点位置  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Matcher 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span></span>; <span class="comment">//判断 输入字符串 是否匹配正则表达式regex；  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span></span>; <span class="comment">//判断输入字符串（不是整个）的开始部分是否匹配 regex；  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span></span>; <span class="comment">//用于 在 CharSequence 输入字符串中查找多个匹配；  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span></span>;  <span class="comment">//用于在 CharSequence 输入字符串的start 位置开始查找多个匹配；  </span></span><br><span class="line"><span class="function">String <span class="title">group</span><span class="params">()</span></span>; <span class="comment">//用于返回匹配regex的输入字符串的子串；</span></span><br></pre></td></tr></table></figure><p><strong>常用的 Pattern 标记</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex, <span class="keyword">int</span> flags)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pattern(regex, flags);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Pattern.CASE_INSENSITIVE：  不区分大小写；</span></span><br><span class="line"><span class="comment">// Pattern.MULTILINE： 允许多行，即不以换行字符作为分隔符；</span></span><br><span class="line"><span class="comment">// Pattern.COMMENTS： 模式中允许空格和注释， 不以空格和注释作为分隔符</span></span><br></pre></td></tr></table></figure><p><strong>Pattern.split()</strong></p><p>将字符串分割成符合 <code>regex</code> 的字符数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String input = <span class="string">"This!!unusual use!!of exclamation!!points"</span>;  </span><br><span class="line">        print(Arrays.toString(Pattern.compile(<span class="string">"!!"</span>).split(input))); <span class="comment">// split(input, 0); 对匹配次数不做任何限制  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* (只匹配前2个 !! ) */</span>  </span><br><span class="line">        <span class="comment">/* 注意：分割边界在分割结果中被删除 */</span>  </span><br><span class="line">        print(Arrays.toString(Pattern.compile(<span class="string">"!!"</span>).split(input, <span class="number">3</span>))); <span class="comment">// 限定匹配次数，limit限制将输入字符串分割成数组的数组大小  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[This, unusual use, of exclamation, points] </span></span><br><span class="line"><span class="comment">[This, unusual use, of exclamation!!points] </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="扫描输入"><a href="#扫描输入" class="headerlink" title="扫描输入"></a>扫描输入</h2><p>使用 <code>BufferedReader</code> 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRead</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(  </span><br><span class="line">            <span class="string">"Sir Robin of Camelot\n22 1.61803"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"\n1.What is your name?"</span>);  </span><br><span class="line">            String name = input.readLine();  </span><br><span class="line">            System.out.println(name); <span class="comment">// Sir Robin of Camelot  </span></span><br><span class="line">              </span><br><span class="line">            System.out.println(<span class="string">"\n2.input: &lt;age&gt; &lt;double&gt;"</span>);  </span><br><span class="line">            String numbers = input.readLine();  </span><br><span class="line">            System.out.println(<span class="string">"input.readLine() = "</span> + numbers); <span class="comment">// 22 1.61803  </span></span><br><span class="line">              </span><br><span class="line">            String[] numArray = numbers.split(<span class="string">" "</span>);  </span><br><span class="line">            <span class="keyword">int</span> age = Integer.parseInt(numArray[<span class="number">0</span>]); <span class="comment">// 22  </span></span><br><span class="line">            <span class="keyword">double</span> favorite = Double.parseDouble(numArray[<span class="number">1</span>]); <span class="comment">// 1.61803  </span></span><br><span class="line">              </span><br><span class="line">            System.out.format(<span class="string">"Hi %s.\n"</span>, name);  </span><br><span class="line">            System.out.format(<span class="string">"In 5 years you will be %d.\n"</span>, age + <span class="number">5</span>);  </span><br><span class="line">            System.out.format(<span class="string">"My favorite double is %f."</span>, favorite / <span class="number">2</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            System.err.println(<span class="string">"I/O exception"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 1.What is your name? </span></span><br><span class="line"><span class="comment">Sir Robin of Camelot </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">2.input: &lt;age&gt; &lt;double&gt; </span></span><br><span class="line"><span class="comment">input.readLine() = 22 1.61803 </span></span><br><span class="line"><span class="comment">Hi Sir Robin of Camelot. </span></span><br><span class="line"><span class="comment">In 5 years you will be 27. </span></span><br><span class="line"><span class="comment">My favorite double is 0.809015. </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>使用 <code>Scanner</code> 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterRead</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// Scanner 可以接受任何类型的 Readable 输入对象  </span></span><br><span class="line">        Scanner stdin = <span class="keyword">new</span> Scanner(SimpleRead.input);  </span><br><span class="line">        System.out.println(<span class="string">"What is your name?"</span>);  </span><br><span class="line">        <span class="comment">// 所有的输入，分词以及翻译的操作都隐藏在不同类型的 next 方法 中.  </span></span><br><span class="line">        String name = stdin.nextLine(); <span class="comment">// nextLine() 返回 String  </span></span><br><span class="line">        System.out.println(name);  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"How old are you? What is your favorite double?"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"(input: &lt;age&gt; &lt;double&gt;)"</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// Scanner 直接读入 integer 和 double 类型数据  </span></span><br><span class="line">        <span class="keyword">int</span> age = stdin.nextInt();  </span><br><span class="line">        <span class="keyword">double</span> favorite = stdin.nextDouble();  </span><br><span class="line">        System.out.println(age);  </span><br><span class="line">        System.out.println(favorite);  </span><br><span class="line">          </span><br><span class="line">        System.out.format(<span class="string">"Hi %s.\n"</span>, name);  </span><br><span class="line">        System.out.format(<span class="string">"In 5 years you will be %d.\n"</span>, age + <span class="number">5</span>);  </span><br><span class="line">        System.out.format(<span class="string">"My favorite double is %f."</span>, favorite / <span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">What is your name? </span></span><br><span class="line"><span class="comment">Sir Robin of Camelot </span></span><br><span class="line"><span class="comment">How old are you? What is your favorite double? </span></span><br><span class="line"><span class="comment">(input: &lt;age&gt; &lt;double&gt;) </span></span><br><span class="line"><span class="comment">22 </span></span><br><span class="line"><span class="comment">1.61803 </span></span><br><span class="line"><span class="comment">Hi Sir Robin of Camelot. </span></span><br><span class="line"><span class="comment">In 5 years you will be 27. </span></span><br><span class="line"><span class="comment">My favorite double is 0.809015.</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过去， <code>Java</code> 对字符串操作的支持相当不完善。不过随着近几个版本的升级，我们可以看到， <code>Java</code> 已经从其他语言中吸取了许多成熟的经验。到目前为止，它对字符串操作的支持已经很完善了。不过，有时你还要在细节上注意效率的问题，例如恰当地使用 <code>StringBuilder</code> 等。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://blog.csdn.net/pacosonswjtu/article/details/78631796" target="_blank" rel="noopener">thinking-in-java(13) String字符串</a></p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 12-通过异常处理错误</title>
      <link href="/article/thinking_in_java_12/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p><code>Java</code> 的基本理念是 「结构不佳的代码不能运行。</p></blockquote><p>发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源通过某种方式，把适当的信息传递给某个接受者—接收者将知道如何正确处理这个问题。</p><a id="more"></a><h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><p><strong>异常情形</strong>是指阻止当前方法或作用域继续执行的问题。除法就是一个简单的例子。除数有可能为 0，所以先进行检查很有必要。但除数为 0 代表的究竟是什么意思？通过当前正在解决的问题环境，或许能知道该如何处理除数为 0 的情况。但如果这是一个意料之外的值，你也不清楚该如何处理，那就抛出异常，而不是顺着原来的路径继续执行下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"1111"</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"2222"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"a cannot be 0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"3333"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"e:"</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"4444"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是简单的异常处理情况，对于 <code>a==0</code> 这种 <strong>异常情况</strong>，我们主动抛出异常,异常的抛出方式类似 <code>Java</code>创建对象的过程，直接 <code>new NullPointerException()</code>的方式创建我们非常熟悉的 <strong>空指针</strong> 异常。</p><p>这个时候编译器会提示你需要将抛出的异常 <code>try catch</code> 掉。那么就按照提示对出现异常的位置进行捕获。在 <code>catch</code> 的地方进行异常的处理。</p><p><code>finally</code> 块内的代表着无论是否出现异常，这段代码块的内容都会执行。</p><p>看一下运行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: a cannot be <span class="number">0</span></span><br><span class="line"><span class="number">1111</span></span><br><span class="line"><span class="number">2222</span></span><br><span class="line"><span class="number">3333</span></span><br><span class="line">e:a cannot be <span class="number">0</span></span><br><span class="line"><span class="number">4444</span></span><br><span class="line">at chapter12.ExceptionTest.main(ExceptionTest.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><p>不必拘泥于 <code>Java</code> 中已有的异常类型。 <code>Java</code> 提供的异常体系不可能预见所有的希望加以报告的错误，所以可以自己定义异常类来表示程序中可能会遇到的特定问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1111"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"2222"</span>);</span><br><span class="line">            f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"3333"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常的栈轨迹"><a href="#异常的栈轨迹" class="headerlink" title="异常的栈轨迹"></a>异常的栈轨迹</h2><p><code>printStackTrace()</code> 方法所提供的信息可以通过 <code>getStackTrace()</code> 方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。看一下代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackTraceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"null"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement stackTraceElement : e.getStackTrace()) &#123;</span><br><span class="line">                System.out.println(stackTraceElement.getMethodName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        g();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        g();</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f</span><br><span class="line">main</span><br><span class="line">----------</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">main</span><br><span class="line">----------</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">h</span><br><span class="line">main</span><br></pre></td></tr></table></figure><p>一层一层的展示异常栈内的信息。</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>对于一些代码，可能会希望无论 <code>try</code> 块中的异常是否抛出，它们都能得到执行。这通常适用于内存回收之外的情况。为了达到这个效果，可以在异常处理程序后面加上 <code>finally</code> 子句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinallyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"111"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"222"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"222"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally clean up"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            f(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"5555555"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"dd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException: dd</span><br><span class="line">at chapter12.FinallyTest.main(FinallyTest.java:<span class="number">40</span>)</span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="keyword">finally</span> clean up</span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="keyword">finally</span> clean up</span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="keyword">finally</span> clean up</span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line">end</span><br><span class="line"><span class="keyword">finally</span> clean up</span><br><span class="line"><span class="number">5555555</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>异常是 <code>Java</code> 程序设计不可分割的一部分，如果不了解如何使用它们，那你只能完成很有限的工作。异常处理的有点之一就是它使得你可以在某处集中精力处理你要解决的问题，而在另外一处处理你编写的这段代码中产生的错误。尽管异常通常被认为是一种工具，使得你可以在运行时报告错误并从错误中恢复。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 11-持有对象</title>
      <link href="/article/thinking_in_java_11/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p>如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这是一个非常简单的程序。</p></blockquote><p>通常，程序总是根据运行时才知道的某些条件去创建新对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型。为解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象。</p><a id="more"></a><h2 id="泛型和类型安全容器"><a href="#泛型和类型安全容器" class="headerlink" title="泛型和类型安全容器"></a>泛型和类型安全容器</h2><p>在使用<code>Java SE5</code>之前的容器是允许你向容器中插入不正确的类型，为了避免这种错误，在之后对类型进行严格的编译判断。只有相同的类型或者直属导出类才能创建容器。通过使用泛型，就可以在<strong>编译器</strong>防止将错误类型的对象放置在容器中。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Java</code>容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：</p><ol><li><strong>Collection。</strong>一个独立对象的序列，这些元素都服从一条或多条规则。<strong>List</strong>必须按照插入的顺序保存元素，而 <strong>Set</strong> 不能有重复元素。<strong>Queue</strong>按照排队规则来确定对象产生的顺序(通常与它们被插入的顺序相同)。</li><li><strong>Map。</strong>一组成对的“键值对”对象，允许你使用键来查找值，因此在某种意义上讲，它将数字与对象关联在一起。<strong>映射表</strong>允许我们使用另一对象来查找某个对象，它也被称为“关联数组”，因为他将某些对象与另外一些对象关联在一起了。<strong>Map</strong> 是强大的编程工具。</li></ol><h2 id="容器的打印"><a href="#容器的打印" class="headerlink" title="容器的打印"></a>容器的打印</h2><p>通过代码来看一下效果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintContainers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Collection <span class="title">fill</span><span class="params">(Collection&lt;String&gt; collection)</span> </span>&#123;</span><br><span class="line">        collection.add(<span class="string">"rat"</span>);</span><br><span class="line">        collection.add(<span class="string">"cat"</span>);</span><br><span class="line">        collection.add(<span class="string">"dog"</span>);</span><br><span class="line">        collection.add(<span class="string">"dog"</span>);</span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map <span class="title">fill</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="string">"rat"</span>, <span class="string">"Fuzzy"</span>);</span><br><span class="line">        map.put(<span class="string">"cat"</span>, <span class="string">"Rags"</span>);</span><br><span class="line">        map.put(<span class="string">"dog"</span>, <span class="string">"Bosco"</span>);</span><br><span class="line">        map.put(<span class="string">"dog"</span>, <span class="string">"Spot"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> ArrayList&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedList&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashSet&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeSet&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashSet&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashMap&lt;String, String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeMap&lt;String, String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[rat, cat, dog, dog]</span><br><span class="line">[rat, cat, dog, dog]</span><br><span class="line">[rat, cat, dog]</span><br><span class="line">[cat, dog, rat]</span><br><span class="line">[rat, cat, dog]</span><br><span class="line">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span><br><span class="line">&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;</span><br><span class="line">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>有两种 <strong>List</strong>类型的容器：</p><ul><li><strong>ArrayList。</strong>它擅长于随机访问元素，但是在 <strong>List</strong> 中间插入数据和移除元素时比较慢。</li><li><strong>LinkedList。</strong>它通过代价低的在 <strong>List</strong> 中间进行插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong>在随机访问方面相对比较慢，但是它的特性集较 <strong>ArrayList</strong> 更大。</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>迭代器</strong>是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序不必知道或关心该序列底层的结构。此外迭代器通常被称为 <strong>轻量级对象</strong>：创建它的代价小。</p><p><code>Java</code>的 <strong>Iterator</strong> 只能单向移动，这个 <strong>Iterator</strong> 只能用来：</p><ol><li>使用方法 <code>iterator()</code>要求容器返回一个 <code>Iterator</code>。</li><li>使用 <code>next()</code>获得序列中的下一个元素。</li><li>使用 <code>hasNext()</code> 检查序列中是否还有元素。</li><li>使用 <code>remove()</code> 将迭代器新近返回的元素删除。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; data = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        data.add(<span class="number">1</span>);</span><br><span class="line">        data.add(<span class="number">2</span>);</span><br><span class="line">        data.add(<span class="number">3</span>);</span><br><span class="line">        data.add(<span class="number">4</span>);</span><br><span class="line">        data.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;Integer&gt; integerListIterator = data.listIterator(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (integerListIterator.hasNext()) &#123;</span><br><span class="line">            Integer next = integerListIterator.next();</span><br><span class="line">            System.out.println(<span class="string">"next:"</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (integerListIterator.hasPrevious()) &#123;</span><br><span class="line">            Integer previous = integerListIterator.previous();</span><br><span class="line">            System.out.println(<span class="string">"previous:"</span> + previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; data = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        data.add(<span class="number">1</span>);</span><br><span class="line">        data.add(<span class="number">2</span>);</span><br><span class="line">        data.add(<span class="number">3</span>);</span><br><span class="line">        data.add(<span class="number">4</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer next = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"data: "</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iterator = data.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code> 不保存重复的元素（至于如何判断元素相同则较为复杂）。如果你视图将相同对象的多个实例添加到 <code>Set</code>中，那么它就会阻止这种重复现象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class SetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;Integer&gt; data = new HashSet&lt;Integer&gt;();</span><br><span class="line">        data.add(1);</span><br><span class="line">        data.add(2);</span><br><span class="line">        data.add(3);</span><br><span class="line">        data.remove(4);</span><br><span class="line">        System.out.println(data.remove(1));</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>将对象映射到其他对象的能力是一种解决编程问题的杀手锏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; data = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        data.put(<span class="number">2</span>, <span class="string">"2"</span>);</span><br><span class="line">        data.put(<span class="number">1</span>, <span class="string">"1"</span>);</span><br><span class="line">        data.put(<span class="number">3</span>, <span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Java</code> 提供了大量持有对象的方式：</p><ol><li>数组将数字与对象联系起来。它保存类型明确的对象，查询对象时，不需要对结果做类型转换。它可以是多维的，可以保存基本类型的数据。但是，数组一旦生成，其容量就不能改变。</li><li><code>Collection</code> 保存单一的元素，而 <code>Map</code> 保存相关联的键值对。有了 <code>Java</code> 的泛型，你就可以指定容器中存放的对象类型，因此你就不会讲错误类型的对象放置到容器中，并且在从容器中获取元素时，不必进行类型转换。</li><li>像数组一样， <code>List</code> 也建立数字索引与对象的关联，因此，数组和 <code>List</code> 都是排好序的容器。 <code>List</code> 能够自动扩充容量。</li><li>如果进行大量的随机访问，就是用 <code>ArrayList</code>；如果经常从表中插入或删除元素，则应该使用 <code>LinkedList</code>。</li><li>各种 <code>Queue</code> 以及栈的行为，由 <code>LinkedList</code>提供支持。</li><li><code>Map</code>是一种将对象与对象相关联的设计。 <code>HashMap</code> 设计用来快速访问，而 <code>TreeMap</code> 保持 键 始终处于排序状态，所以没有 <code>HashMap</code> 快。 <code>LinkedHashMap</code> 保持元素插入的顺序，但是也通过散列提供了快速访问能力。</li><li><code>Set</code>不接受重复元素。 <code>HashSet</code> 提供最快的查询速度，而 <code>TreeSet</code> 保持元素处于排序状态。 <code>LinkedHashSet</code> 以插入顺序保存元素。</li><li>新程序中不应该使用过时的 <code>Vector</code>、 <code>Hashtable</code>和 <code>Stack</code>。</li></ol>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 10-内部类</title>
      <link href="/article/thinking_in_java_10/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内部类非常的有用，因为它允许你把一些逻辑相关的类组织在一块，并控制位于内部的类的可视性，内部类和组合是完全不同的概念，这点很重要。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    int a =2;</span><br><span class="line"></span><br><span class="line">    int f () &#123;</span><br><span class="line">        System.out.println(&quot;Outer.f&quot;);</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     class Inner &#123;</span><br><span class="line">        Outer outer() &#123;</span><br><span class="line">            System.out.println(&quot;outer a = &quot; + a);</span><br><span class="line">            return Outer.this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     private Inner inner() &#123;</span><br><span class="line">        return new Inner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        outer.inner().outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建起来也是很方便，非<code>static</code>内部类是可以持有外部类的引用，也就是使用外部类的成员变量和成员方法。</p><p>可以使用<code>Outer.this</code>拿到外部类的对象</p><h2 id="方法内部嵌套内部类"><a href="#方法内部嵌套内部类" class="headerlink" title="方法内部嵌套内部类"></a>方法内部嵌套内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line"></span><br><span class="line">    interface IWork &#123;</span><br><span class="line">        void work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IWork teach(final String content) &#123;</span><br><span class="line"></span><br><span class="line">        class Student implements IWork&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void work() &#123;</span><br><span class="line">                System.out.println(&quot;content:&quot; + content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Student();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        People people = new People();</span><br><span class="line">        people.teach(&quot;English&quot;).work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 内部也是可以嵌套内部类的，还可以使用方法的参数，不过参数要加上<code>final</code>修饰，表示不可更改对象值。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>顾名思义，就是没有名字的内部类，这种类型的内部类主要应用在不需要创建具体的实现类来实现接口，直接通过<code>new</code>的方式，在内部类实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">abstract class Base &#123;</span><br><span class="line">    Base(int i) &#123;</span><br><span class="line">        System.out.println(&quot;construct: &quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    abstract void f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnonyConstruct &#123;</span><br><span class="line">    public static Base getBase() &#123;</span><br><span class="line">        return new Base(2) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;dddd&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            void f() &#123;</span><br><span class="line">                System.out.println(&quot;Anony f&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Base base = getBase();</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Base</code>作为借口没有具体的实现内容，但是可以通过匿名内部类的方式实现具体的接口，又利用向上转型这一特性完成对接口的引用。这种匿名内部类可以有构造函数的，不过只能是这种无参的构造函数，</p><h2 id="在看工厂模式"><a href="#在看工厂模式" class="headerlink" title="在看工厂模式"></a>在看工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">interface IService &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    void method2();</span><br><span class="line">&#125;</span><br><span class="line">interface IFactory &#123;</span><br><span class="line">    IService getService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Service1 implements IService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Service1 method 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Service1 method 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static IFactory factory = new IFactory() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public IService getService() &#123;</span><br><span class="line">            return new Service1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Service2 implements IService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Service2 method 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Service2 method 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static IFactory factory = new IFactory() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public IService getService() &#123;</span><br><span class="line">            return new Service2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    static void factoryConsumer(IFactory factory) &#123;</span><br><span class="line">        IService service = factory.getService();</span><br><span class="line">        service.method1();</span><br><span class="line">        service.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        factoryConsumer(Service1.factory);</span><br><span class="line">        factoryConsumer(Service2.factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上代码，第一步创建产品和工厂的实现接口，这步是不变的，变化的是产品的具体实现中，构造了匿名内部类完成工厂具体的实现。通过这种方式也可以完成工厂模式。</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>如果不需要内部类对象与其外围类对象之间有关系，那么可以将内部了声明成<code>static</code>，这中通常被称为「嵌套类」，想要理解<code>static</code>应用内部类的含义，就必须记住，普通的内部类对象隐士的保存了一个引用，指向创建它的外围类对象，然而，当内部类是<code>static</code>时，就不是这样的了，嵌套类意味着：</p><ol><li>要创建嵌套类的对象，并不需要其外围类的对象</li><li>不要从嵌套类的对象中访问非静态的外围类对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class StaticOuter &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line"></span><br><span class="line">    StaticInner getInner() &#123;</span><br><span class="line">        return new StaticInner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class StaticInner &#123;</span><br><span class="line">        int b = 12;</span><br><span class="line">        void f() &#123;</span><br><span class="line">            System.out.println(&quot;static inner f&quot;);</span><br><span class="line">            System.out.println(&quot;b &quot; + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new StaticOuter().getInner().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Android</code>中的应用就是使用<code>Handler</code>的时候，如果直接<code>new Handler</code>的方式创建<code>handler</code>，是很容易造成空指针异常，那这个时候就需要创建内部类，但是又容易造成内存泄漏，因此就采用<code>static</code>的方式，这样没有拿到外部类的引用，就避免了内存泄漏的发生。</p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>致辞，我们已经看到许多描述内部类的语法和语义，但是这并不能回答 为什么需要内部类。</p><p>一般来说，内部类继承自某个类和实现某个接口，内部类的代码操作创建它的外围类的对象，所以可以认为内部类提供了某种进入其外围类的窗口。</p><p><strong>每个内部类都能独立地继承自一个实现，所以无论外围类是否已经继承了某个实现，对于内部类都没有影响。</strong></p><p>如果没有内部类的提供，可以继承多个具体的抽象能力，一些设计与编程问题就很难解决。从这个角度，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效的实现了多重继承。也就是说，内部类允许继承多个非接口类型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么我们仍然使用局部内部类而不是匿名内部类，唯一的理由就是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例化。，所以使用局部内部类而不是用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 9-接口</title>
      <link href="/article/thinking_in_java_9/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p>接口和内部类为我们提供一种将接口与实现分离的更加结构化的方法。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><code>interface</code>关键字使抽象的概念更买进一步，<code>abstract</code>关键字允许人们在类中创建一个或者多个没有任何定义的方法，但是没有提供任何相应的具体实现，这些实现是由此类创建者创建。<code>interface</code>这个关键字产生一个完全抽象类。它根本就没有具体的实现。</p><p><code>interface</code>不仅仅是一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继承变种的特性。</p><a id="more"></a><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class StarManager implements IStar&#123;</span><br><span class="line"></span><br><span class="line">    IStar iStar;</span><br><span class="line"></span><br><span class="line">    StarManager(IStar iStar) &#123;</span><br><span class="line">        this.iStar = iStar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sing() &#123;</span><br><span class="line">        System.out.println(&quot;找人唱歌&quot;);</span><br><span class="line">        iStar.sing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int money() &#123;</span><br><span class="line">        System.out.println(&quot;明星需要收费：&quot; + iStar.money());</span><br><span class="line">        System.out.println(&quot;代理费：&quot; + 20);</span><br><span class="line">        return iStar.money() + 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StarManager manager = new StarManager(new HuangBo());</span><br><span class="line">        manager.sing();</span><br><span class="line">        System.out.println(&quot;一共需要花费&quot; + manager.money());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IStar &#123;</span><br><span class="line">    void sing();</span><br><span class="line">    int money();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HuangBo implements IStar &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sing() &#123;</span><br><span class="line">        System.out.println(&quot;黄渤 sing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int money() &#123;</span><br><span class="line">        return 200;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上方代码所示，接口的主要作用在于告诉实现类应该做什么，但是具体要做的事情还是需要导出类进行实现。</p><p><code>Huangbo</code>作为一个<code>star</code>，自然要进行唱歌和唱歌收费，<code>StarManager</code>同样实现<code>IStar</code>接口，那就具有<code>IStar</code>同样的行为，并通过组合的方式传入<code>IStar</code>对象，起到一个代理的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找人唱歌</span><br><span class="line">黄渤 sing</span><br><span class="line">明星需要收费：200</span><br><span class="line">代理费：20</span><br><span class="line">一共需要花费210</span><br></pre></td></tr></table></figure><pre><code>StarManager manager = new StarManager(new HuangBo());manager.sing();System.out.println(&quot;一共需要花费&quot; + manager.money());</code></pre><p>通过创建<code>StarManager</code>的方式，拿到<code>HuangBo</code>对象代理，其实具体的操作在<code>StarManager</code>具体实现中实现。最终需要的<code>money</code>也就会有所变化。</p><h2 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Factories &#123;</span><br><span class="line">    private static void factoryConsumer(CarFactory carFactory) &#123;</span><br><span class="line">        ICar car = carFactory.getCar();</span><br><span class="line">        car.light();</span><br><span class="line">        car.wheel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        factoryConsumer(new BaoMaFactory());</span><br><span class="line">        factoryConsumer(new BenChiFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICar &#123;</span><br><span class="line">    void wheel();</span><br><span class="line">    void light();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface CarFactory &#123;</span><br><span class="line">    ICar getCar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaoMa implements ICar &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void wheel() &#123;</span><br><span class="line">        System.out.println(&quot;BaoMa--wheel&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void light() &#123;</span><br><span class="line">        System.out.println(&quot;BaoMa--light&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BenChi implements ICar &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void wheel() &#123;</span><br><span class="line">        System.out.println(&quot;BenChi--wheel&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void light() &#123;</span><br><span class="line">        System.out.println(&quot;BenChi--light&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaoMaFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ICar getCar() &#123;</span><br><span class="line">        return new BaoMa();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BenChiFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ICar getCar() &#123;</span><br><span class="line">        return new BenChi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接口来完成工厂模式，也是在开发的过程中经常使用的。</p><p>首先你得抽象出产品共有的行为，然后让具体的产品来实现它，比如造轮子或者汽车上面的某个零件。接下来就是建造工厂了，那工厂同样可以抽象出一个共同的特征，就是建造拥有<code>ICar</code>特征具体产品。</p><pre><code>ICar car = carFactory.getCar();car.light();car.wheel();</code></pre><p>那最终就可以通过构造工厂来完成汽车的制造，而不用过多的考虑汽车具体的构造过程，同样方便后期的维护，比如需要再添加其他零件。。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 8-多态</title>
      <link href="/article/thinking_in_java_8/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得刚接触<code>Java</code>的时候，整天被老师灌输的就是「封装」、「继承」、「抽象」和「多态」，因为这是面向对象语言基本的特征。尴尬的是，直到大学毕业了也没有彻底搞懂…</p><p>多态通过分离「做什么」和「怎么做」，从另一个角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能创建可扩展的程序–即无论在项目最初创建时还是需要添加新功能都可以生长的程序。</p><p>「封装」通过合并特征和行为来创建新的数据类型，实现隐藏则通过将细节私有化把接口和实现分离开来，这种类型的组织机制对那些拥有过程化程序设计背景的人来说，更容易理解。而「多态」的作用则是消除类型之间的耦合关系。</p><a id="more"></a><p>继承允许将对象视为它自己本身的类型或其他类型来加以处理。这种能力即为重要，因为它允许将多种类型(从同一基类导出的)视为同一类型处理。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出而来的。</p><h2 id="定位具体子类"><a href="#定位具体子类" class="headerlink" title="定位具体子类"></a>定位具体子类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Machine &#123;</span><br><span class="line">    void work() &#123;</span><br><span class="line">        System.out.println(&quot;Machine work!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Computer extends Machine &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void work() &#123;</span><br><span class="line">        System.out.println(&quot;Computer work&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Light extends Machine &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void work() &#123;</span><br><span class="line">        System.out.println(&quot;Light work&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        run(new Computer());</span><br><span class="line">        run(new Light());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void run(Machine machine) &#123;</span><br><span class="line">        machine.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code>方法传入的是基类类型的<code>Machine</code>，这样就不需要创建适配各种类型的<code>run</code>方法，加强了可维护性和代码健壮性。利用了「向上转型」这一特性，不用在乎具体的实现，只需要传入接口即可。</p><p><code>machine.work();</code>如编译器是怎么知道这个<code>machine</code>的引用是指向具体的实现的呢？「后期绑定」，它的含义就是运行时根据对象的类型进行绑定，后期绑定也叫做动态绑定或运行时绑定。编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。</p><p>Java 中除了<code>static</code>和<code>final</code>方法之外，其他所有的方法都是后期绑定，这意味着通常情况下，我们不必判定是否应该进行后期绑定。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p><strong>不能覆盖私有方法</strong></p><p><strong>域与静态方法</strong></p><h2 id="构造器的调用顺序"><a href="#构造器的调用顺序" class="headerlink" title="构造器的调用顺序"></a>构造器的调用顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    Animal() &#123;</span><br><span class="line">        System.out.println(&quot;Animal&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car &#123;</span><br><span class="line">    Car() &#123;</span><br><span class="line">        System.out.println(&quot;Car&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Water &#123;</span><br><span class="line">    Water() &#123;</span><br><span class="line">        System.out.println(&quot;Water&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class People extends Animal&#123;</span><br><span class="line">    People() &#123;</span><br><span class="line">        System.out.println(&quot;People&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends People &#123;</span><br><span class="line">    Student() &#123;</span><br><span class="line">        System.out.println(&quot;Student&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Car car = new Car();</span><br><span class="line">    private Water water = new Water();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        People student = new Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal</span><br><span class="line">People</span><br><span class="line">Car</span><br><span class="line">Water</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><p>顺序：</p><ol><li>调用基类的构造器</li><li>按声明顺序调用成员的初始化方法</li><li>调用导出类构造器的主体</li></ol><h2 id="构造器内部的多态方法的行为"><a href="#构造器内部的多态方法的行为" class="headerlink" title="构造器内部的多态方法的行为"></a>构造器内部的多态方法的行为</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Phone &#123;</span><br><span class="line"></span><br><span class="line">    Phone() &#123;</span><br><span class="line">        System.out.println(&quot;before call&quot;);</span><br><span class="line">        call();</span><br><span class="line">        System.out.println(&quot;after call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void call() &#123;</span><br><span class="line">        System.out.println(&quot;Phone Call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IPhone extends Phone &#123;</span><br><span class="line">    private String num = &quot;110&quot;;</span><br><span class="line">    IPhone(String num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">        System.out.println(&quot;number: &quot; + this.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void call() &#123;</span><br><span class="line">        System.out.println(&quot;call number: &quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IPhone iPhone = new IPhone(&quot;119&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before call</span><br><span class="line">call number: null</span><br><span class="line">after call</span><br><span class="line">number: 119</span><br></pre></td></tr></table></figure><p>从结果可以看出，在执行基类的构造函数调用到多态方法时，会调用被覆盖的具体方法，但这个时候子类并没有完成初始化，导致获取到子类的成员是<code>null</code>。</p><p>初始化的实际过程：</p><ol><li>在其他任何事物发生之前，将分配个对象的存储空间初始化成二进制的零。</li><li>如前所述那样调用基类构造器</li><li>按照声明的顺序调用成员的初始化方法</li><li>调用导出类的构造器主体</li></ol><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>由于向上转型会丢失具体的类型信息，所以我们就像，通过向下转型应该能获取到类型数据。然而，我们知道向上转型是安全的，因为基类不会具有大余导出类的接口。因此，我们通过基类接口发送的消息保证都可以接受。但是对于向下转型，就无法知道是哪个具体的对象了。</p><p>因此需要进行强制转换，但是如果强转失败会抛出<code>ClassCaseException</code>的异常，因此在使用向下转型的时候需要进行类别的判断，进行容错处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多态意味着不同的形式。我们持有从基类继承而来的相同接口，以及使用该接口的不同形式：不同版本的动态绑定方法。</p><p>为了在自己的程序中有效地运用多态乃至面向对象的技术，必须扩展自己的编程视野，使其不仅包括个别类的成员和消息，而且要包括类与类之间的共同特性以及它们之间的关系。尽管这需要极大的努力，但是这样做是非创值得的，因为它可以带来很多成效：更快的程序开发过程、更好的代码组织、更好的扩展的程序以及更容易的代码维护等。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 7-复用类</title>
      <link href="/article/thinking_in_java_7/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p>复用代码是 Java 众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制diamante并对之加以改变是不够的，它还必须能够做更多的事情。</p></blockquote><h2 id="组合用法"><a href="#组合用法" class="headerlink" title="组合用法"></a>组合用法</h2><p>这个用户最为常用，即在新建的类中，持有别的对象的引用。假设你需要某个对象，它要具有多个 String 对象，几个基本类型数据，以及另一个了类的对象，这种使用在开发中最为常见。对于非基本类型的对象，必须将其引用置于新的类中。</p><a id="more"></a><h2 id="继承用法"><a href="#继承用法" class="headerlink" title="继承用法"></a>继承用法</h2><p>组合的用法比较平实，但是继承使用的是一种特殊的语法。在继承过程中，需要先声明新类与旧类相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class People &#123;</span><br><span class="line">    People() &#123;</span><br><span class="line">        System.out.println(&quot;People&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    People(String name) &#123;</span><br><span class="line">        System.out.println(&quot;People&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Worker extends People&#123;</span><br><span class="line">    Worker() &#123;</span><br><span class="line">        System.out.println(&quot;Worker&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Worker(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        System.out.println(&quot;Worker&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Worker &#123;</span><br><span class="line">    Student() &#123;</span><br><span class="line">        System.out.println(&quot;Student&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        System.out.println(&quot;Student&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">People</span><br><span class="line">Worker</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><p>这种继承关系的又叫做父子关系，子类继承了所有父类的特点，即公开成员变量和公开的方法，当调初始化子类构造函数的时候，会默认调用父类的无参构造函数。当然你也可以通过<code>super</code>的方式主动选择调用父类的某个构造函数。</p><h2 id="组合加继承的方式"><a href="#组合加继承的方式" class="headerlink" title="组合加继承的方式"></a>组合加继承的方式</h2><p>同时使用组合和继承也是非常常见的事。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CADSystem system = new CADSystem(4);</span><br><span class="line">        try &#123;</span><br><span class="line">            // ..</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            system.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    Shape(int i) &#123;</span><br><span class="line">        System.out.println(&quot;Shape construct&quot;);</span><br><span class="line">        age = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Shape dispose&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;age:&quot; + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CADSystem extends Shape &#123;</span><br><span class="line"></span><br><span class="line">    private line[] lines = new line[3];</span><br><span class="line">    private Circle circle;</span><br><span class="line">    private Rect rect;</span><br><span class="line">    CADSystem(int i) &#123;</span><br><span class="line">        super(i);</span><br><span class="line">        for (int j = 0; j &lt; lines.length; j++) &#123;</span><br><span class="line">            lines[j] = new line(j);</span><br><span class="line">        &#125;</span><br><span class="line">        circle = new Circle(i);</span><br><span class="line">        rect = new Rect(i);</span><br><span class="line">        System.out.println(&quot;CADSystem construct&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void dispose() &#123;</span><br><span class="line">        for (line line : lines) &#123;</span><br><span class="line">            line.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        circle.dispose();</span><br><span class="line">        rect.dispose();</span><br><span class="line">        super.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class line extends Shape &#123;</span><br><span class="line"></span><br><span class="line">    line(int i) &#123;</span><br><span class="line">        super(i);</span><br><span class="line">        System.out.println(&quot;Line construct &quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;line dispose&quot;);</span><br><span class="line">        super.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line"></span><br><span class="line">    Circle(int i) &#123;</span><br><span class="line">        super(i);</span><br><span class="line">        System.out.println(&quot;Circle construct&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Circle dispose&quot;);</span><br><span class="line">        super.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rect extends Shape &#123;</span><br><span class="line"></span><br><span class="line">    Rect(int i) &#123;</span><br><span class="line">        super(i);</span><br><span class="line">        System.out.println(&quot;Rect construct&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Rect dispose&quot;);</span><br><span class="line">        super.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有点像类的适配器模式，模拟这样的一种行为，平时画画结束的时候，需要对资源进行清理。<code>Line</code> <code>Circle</code> 和 <code>Rect</code>都是画图工具，同时继承了<code>Shape</code>这个基类，并继承了<code>dispose</code>释放方法。</p><p><code>CADSystem</code> 也继承了<code>Shape</code>，并同时用三种工具的引用。在创建<code>CADSystem</code>的时候也完成了工具的初始化，释放资源的时候，遍历所有工具并释放资源。</p><h2 id="在组合和继承之间选择"><a href="#在组合和继承之间选择" class="headerlink" title="在组合和继承之间选择"></a>在组合和继承之间选择</h2><p>组合和继承都允许在新的类中放置子对象，组合是显示地这样做，而继承是隐式的做。</p><p>组合技术通常用于想在新的类中使用现有类的功能而非它的接口这种情况。即在新的类中嵌入某个对象，让其实现所需要的功能，但新的类用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。</p><p>继承侧重的是新类和基类之间的关系，这种关系可以用新类是现有类的一种类型这句话加以概括。<br>这个时候要提到一个用语「向上转型」，在继承图中可以看出，基类位于上端，子类位于下端，子类转成基类就是「向上转型」，因此向上转型是安全的。到这也可以这么说，一个最清晰的判断是用继承还是组合的办法：问一问自己是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必须的，但如果不需要，则应当好好考虑是否需要继承。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>指无法改变的，不想做改变可能出于两种理由：设计或效率。<code>final</code>修饰基本类型时，数值恒定不变；修饰对象引用，引用恒定不变。修饰方法，子类不能重写该方法，修饰类，该类不能被继承。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>继承和组合都能从现有类型生成新类型，组合一般是将现有类型作为新类型底层实现的一部分加以复用，二继承复用的是接口。</p><p>在使用继承时，由于导出类具有基类接口，因此它可以向上转型，这对多态来讲至关重要。</p><p>尽管面向对象编程对继承极力强调，但在开始一个设计时，一般优先选择使用组合，只在确实必要时才使用继承。因为组合更具有灵活性，此外，通过对成员类型使用继承技术的添加技巧，可以在运行时改变那些成员对象的类型和行为。</p><p>当你开始设计一个系统时，应该认识到程序开发是一个增量过程，犹如人类的学习一样，这一点很重要。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 6-访问权限控制</title>
      <link href="/article/thinking_in_java_6/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我还记得第一次面试的时候，就是问 <code>public</code>、<code>protected</code>和<code>private</code>的区别，当时技术很渣，虽然知道是什么意思，但是表述的不是那么清楚，当时搞得自己很紧张，后面的问题也没有回答的很好。。。</p><blockquote><p>访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关</p></blockquote><h2 id="Java-访问权限修饰词"><a href="#Java-访问权限修饰词" class="headerlink" title="Java 访问权限修饰词"></a>Java 访问权限修饰词</h2><p><strong>public</strong></p><p>使用关键字<code>public</code>关键字，就意味着<code>public</code>之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。</p><p><strong>protected</strong></p><p>继承访问权限，通过继承可以利用一个现有类~我们将其称为基类，基类的创建者会希望有某个特定成员，把它的访问权限赋予派生类而不是所有类。<code>protected</code>也提供包访问权限，也就是说，相同包内的其他类也可以访问<code>protected</code>元素。</p><p><strong>private</strong></p><p>除了包含该成员的类之外，其他任何类都无法访问这个成员，等于说是隔离了自己。</p><a id="more"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>控制对成员的访问权限与两个方面。第一是为了使用户不要碰触哪些他们不该碰触的地方，这些部分对于类内部的操作是必要的。但是它并不属于客户端程序员所需接口的一部分。因此将方法和域指定成<code>private</code>对客户端程序而言是一种保护服务。因为这样他们可以很清楚地看到什么对他们重要，什么他们是可以忽略的。这样简化了他们对类的理解。</p><p>第二个原因，也是最重要的原因，是为了让类库设计者可以更改类的内部工作方式，而不必担心这样会对客户端程序产生重大的影响。例如，最初可能会以某一种方式创建一个类，然后发现如果更改程序的内部程序结构，可以大大提高运行速度，如果接口和实现可以明确隔离和加以保护，那么就可以实现这一目的，而不必强制客户端程序员重现编写代码。访问权限控制可以确保不会有任何客户端程序员依赖某个类的底层实现的任何部分。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 5-初始化与清理</title>
      <link href="/article/thinking_in_java_5/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p>随着计算机革命的发展，不安全的编码方式逐渐成为编程代价高昂的主因之一。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初始化和清理是涉及程序安全的了两个问题，如果处理不好的话，很容易在运行的时候出现奔溃，造成很不好的用户体验。首先初始化，在开发的过程中，每当创建基本类型或者是其他对象，都会下意识的初始化，虽然全局变量会默认有个初始值，局部变量编译时期就会报错，但是我们还是要养成创建同时初始化的好习惯。至于清理，不像 <code>C/C++</code>内存需要自己分配和释放，<code>Java</code>内置的虚拟机，已经帮助我们完成这件事情了，但是在开发的过程中，还是要注意一些资源的释放，免得造成内存泄漏等异常。</p><a id="more"></a><h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>如果每个对象都要构造一个<code>Initialize()</code>的方法，显然是不实际的，总不能让每次创建对象的时候都去调用这个方法吧。因此<code>Java</code>引入了构造函数这个概念。</p><pre><code>Student(int age) {    System.out.println(&quot;student init age:&quot; + age);}</code></pre><p>有点类似方法的形式，名称和类名保持一致，首字母大写，可选择携带参数，无返回值。</p><pre><code>new Student(12);</code></pre><p>这个时候将会分配存储空间，并调用相应的构造器，这就确保了在你能操作对象之前，它已经被恰当的初始化了。</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>拥有名称重复的方法，但是参数的个数或者类型要不一致，构造函数亦然。那<code>Java</code>如何知道是哪一个方法呢？其实规则很简单：每个重载方法都必须有一个独一无二的参数类型列表。</p><p>甚至参数顺序的不同也足以区分两个方法，不过一般情况下别这么做，因为会使代码难以维护。</p><p>那为什么不以返回值区分重载方法呢？</p><pre><code>void f();int f();</code></pre><p><code>int a = f()</code>这种确实可以区分，但是<code>f()</code>这种方式编译器就不知道你需要调用的是哪个方法了。</p><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p><code>this</code>关键字只能在方法中使用，表示对调用方法的那个对象的引用。<code>this</code>的用法和其他对象引用并无不同，但要注意的是，如果在方法内部调用同一个类和同一个方法，就不必使用<code>this</code>，直接调用即可。</p><p>构造函数中是可以调用自身的构造器的，常见的就是创建一个自定义<code>view</code>,这个时候默认创建 4 个构造函数，最终都是调用最长的那个构造函数。</p><pre><code>class People {    People(){        this(12, &quot;default&quot;);    }    People(int age){        this(age, &quot;default&quot;);    }    People(int age, String name){        //....    }}</code></pre><p><code>static</code>就更好理解了，<code>static</code>方法就是没有<code>this</code>的方法，在<code>static</code>方法的内部不能调用非静态方法，反过来是可以的。</p><h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><p><code>Java</code>里的对象并非总是被垃圾回收，主要有三个特点：</p><ol><li>对象可能不被垃圾回收。</li><li>垃圾回收并不等于析构。</li><li>垃圾回收只与内存有关。</li></ol><p><strong>finalize</strong></p><p><code>Java</code>允许在类中定义一个名为<code>finalize</code>的方法，它的工作原理假定是这样的：一旦下一次垃圾回收器准备好释放对象占用的内存空间，将首先调用一个名为<code>finalize</code>的方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存，所以要是你打算用<code>finalize()</code>，就能在垃圾回收时刻做一些重要的清理工作。但是它是无法预料，常常是危险的，总之是多余的。</p><p><strong>垃圾回收器如何工作</strong></p><p>在以前，在堆上分配对象的代价十分昂贵，然而垃圾回收期对于提高对象的创建速度，却有明显的效果，这意味着<code>Java</code>从堆分配空间的速度，可以和其他语言从堆栈中分配空间的速度相媲美。</p><p>「引用计数」是一种简单但是速度很慢的垃圾回收技术。每个对象都要有一个引用计数器。当有引用连接至对象时，引用计数就加1，当引用离开对象或被置为<code>null</code>。虽然管理引用计数的开销不大，但这项开销在整个程序生命周期中将持续发生，垃圾回收期会在含有全部对象的列表上遍历，当发现对象的引用计数为 0 时，就释放器占用的控件，这种方法有个缺陷，当对象之间存在循环引用，虽然引用计数不为零，但是其实这个对象应当被回收，因此引用计数似乎未被应用于任何一种<code>Java</code>虚拟机实现中。</p><p>现在有一种区别于引用计数技术，它们依据的思想是：对任何“活”的对象，一定能最终追溯其存活在堆栈或静态存储区中的引用。这就解决了交互自引用的对象组的问题。</p><p>在这种技术下，<code>Java</code>虚拟机将采用一种「自适应」的垃圾回收技术。至于如何处理找到存活的对象，取决于不同的<code>Java</code>虚拟机实现。</p><p>「停止-复制」，需要暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新的堆中时，它们是一个挨着一个，所以新堆保持紧凑排列，然后可以分配新空间了。对于这种方式，效率会降低，这有两个原因。首先两个堆，然后得在这两个分离的堆之间来回倒腾，从而维护比实际需要多一倍的空间。某些<code>Java</code>虚拟机对此问题的处理方式是：按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。第二个问题在于复制，程序进入稳定状态之后，可能会产生少量垃圾，甚至没有垃圾，尽管如此，复制式回收器会将所有内存自一处复制到另一处，这很浪费。</p><p>为了避免这种浪费，一些<code>Java</code>虚拟机会进行检查，要是没有新垃圾产生，就会转换到另一种工作模式。</p><p>「标记-清扫」，对一般用途而言，速度相当慢，但是当你知道只会产生少量垃圾甚至不会产生垃圾时，它的速度就会非常快。它所依据的思路同样是从堆栈和静态存储区出发，便利所有的引用，进而找出所有存活的对象。每当找到一个存活对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才开始。不会发生复制动作，所以剩下的对空间是不连续的，垃圾回收器要是希望得到连续的空间的话，就得重新整理剩下的对象。</p><p><code>Java</code>虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器效率降低的话，就切换到「标记-清扫」方式，同样，<code>Java</code>虚拟机会跟踪效果，要是堆空间出现很对碎片，就会切换回到「停止-复制」的方式，这就是「自适应」技术。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组是相同类型的、同一个标识符名称被封装到一个对象序列活基本类型数据序列。</p><p><strong>可变参数</strong></p><pre><code>public void f(Object... args) {    for (Object arg : args) {        System.out.println(arg);    }}Student student = new Student(2);student.f(&quot;x&quot;,2, &quot;dfa&quot;, 0.2f);// outputx2dfa0.2</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><pre><code>enum Color {    RED, BLUE, BLACK}Color red = Color.RED;switch (red) {    case RED:        System.out.println(&quot;red&quot;);        break;    case BLUE:        System.out.println(&quot;blue&quot;);        break;    default:        break;}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在<code>Java</code>中，垃圾回收器会自动为对象释放内存，所以在很多场合下，类似的清理方法在<code>Java</code>中就不太需要了(不过当要用的时候，你就只能自己动手了)。在不需要类似析构函数的行为的时候，<code>Java</code>的垃圾回收器可以极大地简化编程工作，而且在处理内存的时候也更安全，有些垃圾回收器甚至能清理其他资源，比如图形和文件句柄。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 4-控制执行流程</title>
      <link href="/article/thinking_in_java_4/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><p>就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在 Java 中，你要使用执行控制语句来做出选择。**</p><p>作为一名程序员，尤其经常接触业务需求的开发人员，那流程的接触是必不可少的，基本的用法也是很熟练，所以在这就不介绍流程的基础知识了，直接看代码。</p><a id="more"></a><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void checkGrade(int grade) &#123;</span><br><span class="line">        if (grade &gt;= 90) &#123;</span><br><span class="line">            System.out.println(&quot;优秀&quot;);</span><br><span class="line">        &#125; else if (grade &gt;= 80) &#123;</span><br><span class="line">            System.out.println(&quot;良好&quot;);</span><br><span class="line">        &#125; else if (grade &gt;= 70) &#123;</span><br><span class="line">            System.out.println(&quot;中等&quot;);</span><br><span class="line">        &#125; else if (grade &gt;= 60) &#123;</span><br><span class="line">            System.out.println(&quot;及格&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;不及格&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void testWhile() &#123;</span><br><span class="line">    int i = 1;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (i &lt;= 10) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    do &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; while (i &lt;= 10);</span><br><span class="line">    System.out.println(&quot;sum:&quot; + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void testFor() &#123;</span><br><span class="line">    for (int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">        if (i % 2 == 0) &#123;</span><br><span class="line">            System.out.println(i + &quot;是偶数&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot;是奇数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void testSwitch() &#123;</span><br><span class="line">    int sex = 0;</span><br><span class="line">    switch (sex) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            System.out.println(&quot;男性&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">            System.out.println(&quot;男性&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            System.out.println(&quot;未知&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 3-操作符</title>
      <link href="/article/thinking_in_java_3/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><p>在最底层，Java 中的数据是通过使用操作符来操作的。**</p><p> 作为一个开发将近一年的程序员，对这些基本的操作符的掌握还是算熟练的，因此就不过多介绍了，毕竟大家基本上都知道，但是还是把内容过了一遍，笔记就不赘述了。一切的理论都不如实践来的实际，遇到模棱两可的，不如直接通过程序跑一下进行验证。</p><a id="more"></a><h2 id="1-赋值"><a href="#1-赋值" class="headerlink" title="1. 赋值"></a>1. 赋值</h2><p>使用「=」，意思是 <strong>取右边的值，把它复制给左边，右值可以是任何数、变量或者是表达式，但左值必须是一个明确的已命名的变量。</strong></p><pre><code>Student a = new Student();Student b = new Student();a.name = &quot;a&quot;;b.name = &quot;b&quot;;a = b;System.out.println(&quot;a-&gt;&quot; + a + &quot;\tb-&gt;&quot; + b);b.name = &quot;c&quot;;System.out.println(&quot;a-&gt;&quot; + a + &quot;\tb-&gt;&quot; + b);System.out.println(&quot;---------------&quot;);</code></pre><p>输出：</p><pre><code>a-&gt;b    b-&gt;ba-&gt;c    b-&gt;c</code></pre><p>对象的赋值一般是值引用的传递。</p><h2 id="2-使用操作符时常犯的错"><a href="#2-使用操作符时常犯的错" class="headerlink" title="2. 使用操作符时常犯的错"></a>2. 使用操作符时常犯的错</h2><p>使用操作符时一个常犯的错就是，即使对表达式如何计算有点不确定，也不愿意使用括号。</p><pre><code>while (x = y) {    // ...}</code></pre><p><strong>x = y</strong> 属于合法表达式，但是结果是 int 类型的值，二 while 括号需要的是 boolean 值，因此在编译期即会报错。</p><h2 id="3-截尾和舍入"><a href="#3-截尾和舍入" class="headerlink" title="3. 截尾和舍入"></a>3. 截尾和舍入</h2><pre><code>int a = 0.6;int b = 0.4;int c = -0.6;int d = -0.4;</code></pre><p>最后的结果都是 0；</p><h2 id="4-运算溢出"><a href="#4-运算溢出" class="headerlink" title="4. 运算溢出"></a>4. 运算溢出</h2><pre><code>int big = Integer.MAX_VALUE;System.out.println(&quot;big = &quot; + big);int bigger = big * 2;System.out.println(&quot;bigger = &quot; + bigger);</code></pre><p>输出结果</p><pre><code>big = 2147483647bigger = -2</code></pre><p>虽然溢出了，但是并没有报错，运行时也不会出现异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对基本运算符的掌握是程序必备的技能，无论哪门语言基本上相通的，越基础的东西，越是需要搞透彻，在开发的过程中，可不能因为这么基础的东西犯错！</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 2-一切都是对象</title>
      <link href="/article/thinking_in_java_2/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><blockquote><p>如果我们说另一种不同的语言，那么我们就会觉得一个有些不同的世界。<br> —Luduing Wittgerstein(1889-1951)</p></blockquote><h2 id="1-用引用操作对象"><a href="#1-用引用操作对象" class="headerlink" title="1. 用引用操作对象"></a>1. 用引用操作对象</h2><p>尽管一切都是对象，但是操纵的标识符实际上是对象的一个「引用」，可以看做成日常生活中电视机和遥控器的关系。只要拥有遥控器，就能保持着与电视机的连接，对电视声音和节目的调整，实际上都是对遥控器(引用)的操作。</p><a id="more"></a><pre><code>String s;</code></pre><p>这里只是创建了引用，并不是对象，如果此时想 s 发送一个消息，就会返回一个运行时错误，这是因为此时 s 实际上并没有与任何对象有联系，因此一个安全的做饭就是，创建一个引用的同时，要对其进行初始化。</p><pre><code>String s = &quot;Hello wolrd</code></pre><p>但这里用到 Java 语言一个特性：字符串可以用带引号的文本初始化，通常，必须对对象采用一种更通用的初始化方法。</p><h2 id="2-必须由你创建所有对象"><a href="#2-必须由你创建所有对象" class="headerlink" title="2. 必须由你创建所有对象"></a>2. 必须由你创建所有对象</h2><p><strong>存储的位置</strong></p><p>程序运行时，对象是怎么进行防治安排的呢？有五个不同的地方可以存储数据：</p><ol><li><p><strong>寄存器。</strong> 这是最快的存储区，因为它位于不同于替他存储区的地方–处理器内部。但是寄存器的存储数量极其有限，所以寄存器的存储根据需求进行分配，你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。</p></li><li><p><strong>堆栈。</strong> 位于通用 RAM(随机访问存储器),但通过堆栈指针可以从处理器那里获得直接支持。堆栈指针如果向下移动，则分配新的内存，如果向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java 系统必须知道存储在堆栈内所有的确切的生命周期，以便上下移动堆栈指针，这也约束了程序的灵活性。</p></li><li><p><strong>堆。</strong>一种通用的内存池(也位于 RAM)，用于存储所有的 Java 对象，堆位于不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性，当需要一个对象时，只需要 new 写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配，当然，为这种灵活性必须付出相应的代价：用堆进行存储分配和清理可能比堆栈进行存储分配 需要更多的时间。</p></li><li><p><strong>常量存储。</strong> 常量通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。</p></li><li><p><strong>非 RAM 存储。</strong> 如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。</p></li></ol><p><strong>基本类型</strong></p><p>不同于其他的 Java 对象，创建出来的时候存储在堆中，基本类型创建并非是应用的自动变量，这个变量直接存储值，并置于堆栈中，因此更加的高效。</p><p>Java 中确定每种基本类型所占空间的大小，它们的大小并不像其他大多数语言那样所机器硬件架构的变化而变化。</p><table><thead><tr><th>基本类型</th><th style="text-align:center">大小</th><th style="text-align:center">最大值</th><th style="text-align:center">最小值</th></tr></thead><tbody><tr><td>boolen</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td>char</td><td style="text-align:center">16-bit</td><td style="text-align:center">Unicode 0</td><td style="text-align:center">Unicode 2^16-1</td></tr><tr><td>byte</td><td style="text-align:center">8-bit</td><td style="text-align:center">-128</td><td style="text-align:center">127</td></tr><tr><td>short</td><td style="text-align:center">16-bit</td><td style="text-align:center">-2^15</td><td style="text-align:center">2^15-1</td></tr><tr><td>int</td><td style="text-align:center">32-bit</td><td style="text-align:center">-2^31</td><td style="text-align:center">2^31-1</td></tr><tr><td>long</td><td style="text-align:center">64-bit</td><td style="text-align:center">-2^63</td><td style="text-align:center">2^63-1</td></tr><tr><td>float</td><td style="text-align:center">32-bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td></tr><tr><td>double</td><td style="text-align:center">64-bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td></tr><tr><td>void</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="3-创建新的数据类型：类"><a href="#3-创建新的数据类型：类" class="headerlink" title="3. 创建新的数据类型：类"></a>3. 创建新的数据类型：类</h2><p>如果一切都是对象，那么是什么决定了某一类对象的外观与行为呢？通过关键字 class 创建类。</p><p><strong>基本成员默认值</strong></p><table><thead><tr><th>基本类型</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td>boolen</td><td style="text-align:center">false</td></tr><tr><td>char</td><td style="text-align:center">‘\u0000’(null)</td></tr><tr><td>byte</td><td style="text-align:center">(byte)0</td></tr><tr><td>short</td><td style="text-align:center">(short)0</td></tr><tr><td>int</td><td style="text-align:center">0</td></tr><tr><td>long</td><td style="text-align:center">0L</td></tr><tr><td>float</td><td style="text-align:center">0.0f</td></tr><tr><td>double</td><td style="text-align:center">0.0d</td></tr></tbody></table><h2 id="4-static-关键字"><a href="#4-static-关键字" class="headerlink" title="4. static 关键字"></a>4. static 关键字</h2><p>通过 static 关键字可以满足两方面的需求：第一种，只想为特定域分哦诶单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不用创建对象。第二种，希望某个方法不与包含它的类的任何对象关联在一起，也就是说没有创建对象，也能够调用这个方法。及类数据和类方法两个概念。</p><h2 id="5-注释相关"><a href="#5-注释相关" class="headerlink" title="5. 注释相关"></a>5. 注释相关</h2><p>基础的就不介绍了，介绍一些标签示例：</p><p><strong>@see</strong></p><pre><code>@see className@see fully-qualified-className&amp;methodName</code></pre><p><strong>@link</strong></p><pre><code>{@link package.class#member label}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本章的学习，接触相当多的关于如何编写一个简单程序的 Java 编程知识，此外对 Java 语言及它的一些基本思想也有了一个总体认识。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Thinking in Java 读书笔记』—— 1-对象导论</title>
      <link href="/article/thinking_in_java_1/"/>
      <content type="html"><![CDATA[<p><a href="http://xiaweizi.cn/categories/Thinking-In-Java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Thinking in java 读书笔记</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从本章开始，逐渐记录笔者在阅读「Thinking in Java」时，内容的积累、代码的实践和个人编程的心得，重要的是个人的成长。正式工作将近一年的我，有必要重新温故一下<code>Java</code>的核心基础，巩固自身的硬实力，从根本感受<code>Java</code>语言的魅力，而不是局限于敲代码，完成产品需求。更重要的是领悟每种语言的特色，融入其中，提升自己，感受学习带来的快乐！足以！</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Java-五个基本特性"><a href="#1-Java-五个基本特性" class="headerlink" title="1. Java 五个基本特性"></a>1. Java 五个基本特性</h3><ol><li>万物皆为对象</li><li>程序是对象的集合，他们通过发送消息来告知彼此所要做的。</li><li>每个对象都有自己的由其他对象所构成的存储。</li><li>每个对象拥有其类型。</li><li>某一特定类型所有对象都已接收同样的消息。</li></ol><h3 id="2-每个对象都有一个接口"><a href="#2-每个对象都有一个接口" class="headerlink" title="2. 每个对象都有一个接口"></a>2. 每个对象都有一个接口</h3><h3 id="3-每个对象都提供服务"><a href="#3-每个对象都提供服务" class="headerlink" title="3. 每个对象都提供服务"></a>3. 每个对象都提供服务</h3><p>将对象看做是服务提供者有一个好处，它有助于提高对象的内聚性。这不仅在设计过程中非常有用，而且当其他人试图理解你的代码活重用某个对象时候， 如果他们看出对象多能提供的服务的价值，它会调整对象以适应其设计的过程变得简单很多。</p><h3 id="4-被隐藏的具体实现"><a href="#4-被隐藏的具体实现" class="headerlink" title="4. 被隐藏的具体实现"></a>4. 被隐藏的具体实现</h3><p>类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。这以为着类创建者可以任意修改被隐藏的部分，而不用担心对其他任何人造成影响，被隐藏的部分通常对象内部脆弱的部分，它们很容易被粗心或者不知内情的客户端程序员所毁坏，因此将实现隐藏起来可以减少程序的 bug。</p><h3 id="5-Java-用三个关键字在类的内部设定边界"><a href="#5-Java-用三个关键字在类的内部设定边界" class="headerlink" title="5. Java 用三个关键字在类的内部设定边界"></a>5. Java 用三个关键字在类的内部设定边界</h3><table><thead><tr><th>public</th><th style="text-align:center">private</th><th style="text-align:right">protected</th></tr></thead><tbody><tr><td>任何人都可以用</td><td style="text-align:center">除类型创建者和内部方法，任何人不能访问</td><td style="text-align:right">仅继承的成员可以访问</td></tr></tbody></table><h3 id="6-复用具体实现"><a href="#6-复用具体实现" class="headerlink" title="6. 复用具体实现"></a>6. 复用具体实现</h3><p>代码复用是面向对象程序设计语言所提供的最了不起的优点之一。在建立新类时，应该优先考虑组合，因为它更加简单灵活，如果采用这种方式，设计会变得更加清晰，一旦有了一些经验之后，便能够看出必须使用继承的场合了。</p><h3 id="7-继承"><a href="#7-继承" class="headerlink" title="7. 继承"></a>7. 继承</h3><p><img src="http://upload-images.jianshu.io/upload_images/4043475-d0294e2e99758f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继承"></p><pre><code>void doSomeThing(Shape shape) {    shape.draw();    // ....    shape.setColor(); }Circle circle = new Circle();doSomeThing(circle);</code></pre><p>当<code>Circle</code>被传入到预期接收的<code>Shape</code>，向上转型，这就是泛型的使用，当调用基类的方法时，会主动定位到指定的具体对象，调用该对象的具体实现方法。</p><h3 id="8-容器"><a href="#8-容器" class="headerlink" title="8. 容器"></a>8. 容器</h3><p>需要对容器有所选择，主要有两个原因：1. 不同容器提供了不同类型的接口和外部行为。堆栈相比于队列就具备不同的接口和行为。2. 不同的容器对某些操作具有不同的效率，最好的例子便是 <code>ArrayList</code> 和 <code>LinkedList</code>。</p><h3 id="9-对象的创建和生命周期"><a href="#9-对象的创建和生命周期" class="headerlink" title="9. 对象的创建和生命周期"></a>9. 对象的创建和生命周期</h3><p>在使用对象时，最关键的问题之一便是它们的生成和销毁方式，每个对象为了生存都需要资源，尤其是内存，当我们不再需要一个对象时候，它必须被清理掉，使其占有的资源可以被释放和重用。</p><h3 id="10-异常处理：处理错误"><a href="#10-异常处理：处理错误" class="headerlink" title="10. 异常处理：处理错误"></a>10. 异常处理：处理错误</h3><p>异常处理将错误处理直接置于编程语言中，有时候甚至置于操作系统中。异常处理不是面向对象的特征–尽管在面向对象语言中异常常被表示成一个对象，异常处理在面向对象语言出现之前就已经存在了。</p><h3 id="11-并发编程"><a href="#11-并发编程" class="headerlink" title="11. 并发编程"></a>11. 并发编程</h3><p>频发的操作不可能允许我们等上一个操作结束才能进行下一个操作，这个时候就需要并发执行，很早计算机就已经有了这个概念，就是在同一个时刻处理多个任务的思想。</p><h3 id="12-Java-与-Internet"><a href="#12-Java-与-Internet" class="headerlink" title="12. Java 与 Internet"></a>12. Java 与 Internet</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OOP 和 Java 也许并不适合所有人，重要的是正确评估自己的需求，并决定 Java 是否能够最好的满足这些需求，还是使用其他的编程系统才是更好的选择，如果知道自己的需求在可预见的未来会变得非常特殊，并且 Java 可能不满足你的具体限制，那么就应该考虑其他的选择了。</p>]]></content>
      
      <categories>
          
          <category> Thinking In Java 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking In Java </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
